.github\scripts\prevent_prohibited_workflows.py:16:5: ANN201 Missing return type annotation for public function `main`
   |
16 | def main():
   |     ^^^^ ANN201
17 |     """
18 |     Verifica si alguno de los archivos pasados como argumento es un workflow prohibido.
   |
   = help: Add return type annotation: `None`

backend-call-automation\api\routes.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from fastapi import APIRouter, HTTPException
2 | | from services.supabase_service import SupabaseService
3 | | from services.twilio_service import TwilioService
4 | |
5 | | from typing import Any
  | |______________________^ I001
6 |
7 |   router = APIRouter()
  |
  = help: Organize imports

backend-call-automation\api\routes.py:5:20: F401 [*] `typing.Any` imported but unused
  |
3 | from services.twilio_service import TwilioService
4 |
5 | from typing import Any
  |                    ^^^ F401
6 |
7 | router = APIRouter()
  |
  = help: Remove unused import: `typing.Any`

backend-call-automation\api\routes.py:13:11: ANN201 Missing return type annotation for public function `make_call`
   |
12 | @router.post("/calls/")
13 | async def make_call(data: dict[str, str]):
   |           ^^^^^^^^^ ANN201
14 |     try:
15 |         phone_number = data.get("phone_number")
   |
   = help: Add return type annotation

backend-call-automation\api\routes.py:17:13: TRY301 Abstract `raise` to an inner function
   |
15 |         phone_number = data.get("phone_number")
16 |         if not phone_number:
17 |             raise HTTPException(status_code=400, detail="Phone number is required")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
18 |
19 |         # Iniciar llamada con Twilio
   |

backend-call-automation\api\routes.py:27:9: TRY300 Consider moving this statement to an `else` block
   |
25 |         )
26 |
27 |         return {"status": "success", "call_sid": call.sid, "record_id": call_record.id}
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY300
28 |
29 |     except Exception as e:
   |

backend-call-automation\api\routes.py:30:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
29 |     except Exception as e:
30 |         raise HTTPException(status_code=500, detail=str(e))
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
   |

backend-call-automation\app\__init__.py:1:20: F401 `typing.Any` imported but unused
  |
1 | from typing import Any
  |                    ^^^ F401
  |
  = help: Remove unused import: `typing.Any`

backend-call-automation\app\api\campaigns.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from uuid import UUID
 2 | |
 3 | | from fastapi import APIRouter, Depends, HTTPException, Query
 4 | | from sqlalchemy.ext.asyncio import AsyncSession
 5 | |
 6 | | from app.crud.campaign import (
 7 | |     add_client_to_campaign,
 8 | |     create_campaign,
 9 | |     delete_campaign,
10 | |     get_campaign,
11 | |     get_campaigns,
12 | |     update_campaign,
13 | | )
14 | | from app.db.database import get_session
15 | | from app.schemas.campaign import Campaign, CampaignCreate, CampaignUpdate
16 | |
17 | | from typing import Any
   | |______________________^ I001
18 |
19 |   router = APIRouter(prefix="/api/campaigns", tags=["campaigns"])
   |
   = help: Organize imports

backend-call-automation\app\api\campaigns.py:17:20: F401 [*] `typing.Any` imported but unused
   |
15 | from app.schemas.campaign import Campaign, CampaignCreate, CampaignUpdate
16 |
17 | from typing import Any
   |                    ^^^ F401
18 |
19 | router = APIRouter(prefix="/api/campaigns", tags=["campaigns"])
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\api\campaigns.py:59:11: ANN201 Missing return type annotation for public function `delete_campaign_endpoint`
   |
58 | @router.delete("/{campaign_id}")
59 | async def delete_campaign_endpoint(campaign_id: UUID, db: AsyncSession = Depends(get_session)):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
60 |     deleted = await delete_campaign(db, campaign_id)
61 |     if not deleted:
   |
   = help: Add return type annotation

backend-call-automation\app\api\campaigns.py:67:11: ANN201 Missing return type annotation for public function `add_client_to_campaign_endpoint`
   |
66 | @router.post("/{campaign_id}/clients/{client_id}")
67 | async def add_client_to_campaign_endpoint(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
68 |     campaign_id: UUID, client_id: UUID, db: AsyncSession = Depends(get_session)
69 | ):
   |
   = help: Add return type annotation

backend-call-automation\app\api\campaigns.py:72:9: TRY300 Consider moving this statement to an `else` block
   |
70 |     try:
71 |         await add_client_to_campaign(db, campaign_id, client_id)
72 |         return {"message": "Client added to campaign successfully"}
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY300
73 |     except ValueError as e:
74 |         raise HTTPException(status_code=400, detail=str(e))
   |

backend-call-automation\app\api\campaigns.py:74:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
72 |         return {"message": "Client added to campaign successfully"}
73 |     except ValueError as e:
74 |         raise HTTPException(status_code=400, detail=str(e))
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
   |

backend-call-automation\app\api\endpoints\cache.py:42:48: TRY401 Redundant exception object included in `logging.exception` call
   |
41 |     except Exception as e:
42 |         logger.exception(f"Error en precarga: {e!s}")
   |                                                ^ TRY401
43 |         raise HTTPException(status_code=500, detail=f"Error al iniciar precarga: {e!s}") from e
   |

backend-call-automation\app\api\endpoints\cache.py:76:54: TRY401 Redundant exception object included in `logging.exception` call
   |
75 |     except Exception as e:
76 |         logger.exception(f"Error en sincronización: {e!s}")
   |                                                      ^ TRY401
77 |         raise HTTPException(
78 |             status_code=500, detail=f"Error al iniciar sincronización: {e!s}"
   |

backend-call-automation\app\api\endpoints\cache.py:99:9: TRY300 Consider moving this statement to an `else` block
    |
 97 |         metrics = await cache_service.get_metrics()
 98 |
 99 |         return metrics
    |         ^^^^^^^^^^^^^^ TRY300
100 |
101 |     except Exception as e:
    |

backend-call-automation\app\api\endpoints\cache.py:99:16: RET504 Unnecessary assignment to `metrics` before `return` statement
    |
 97 |         metrics = await cache_service.get_metrics()
 98 |
 99 |         return metrics
    |                ^^^^^^^ RET504
100 |
101 |     except Exception as e:
    |
    = help: Remove unnecessary assignment

backend-call-automation\app\api\endpoints\cache.py:102:56: TRY401 Redundant exception object included in `logging.exception` call
    |
101 |     except Exception as e:
102 |         logger.exception(f"Error al obtener métricas: {e!s}")
    |                                                        ^ TRY401
103 |         raise HTTPException(status_code=500, detail=f"Error al obtener métricas: {e!s}") from e
104 | from typing import Any
    |

backend-call-automation\app\api\endpoints\cache.py:104:1: E402 Module level import not at top of file
    |
102 |         logger.exception(f"Error al obtener métricas: {e!s}")
103 |         raise HTTPException(status_code=500, detail=f"Error al obtener métricas: {e!s}") from e
104 | from typing import Any
    | ^^^^^^^^^^^^^^^^^^^^^^ E402
    |

backend-call-automation\app\api\endpoints\cache.py:104:20: F401 [*] `typing.Any` imported but unused
    |
102 |         logger.exception(f"Error al obtener métricas: {e!s}")
103 |         raise HTTPException(status_code=500, detail=f"Error al obtener métricas: {e!s}") from e
104 | from typing import Any
    |                    ^^^ F401
    |
    = help: Remove unused import: `typing.Any`

backend-call-automation\app\api\endpoints\calls.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import logging
2 | |
3 | | from fastapi import APIRouter, WebSocket, WebSocketDisconnect
4 | |
5 | | from app.services.call_service import CallService
6 | |
7 | | from typing import Any
  | |______________________^ I001
8 |
9 |   router = APIRouter()
  |
  = help: Organize imports

backend-call-automation\app\api\endpoints\calls.py:7:20: F401 [*] `typing.Any` imported but unused
  |
5 | from app.services.call_service import CallService
6 |
7 | from typing import Any
  |                    ^^^ F401
8 |
9 | router = APIRouter()
  |
  = help: Remove unused import: `typing.Any`

backend-call-automation\app\api\endpoints\calls.py:83:59: TRY401 Redundant exception object included in `logging.exception` call
   |
81 |     except Exception as e:
82 |         # Manejar otros errores
83 |         logging.exception(f"Error en websocket de audio: {e!s}")
   |                                                           ^ TRY401
84 |         await call_service.end_call(call_id)
85 |         raise
   |

backend-call-automation\app\config\ai_config.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from pydantic_settings import BaseSettings
2 | |
3 | | # Importar los prompts optimizados
4 | | from app.config.campaign_prompts import CAMPAIGN_PROMPTS, DEFAULT_VALUES, REQUIRED_VARIABLES
5 | |
6 | |
7 | | from typing import Any
  | |______________________^ I001
8 |
9 |   class AISettings(BaseSettings):
  |
  = help: Organize imports

backend-call-automation\app\config\ai_config.py:7:20: F401 [*] `typing.Any` imported but unused
  |
7 | from typing import Any
  |                    ^^^ F401
8 |
9 | class AISettings(BaseSettings):
  |
  = help: Remove unused import: `typing.Any`

backend-call-automation\app\config\campaign_prompts.py:1:20: F401 [*] `typing.Any` imported but unused
  |
1 | from typing import Any
  |                    ^^^ F401
2 |
3 | """
  |
  = help: Remove unused import: `typing.Any`

backend-call-automation\app\config\database.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 | / from app.config.dependencies import get_supabase_client
 7 | |
 8 | | from typing import Any
   | |______________________^ I001
 9 |
10 |   __all__ = ["get_supabase_client"]
   |
   = help: Organize imports

backend-call-automation\app\config\database.py:8:20: F401 [*] `typing.Any` imported but unused
   |
 6 | from app.config.dependencies import get_supabase_client
 7 |
 8 | from typing import Any
   |                    ^^^ F401
 9 |
10 | __all__ = ["get_supabase_client"]
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\config\dependencies.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from collections.abc import AsyncGenerator
 2 | | from functools import lru_cache
 3 | |
 4 | | from fastapi import Depends
 5 | |
 6 | | from app.config.settings import get_settings
 7 | | from app.services.call_service import CallService
 8 | | from app.services.campaign_scheduler import CampaignScheduler
 9 | | from app.services.campaign_service import CampaignService
10 | | from app.services.contact_service import ContactService
11 | | from app.services.twilio_service import TwilioService  # Importar TwilioService
12 | | from supabase import Client, create_client
13 | |
14 | | from typing import Any
   | |______________________^ I001
15 |
16 |   settings = get_settings()
   |
   = help: Organize imports

backend-call-automation\app\config\dependencies.py:14:20: F401 [*] `typing.Any` imported but unused
   |
12 | from supabase import Client, create_client
13 |
14 | from typing import Any
   |                    ^^^ F401
15 |
16 | settings = get_settings()
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\config\dependencies.py:55:11: ANN201 Missing return type annotation for public function `get_contact_service`
   |
54 | @lru_cache
55 | async def get_contact_service(supabase: Client = Depends(get_supabase_client)):
   |           ^^^^^^^^^^^^^^^^^^^ ANN201
56 |     """
57 |     Returns a cached Contact service instance
   |
   = help: Add return type annotation

backend-call-automation\app\config\metrics_config.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Configuración centralizada para el sistema de métricas y monitoreo."""
 2 |
 3 | / from functools import lru_cache
 4 | |
 5 | | from pydantic_settings import BaseSettings
 6 | |
 7 | |
 8 | | from typing import Any
   | |______________________^ I001
 9 |
10 |   class MetricsSettings(BaseSettings):
   |
   = help: Organize imports

backend-call-automation\app\config\metrics_config.py:8:20: F401 [*] `typing.Any` imported but unused
   |
 8 | from typing import Any
   |                    ^^^ F401
 9 |
10 | class MetricsSettings(BaseSettings):
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\config\redis_client.py:3:25: F401 [*] `typing.Optional` imported but unused
  |
1 | import json
2 | import logging
3 | from typing import Any, Optional
  |                         ^^^^^^^^ F401
4 |
5 | from redis import Redis
  |
  = help: Remove unused import: `typing.Optional`

backend-call-automation\app\config\redis_client.py:19:41: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   |
19 | async def set_in_cache(key: str, value: Any, expire: int = 3600) -> bool:
   |                                         ^^^ ANN401
20 |     """Guarda valor en caché con expiración.
   |

backend-call-automation\app\config\redis_client.py:32:9: TRY300 Consider moving this statement to an `else` block
   |
30 |     try:
31 |         redis_client.setex(key, expire, json.dumps(value))
32 |         return True
   |         ^^^^^^^^^^^ TRY300
33 |     except Exception as e:
34 |         logger.error(f"Error al guardar en caché: {e!s}")
   |

backend-call-automation\app\config\redis_client.py:34:9: TRY400 Use `logging.exception` instead of `logging.error`
   |
32 |         return True
33 |     except Exception as e:
34 |         logger.error(f"Error al guardar en caché: {e!s}")
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
35 |         return False
   |
   = help: Replace with `exception`

backend-call-automation\app\config\redis_client.py:38:39: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `get_from_cache`
   |
38 | async def get_from_cache(key: str) -> Any:
   |                                       ^^^ ANN401
39 |     """Recupera valor de caché.
   |

backend-call-automation\app\config\redis_client.py:53:9: TRY300 Consider moving this statement to an `else` block
   |
51 |             value_str = value.decode("utf-8") if isinstance(value, bytes) else value
52 |             return json.loads(value_str)
53 |         return None
   |         ^^^^^^^^^^^ TRY300
54 |     except Exception as e:
55 |         logger.error(f"Error al recuperar de caché: {e!s}")
   |

backend-call-automation\app\config\redis_client.py:55:9: TRY400 Use `logging.exception` instead of `logging.error`
   |
53 |         return None
54 |     except Exception as e:
55 |         logger.error(f"Error al recuperar de caché: {e!s}")
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
56 |         return None
   |
   = help: Replace with `exception`

backend-call-automation\app\config\redis_client.py:71:9: TRY400 Use `logging.exception` instead of `logging.error`
   |
69 |         return bool(redis_client.delete(key))
70 |     except Exception as e:
71 |         logger.error(f"Error al eliminar de caché: {e!s}")
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
72 |         return False
   |
   = help: Replace with `exception`

backend-call-automation\app\config\redis_client.py:91:9: TRY400 Use `logging.exception` instead of `logging.error`
   |
89 |         )
90 |     except Exception as e:
91 |         logger.error(f"Error al obtener métricas de caché: {e!s}")
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
92 |         return CacheMetrics(total_keys=0, memory_used="0", hit_rate=0.0, uptime=0)
   |
   = help: Replace with `exception`

backend-call-automation\app\config\redis_client.py:126:17: SIM108 Use ternary operator `entity_id = key.split(":", 1)[1] if ":" in key else key` instead of `if`-`else`-block
    |
124 |               if value:
125 |                   # Extraer ID de la clave (asumiendo formato "prefix:id")
126 | /                 if ":" in key:
127 | |                     entity_id = key.split(":", 1)[1]
128 | |                 else:
129 | |                     entity_id = key
    | |___________________________________^ SIM108
130 |
131 |                   # Upsert a Supabase
    |
    = help: Replace `if`-`else`-block with `entity_id = key.split(":", 1)[1] if ":" in key else key`

backend-call-automation\app\config\redis_client.py:136:9: TRY300 Consider moving this statement to an `else` block
    |
134 |                 ).execute()
135 |
136 |         return True
    |         ^^^^^^^^^^^ TRY300
137 |     except Exception as e:
138 |         logger.error(f"Error al sincronizar con Supabase: {e!s}")
    |

backend-call-automation\app\config\redis_client.py:138:9: TRY400 Use `logging.exception` instead of `logging.error`
    |
136 |         return True
137 |     except Exception as e:
138 |         logger.error(f"Error al sincronizar con Supabase: {e!s}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
139 |         return False
    |
    = help: Replace with `exception`

backend-call-automation\app\config\redis_client.py:150:9: TRY300 Consider moving this statement to an `else` block
    |
148 |     try:
149 |         redis_client.flushdb()
150 |         return True
    |         ^^^^^^^^^^^ TRY300
151 |     except Exception as e:
152 |         logger.error(f"Error al limpiar caché: {e!s}")
    |

backend-call-automation\app\config\redis_client.py:152:9: TRY400 Use `logging.exception` instead of `logging.error`
    |
150 |         return True
151 |     except Exception as e:
152 |         logger.error(f"Error al limpiar caché: {e!s}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
153 |         return False
    |
    = help: Replace with `exception`

backend-call-automation\app\config\settings.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import os  # Importar os
 2 | | from functools import lru_cache
 3 | |
 4 | | from pydantic import ConfigDict, Field
 5 | | from pydantic_settings import BaseSettings
 6 | |
 7 | |
 8 | | from typing import Any
   | |______________________^ I001
 9 |
10 |   class Settings(BaseSettings):
   |
   = help: Organize imports

backend-call-automation\app\config\settings.py:8:20: F401 [*] `typing.Any` imported but unused
   |
 8 | from typing import Any
   |                    ^^^ F401
 9 |
10 | class Settings(BaseSettings):
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\config\settings.py:63:29: S105 Possible hardcoded password assigned to: "VAULT_TOKEN_FILE"
   |
61 |     # Vault Configuration (Required for production)
62 |     VAULT_ADDR: str = "http://vault:8200"
63 |     VAULT_TOKEN_FILE: str = "/run/secrets/vault-token"
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ S105
64 |     VAULT_MOUNT_POINT: str = "kv"
65 |     VAULT_PATH: str = "elevenlabs"
   |

backend-call-automation\app\config\settings.py:89:9: ERA001 Found commented-out code
   |
88 |     model_config = ConfigDict(
89 |         # env_file=".env", # Se definirá dinámicamente en get_settings
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
90 |         env_file_encoding="utf-8",
91 |         case_sensitive=True,
   |
   = help: Remove commented-out code

backend-call-automation\app\config\settings.py:110:101: E501 Line too long (106 > 100)
    |
108 |     # Pasar _env_file explícitamente
109 |     # Pydantic-settings buscará este archivo
110 |     # Si env_filename tampoco existe, _env_file será None y pydantic-settings buscará variables de entorno
    |                                                                                                     ^^^^^^ E501
111 |     return Settings(_env_file=env_filename if os.path.exists(env_filename) else None)
    |

backend-call-automation\app\config\supabase.py:13:1: I001 [*] Import block is un-sorted or un-formatted
   |
11 |   """
12 |
13 | / import os
14 | | import sys
15 | | import logging
16 | | from pathlib import Path
17 | | from typing import Optional
18 | | from unittest.mock import MagicMock
19 | |
20 | | from dotenv import load_dotenv
21 | |
22 | | from supabase import Client, create_client
   | |__________________________________________^ I001
23 |
24 |   # Configurar logger
   |
   = help: Organize imports

backend-call-automation\app\config\supabase.py:28:5: ANN201 Missing return type annotation for public function `load_env_files`
   |
27 | # Cargar variables de entorno según el entorno
28 | def load_env_files():
   |     ^^^^^^^^^^^^^^ ANN201
29 |     """Carga los archivos de variables de entorno apropiados."""
30 |     # Directorio base del proyecto
   |
   = help: Add return type annotation: `None`

backend-call-automation\app\config\supabase.py:59:18: UP007 [*] Use `X | Y` for type annotations
   |
58 | # Inicializar cliente como None para manejar errores
59 | supabase_client: Optional[Client] = None
   |                  ^^^^^^^^^^^^^^^^ UP007
60 |
61 | # En entorno de prueba, usar valores por defecto si no están definidos
   |
   = help: Convert to `X | Y`

backend-call-automation\app\config\supabase.py:83:9: TRY400 Use `logging.exception` instead of `logging.error`
   |
81 |     else:
82 |         # En producción, propagar el error
83 |         logger.error(f"Failed to create Supabase client: {e!s}")
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
84 |         raise ValueError(f"Error creating Supabase client: {e!s}") from e
   |
   = help: Replace with `exception`

backend-call-automation\app\config\supabase.py:84:15: TRY003 Avoid specifying long messages outside the exception class
   |
82 |         # En producción, propagar el error
83 |         logger.error(f"Failed to create Supabase client: {e!s}")
84 |         raise ValueError(f"Error creating Supabase client: {e!s}") from e
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
   |

backend-call-automation\app\dependencies\__init__.py:4:1: I001 [*] Import block is un-sorted or un-formatted
   |
 2 |   Módulo de dependencias para la inyección de dependencias en FastAPI.
 3 |   """
 4 | / from typing import Any
 5 | |
 6 | | # Importar las dependencias de servicio para que estén disponibles al importar app.dependencies
 7 | | from app.dependencies.service_dependencies import AIConversationServiceDep
 8 | | from app.dependencies.service_dependencies import AudioCacheServiceDep
 9 | | from app.dependencies.service_dependencies import CallServiceDep
10 | | from app.dependencies.service_dependencies import CampaignServiceDep
11 | | from app.dependencies.service_dependencies import ContactServiceDep
12 | | from app.dependencies.service_dependencies import ElevenLabsServiceDep
13 | | from app.dependencies.service_dependencies import EnhancedAIConversationServiceDep
14 | | from app.dependencies.service_dependencies import TwilioServiceDep
15 | | from app.dependencies.service_dependencies import get_ai_conversation_service
16 | | from app.dependencies.service_dependencies import get_audio_cache_service
17 | | from app.dependencies.service_dependencies import get_call_service
18 | | from app.dependencies.service_dependencies import get_campaign_service
19 | | from app.dependencies.service_dependencies import get_contact_service
20 | | from app.dependencies.service_dependencies import get_elevenlabs_service
21 | | from app.dependencies.service_dependencies import get_enhanced_ai_conversation_service
22 | | from app.dependencies.service_dependencies import get_twilio_service
   | |____________________________________________________________________^ I001
23 |
24 |   __all__ = [
   |
   = help: Organize imports

backend-call-automation\app\dependencies\__init__.py:4:20: F401 `typing.Any` imported but unused
  |
2 | Módulo de dependencias para la inyección de dependencias en FastAPI.
3 | """
4 | from typing import Any
  |                    ^^^ F401
5 |
6 | # Importar las dependencias de servicio para que estén disponibles al importar app.dependencies
  |
  = help: Remove unused import: `typing.Any`

backend-call-automation\app\dependencies\service_dependencies.py:5:1: I001 [*] Import block is un-sorted or un-formatted
   |
 3 |   """
 4 |
 5 | / from typing import Annotated, Optional, Any
 6 | |
 7 | | from fastapi import Depends
 8 | |
 9 | | from app.services.ai_conversation_service import AIConversationService
10 | | from app.services.audio_cache_service import AudioCacheService
11 | | from app.services.call_service import CallService
12 | | from app.services.campaign_service import CampaignService
13 | | from app.services.contact_service import ContactService
14 | | from app.services.elevenlabs_service import ElevenLabsService
15 | | from app.services.enhanced_ai_conversation_service import EnhancedAIConversationService
16 | | from app.services.twilio_service import TwilioService
   | |_____________________________________________________^ I001
17 |
18 |   # Singleton instances
   |
   = help: Organize imports

backend-call-automation\app\dependencies\service_dependencies.py:5:31: F401 [*] `typing.Optional` imported but unused
  |
3 | """
4 |
5 | from typing import Annotated, Optional, Any
  |                               ^^^^^^^^ F401
6 |
7 | from fastapi import Depends
  |
  = help: Remove unused import

backend-call-automation\app\dependencies\service_dependencies.py:5:41: F401 [*] `typing.Any` imported but unused
  |
3 | """
4 |
5 | from typing import Annotated, Optional, Any
  |                                         ^^^ F401
6 |
7 | from fastapi import Depends
  |
  = help: Remove unused import

backend-call-automation\app\dependencies\service_dependencies.py:36:12: PLW0603 Using the global statement to update `_call_service` is discouraged
   |
34 |         CallService: Instancia del servicio de llamadas
35 |     """
36 |     global _call_service
   |            ^^^^^^^^^^^^^ PLW0603
37 |     if _call_service is None:
38 |         _call_service = CallService()
   |

backend-call-automation\app\dependencies\service_dependencies.py:49:12: PLW0603 Using the global statement to update `_twilio_service` is discouraged
   |
47 |         TwilioService: Instancia del servicio de Twilio
48 |     """
49 |     global _twilio_service
   |            ^^^^^^^^^^^^^^^ PLW0603
50 |     if _twilio_service is None:
51 |         _twilio_service = TwilioService()
   |

backend-call-automation\app\dependencies\service_dependencies.py:62:12: PLW0603 Using the global statement to update `_campaign_service` is discouraged
   |
60 |         CampaignService: Instancia del servicio de campañas
61 |     """
62 |     global _campaign_service
   |            ^^^^^^^^^^^^^^^^^ PLW0603
63 |     if _campaign_service is None:
64 |         _campaign_service = CampaignService()
   |

backend-call-automation\app\dependencies\service_dependencies.py:75:12: PLW0603 Using the global statement to update `_contact_service` is discouraged
   |
73 |         ContactService: Instancia del servicio de contactos
74 |     """
75 |     global _contact_service
   |            ^^^^^^^^^^^^^^^^ PLW0603
76 |     if _contact_service is None:
77 |         _contact_service = ContactService()
   |

backend-call-automation\app\dependencies\service_dependencies.py:88:12: PLW0603 Using the global statement to update `_ai_conversation_service` is discouraged
   |
86 |         AIConversationService: Instancia del servicio de conversación con IA
87 |     """
88 |     global _ai_conversation_service
   |            ^^^^^^^^^^^^^^^^^^^^^^^^ PLW0603
89 |     if _ai_conversation_service is None:
90 |         _ai_conversation_service = AIConversationService()
   |

backend-call-automation\app\dependencies\service_dependencies.py:101:12: PLW0603 Using the global statement to update `_enhanced_ai_conversation_service` is discouraged
    |
 99 |         EnhancedAIConversationService: Instancia del servicio mejorado de conversación con IA
100 |     """
101 |     global _enhanced_ai_conversation_service
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLW0603
102 |     if _enhanced_ai_conversation_service is None:
103 |         _enhanced_ai_conversation_service = EnhancedAIConversationService()
    |

backend-call-automation\app\dependencies\service_dependencies.py:114:12: PLW0603 Using the global statement to update `_elevenlabs_service` is discouraged
    |
112 |         ElevenLabsService: Instancia del servicio de ElevenLabs
113 |     """
114 |     global _elevenlabs_service
    |            ^^^^^^^^^^^^^^^^^^^ PLW0603
115 |     if _elevenlabs_service is None:
116 |         _elevenlabs_service = ElevenLabsService()
    |

backend-call-automation\app\dependencies\service_dependencies.py:127:12: PLW0603 Using the global statement to update `_audio_cache_service` is discouraged
    |
125 |         AudioCacheService: Instancia del servicio de caché de audio
126 |     """
127 |     global _audio_cache_service
    |            ^^^^^^^^^^^^^^^^^^^^ PLW0603
128 |     if _audio_cache_service is None:
129 |         _audio_cache_service = AudioCacheService()
    |

backend-call-automation\app\main.py:37:11: ANN201 Missing return type annotation for public function `lifespan`
   |
35 | # Definir el contexto de vida de la aplicación
36 | @asynccontextmanager
37 | async def lifespan(app: FastAPI):
   |           ^^^^^^^^ ANN201
38 |     # Iniciar tarea de sincronización de caché al iniciar la aplicación
39 |     logger.info("Starting cache sync task")
   |
   = help: Add return type annotation

backend-call-automation\app\main.py:37:20: ARG001 Unused function argument: `app`
   |
35 | # Definir el contexto de vida de la aplicación
36 | @asynccontextmanager
37 | async def lifespan(app: FastAPI):
   |                    ^^^ ARG001
38 |     # Iniciar tarea de sincronización de caché al iniciar la aplicación
39 |     logger.info("Starting cache sync task")
   |

backend-call-automation\app\main.py:82:1: E402 Module level import not at top of file
   |
82 | from app.routers import call_webhook
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
83 |
84 | from typing import Any
   |

backend-call-automation\app\main.py:82:1: I001 [*] Import block is un-sorted or un-formatted
   |
82 | / from app.routers import call_webhook
83 | |
84 | | from typing import Any
   | |______________________^ I001
85 |
86 |   app.include_router(campaign_router.router)
   |
   = help: Organize imports

backend-call-automation\app\main.py:84:1: E402 Module level import not at top of file
   |
82 | from app.routers import call_webhook
83 |
84 | from typing import Any
   | ^^^^^^^^^^^^^^^^^^^^^^ E402
85 |
86 | app.include_router(campaign_router.router)
   |

backend-call-automation\app\main.py:84:20: F401 [*] `typing.Any` imported but unused
   |
82 | from app.routers import call_webhook
83 |
84 | from typing import Any
   |                    ^^^ F401
85 |
86 | app.include_router(campaign_router.router)
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\main.py:99:11: ANN201 Missing return type annotation for public function `root`
    |
 98 | @app.get("/")
 99 | async def root():
    |           ^^^^ ANN201
100 |     return {
101 |         "message": "Bienvenido a la API de Automatización de Llamadas",
    |
    = help: Add return type annotation

backend-call-automation\app\middleware\__init__.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 8 | / from app.middleware.auth_middleware import setup_auth_middleware
 9 | | from app.middleware.error_handler import setup_error_handling
10 | |
11 | | from typing import Any
   | |______________________^ I001
12 |
13 |   __all__ = ["setup_auth_middleware", "setup_error_handling"]
   |
   = help: Organize imports

backend-call-automation\app\middleware\__init__.py:11:20: F401 `typing.Any` imported but unused
   |
 9 | from app.middleware.error_handler import setup_error_handling
10 |
11 | from typing import Any
   |                    ^^^ F401
12 |
13 | __all__ = ["setup_auth_middleware", "setup_error_handling"]
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\middleware\auth_middleware.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |
 8 | / import time
 9 | | from collections.abc import Awaitable, Callable
10 | |
11 | | import jwt  # PyJWT en lugar de python-jose
12 | | from fastapi import Request, status
13 | | from fastapi.responses import JSONResponse, Response
14 | | from starlette.middleware.base import BaseHTTPMiddleware
15 | | from starlette.types import ASGIApp
16 | |
17 | | from app.config.settings import get_settings
18 | | from app.utils.logging import app_logger as logger
19 | |
20 | | from typing import Optional, Any
   | |________________________________^ I001
21 |
22 |   settings = get_settings()
   |
   = help: Organize imports

backend-call-automation\app\middleware\auth_middleware.py:20:20: F401 [*] `typing.Optional` imported but unused
   |
18 | from app.utils.logging import app_logger as logger
19 |
20 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
21 |
22 | settings = get_settings()
   |
   = help: Remove unused import

backend-call-automation\app\middleware\auth_middleware.py:20:30: F401 [*] `typing.Any` imported but unused
   |
18 | from app.utils.logging import app_logger as logger
19 |
20 | from typing import Optional, Any
   |                              ^^^ F401
21 |
22 | settings = get_settings()
   |
   = help: Remove unused import

backend-call-automation\app\middleware\auth_middleware.py:57:15: PLR0911 Too many return statements (8 > 6)
   |
55 |         self.jwt_algorithms = jwt_algorithms or ["HS256"]
56 |
57 |     async def dispatch(
   |               ^^^^^^^^ PLR0911
58 |         self, request: Request, call_next: Callable[[Request], Awaitable]
59 |     ) -> Response:
   |

backend-call-automation\app\middleware\auth_middleware.py:150:19: TRY003 Avoid specifying long messages outside the exception class
    |
148 |         exp = payload.get("exp")
149 |         if exp and exp < time.time():
150 |             raise jwt.ExpiredSignatureError("Token expirado")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
151 |
152 |         return payload
    |

backend-call-automation\app\middleware\error_handler.py:17:1: ERA001 Found commented-out code
   |
15 | from starlette.exceptions import HTTPException as StarletteHTTPException
16 |
17 | # from typing import Any  # No se utiliza
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
   |
   = help: Remove commented-out code

backend-call-automation\app\middleware\error_handler.py:66:31: PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
   |
65 |         # Loguear error si es 5xx
66 |         if exc.status_code >= 500:
   |                               ^^^ PLR2004
67 |             self.logger.error(
68 |                 f"HTTP error {exc.status_code}: {exc.detail}",
   |

backend-call-automation\app\models\base.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from datetime import datetime
2 | |
3 | | from pydantic import UUID4, BaseModel, ConfigDict
4 | |
5 | |
6 | | from typing import Any
  | |______________________^ I001
7 |
8 |   class BaseDBModel(BaseModel):
  |
  = help: Organize imports

backend-call-automation\app\models\base.py:6:20: F401 [*] `typing.Any` imported but unused
  |
6 | from typing import Any
  |                    ^^^ F401
7 |
8 | class BaseDBModel(BaseModel):
  |
  = help: Remove unused import: `typing.Any`

backend-call-automation\app\models\cache_metrics.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Modelo para las métricas de caché."""
 2 |
 3 | / from datetime import datetime
 4 | |
 5 | | from pydantic import BaseModel, ConfigDict, Field
 6 | |
 7 | |
 8 | | from typing import Any
   | |______________________^ I001
 9 |
10 |   class CacheMetrics(BaseModel):
   |
   = help: Organize imports

backend-call-automation\app\models\cache_metrics.py:8:20: F401 [*] `typing.Any` imported but unused
   |
 8 | from typing import Any
   |                    ^^^ F401
 9 |
10 | class CacheMetrics(BaseModel):
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\models\call.py:7:25: F401 [*] `typing.Optional` imported but unused
  |
5 | from datetime import datetime
6 | from enum import Enum
7 | from typing import Any, Optional
  |                         ^^^^^^^^ F401
8 | from uuid import UUID
  |
  = help: Remove unused import: `typing.Optional`

backend-call-automation\app\models\call_metrics.py:6:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 | / from pydantic import BaseModel, ConfigDict, Field
 7 | |
 8 | |
 9 | | from typing import Any
   | |______________________^ I001
10 |
11 |   class CallMetrics(BaseModel):
   |
   = help: Organize imports

backend-call-automation\app\models\call_metrics.py:9:20: F401 [*] `typing.Any` imported but unused
   |
 9 | from typing import Any
   |                    ^^^ F401
10 |
11 | class CallMetrics(BaseModel):
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\models\campaign.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from datetime import datetime
 2 | | from enum import Enum
 3 | | from uuid import UUID
 4 | |
 5 | | from pydantic import BaseModel, ConfigDict, Field, ValidationInfo, field_validator
 6 | |
 7 | |
 8 | | from typing import Optional, Any
   | |________________________________^ I001
 9 |
10 |   class CampaignStatus(str, Enum):
   |
   = help: Organize imports

backend-call-automation\app\models\campaign.py:8:20: F401 [*] `typing.Optional` imported but unused
   |
 8 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
 9 |
10 | class CampaignStatus(str, Enum):
   |
   = help: Remove unused import

backend-call-automation\app\models\campaign.py:8:30: F401 [*] `typing.Any` imported but unused
   |
 8 | from typing import Optional, Any
   |                              ^^^ F401
 9 |
10 | class CampaignStatus(str, Enum):
   |
   = help: Remove unused import

backend-call-automation\app\models\campaign.py:77:33: N805 First argument of a method should be named `self`
   |
76 |     @field_validator("schedule_end")
77 |     def end_must_be_after_start(cls, v: datetime, info: ValidationInfo) -> datetime:
   |                                 ^^^ N805
78 |         if "schedule_start" in info.data and v <= info.data["schedule_start"]:
79 |             raise ValueError("La fecha de finalización debe ser posterior a la de inicio")
   |
   = help: Rename `cls` to `self`

backend-call-automation\app\models\campaign.py:79:19: TRY003 Avoid specifying long messages outside the exception class
   |
77 |     def end_must_be_after_start(cls, v: datetime, info: ValidationInfo) -> datetime:
78 |         if "schedule_start" in info.data and v <= info.data["schedule_start"]:
79 |             raise ValueError("La fecha de finalización debe ser posterior a la de inicio")
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
80 |         return v
   |

backend-call-automation\app\models\campaign.py:83:32: N805 First argument of a method should be named `self`
   |
82 |     @field_validator("calling_hours_end")
83 |     def validate_calling_hours(cls, v: str, info: ValidationInfo) -> str:
   |                                ^^^ N805
84 |         if "calling_hours_start" in info.data:
85 |             start = datetime.strptime(info.data["calling_hours_start"], "%H:%M").time()
   |
   = help: Rename `cls` to `self`

backend-call-automation\app\models\campaign.py:85:21: DTZ007 Naive datetime constructed using `datetime.datetime.strptime()` without %z
   |
83 |     def validate_calling_hours(cls, v: str, info: ValidationInfo) -> str:
84 |         if "calling_hours_start" in info.data:
85 |             start = datetime.strptime(info.data["calling_hours_start"], "%H:%M").time()
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ007
86 |             end = datetime.strptime(v, "%H:%M").time()
87 |             if end <= start:
   |
   = help: Call `.replace(tzinfo=<timezone>)` or `.astimezone()` to convert to an aware datetime

backend-call-automation\app\models\campaign.py:86:19: DTZ007 Naive datetime constructed using `datetime.datetime.strptime()` without %z
   |
84 |         if "calling_hours_start" in info.data:
85 |             start = datetime.strptime(info.data["calling_hours_start"], "%H:%M").time()
86 |             end = datetime.strptime(v, "%H:%M").time()
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ007
87 |             if end <= start:
88 |                 raise ValueError("La hora de fin debe ser posterior a la de inicio")
   |
   = help: Call `.replace(tzinfo=<timezone>)` or `.astimezone()` to convert to an aware datetime

backend-call-automation\app\models\campaign.py:88:23: TRY003 Avoid specifying long messages outside the exception class
   |
86 |             end = datetime.strptime(v, "%H:%M").time()
87 |             if end <= start:
88 |                 raise ValueError("La hora de fin debe ser posterior a la de inicio")
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
89 |         return v
   |

backend-call-automation\app\models\campaign.py:127:30: N805 First argument of a method should be named `self`
    |
126 |     @field_validator("successful_calls", "failed_calls")
127 |     def validate_call_counts(cls, v: int, info: ValidationInfo) -> int:
    |                              ^^^ N805
128 |         if (
129 |             "total_calls" in info.data
    |
    = help: Rename `cls` to `self`

backend-call-automation\app\models\campaign.py:139:23: TRY003 Avoid specifying long messages outside the exception class
    |
137 |               # Validar que la suma de exitosas y fallidas no exceda el total
138 |               if successful + failed > total:
139 |                   raise ValueError(
    |  _______________________^
140 | |                     "La suma de llamadas exitosas y fallidas no puede exceder el total"
141 | |                 )
    | |_________________^ TRY003
142 |           return v
    |

backend-call-automation\app\models\contact.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from typing import Annotated, Optional, Any
2 | |
3 | | from pydantic import BaseModel, EmailStr, Field
4 | |
5 | | from .base import BaseDBModel
  | |_____________________________^ I001
  |
  = help: Organize imports

backend-call-automation\app\models\contact.py:1:31: F401 [*] `typing.Optional` imported but unused
  |
1 | from typing import Annotated, Optional, Any
  |                               ^^^^^^^^ F401
2 |
3 | from pydantic import BaseModel, EmailStr, Field
  |
  = help: Remove unused import

backend-call-automation\app\models\contact.py:1:41: F401 [*] `typing.Any` imported but unused
  |
1 | from typing import Annotated, Optional, Any
  |                                         ^^^ F401
2 |
3 | from pydantic import BaseModel, EmailStr, Field
  |
  = help: Remove unused import

backend-call-automation\app\models\user.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from enum import Enum
 2 | |
 3 | | from pydantic import BaseModel, EmailStr
 4 | |
 5 | | from .base import BaseDBModel
 6 | |
 7 | |
 8 | | from typing import Optional, Any
   | |________________________________^ I001
 9 |
10 |   class UserRole(str, Enum):
   |
   = help: Organize imports

backend-call-automation\app\models\user.py:8:20: F401 [*] `typing.Optional` imported but unused
   |
 8 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
 9 |
10 | class UserRole(str, Enum):
   |
   = help: Remove unused import

backend-call-automation\app\models\user.py:8:30: F401 [*] `typing.Any` imported but unused
   |
 8 | from typing import Optional, Any
   |                              ^^^ F401
 9 |
10 | class UserRole(str, Enum):
   |
   = help: Remove unused import

backend-call-automation\app\monitoring\custom_metrics.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |
 8 | / import logging
 9 | | from typing import Iterable, List, Optional
10 | |
11 | | from prometheus_client import Counter, Gauge, Histogram
12 | | from prometheus_client.metrics_core import Metric
13 | | from prometheus_client.registry import Collector, CollectorRegistry, REGISTRY
   | |_____________________________________________________________________________^ I001
14 |
15 |   # Configurar logger
   |
   = help: Organize imports

backend-call-automation\app\monitoring\custom_metrics.py:9:1: UP035 [*] Import from `collections.abc` instead: `Iterable`
   |
 8 | import logging
 9 | from typing import Iterable, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP035
10 |
11 | from prometheus_client import Counter, Gauge, Histogram
   |
   = help: Import from `collections.abc`

backend-call-automation\app\monitoring\custom_metrics.py:9:1: UP035 `typing.List` is deprecated, use `list` instead
   |
 8 | import logging
 9 | from typing import Iterable, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP035
10 |
11 | from prometheus_client import Counter, Gauge, Histogram
   |

backend-call-automation\app\monitoring\custom_metrics.py:36:1: W293 Blank line contains whitespace
   |
34 |     """
35 |     Colector personalizado para métricas específicas de la aplicación.
36 |
   | ^^^^ W293
37 |     Este colector permite definir métricas personalizadas que no se pueden
38 |     crear fácilmente con los tipos estándar de Prometheus.
   |
   = help: Remove whitespace from blank line

backend-call-automation\app\monitoring\custom_metrics.py:41:9: ANN204 Missing return type annotation for special method `__init__`
   |
39 |     """
40 |
41 |     def __init__(self, registry: Optional[CollectorRegistry] = REGISTRY):
   |         ^^^^^^^^ ANN204
42 |         """
43 |         Inicializa el colector personalizado.
   |
   = help: Add return type annotation: `None`

backend-call-automation\app\monitoring\custom_metrics.py:41:34: UP007 [*] Use `X | Y` for type annotations
   |
39 |     """
40 |
41 |     def __init__(self, registry: Optional[CollectorRegistry] = REGISTRY):
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP007
42 |         """
43 |         Inicializa el colector personalizado.
   |
   = help: Convert to `X | Y`

backend-call-automation\app\monitoring\custom_metrics.py:44:1: W293 Blank line contains whitespace
   |
42 |         """
43 |         Inicializa el colector personalizado.
44 |
   | ^^^^^^^^ W293
45 |         Args:
46 |             registry: Registro de Prometheus donde registrar el colector
   |
   = help: Remove whitespace from blank line

backend-call-automation\app\monitoring\custom_metrics.py:48:24: UP006 [*] Use `list` instead of `List` for type annotation
   |
46 |             registry: Registro de Prometheus donde registrar el colector
47 |         """
48 |         self._metrics: List[Metric] = []
   |                        ^^^^ UP006
49 |         if registry:
50 |             try:
   |
   = help: Replace with `list`

backend-call-automation\app\monitoring\custom_metrics.py:54:17: TRY400 Use `logging.exception` instead of `logging.error`
   |
52 |                 logger.info("CustomCollector registered successfully")
53 |             except Exception as e:
54 |                 logger.error(f"Error registering CustomCollector: {e}")
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
55 |
56 |     def collect(self) -> Iterable[Metric]:
   |
   = help: Replace with `exception`

backend-call-automation\app\monitoring\custom_metrics.py:59:1: W293 Blank line contains whitespace
   |
57 |         """
58 |         Recopila las métricas personalizadas.
59 |
   | ^^^^^^^^ W293
60 |         Returns:
61 |             Iterable de métricas
   |
   = help: Remove whitespace from blank line

backend-call-automation\app\monitoring\custom_metrics.py:68:1: W293 Blank line contains whitespace
   |
66 |         """
67 |         Añade una métrica al colector.
68 |
   | ^^^^^^^^ W293
69 |         Args:
70 |             metric: Métrica a añadir
   |
   = help: Remove whitespace from blank line

backend-call-automation\app\monitoring\custom_metrics.py:73:1: W293 [*] Blank line contains whitespace
   |
71 |         """
72 |         self._metrics.append(metric)
73 |
   | ^^^^^^^^ W293
74 |
75 | # Crear una instancia del colector personalizado
   |
   = help: Remove whitespace from blank line

backend-call-automation\app\monitoring\elevenlabs_metrics.py:9:1: I001 [*] Import block is un-sorted or un-formatted
   |
 9 | / from prometheus_client import Counter, Gauge, Histogram
10 | |
11 | | from typing import Any
   | |______________________^ I001
12 |
13 |   # Métricas básicas para la integración con ElevenLabs
   |
   = help: Organize imports

backend-call-automation\app\monitoring\elevenlabs_metrics.py:11:20: F401 [*] `typing.Any` imported but unused
   |
 9 | from prometheus_client import Counter, Gauge, Histogram
10 |
11 | from typing import Any
   |                    ^^^ F401
12 |
13 | # Métricas básicas para la integración con ElevenLabs
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\routers\audio_cache_router.py:22:5: ARG001 Unused function argument: `supabase_client`
   |
20 | @router.get("/stats", response_model=dict[str, Any])
21 | async def get_cache_stats(
22 |     supabase_client: SupabaseClient = Depends(get_supabase_client),
   |     ^^^^^^^^^^^^^^^ ARG001
23 | ) -> dict[str, Any]:
24 |     """
   |

backend-call-automation\app\routers\audio_cache_router.py:32:9: TRY300 Consider moving this statement to an `else` block
   |
30 |     try:
31 |         stats = await audio_cache_service.get_cache_stats()
32 |         return stats
   |         ^^^^^^^^^^^^ TRY300
33 |     except Exception as e:
34 |         logger.error(f"Error al obtener estadísticas del caché: {e!s}")
   |

backend-call-automation\app\routers\audio_cache_router.py:32:16: RET504 Unnecessary assignment to `stats` before `return` statement
   |
30 |     try:
31 |         stats = await audio_cache_service.get_cache_stats()
32 |         return stats
   |                ^^^^^ RET504
33 |     except Exception as e:
34 |         logger.error(f"Error al obtener estadísticas del caché: {e!s}")
   |
   = help: Remove unnecessary assignment

backend-call-automation\app\routers\audio_cache_router.py:35:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
33 |       except Exception as e:
34 |           logger.error(f"Error al obtener estadísticas del caché: {e!s}")
35 | /         raise HTTPException(
36 | |             status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
37 | |             detail=f"Error al obtener estadísticas del caché: {e!s}",
38 | |         )
   | |_________^ B904
   |

backend-call-automation\app\routers\audio_cache_router.py:43:5: ARG001 Unused function argument: `supabase_client`
   |
41 | @router.post("/clear", response_model=dict[str, bool])
42 | async def clear_cache(
43 |     supabase_client: SupabaseClient = Depends(get_supabase_client),
   |     ^^^^^^^^^^^^^^^ ARG001
44 | ) -> dict[str, bool]:
45 |     """
   |

backend-call-automation\app\routers\audio_cache_router.py:53:9: TRY300 Consider moving this statement to an `else` block
   |
51 |     try:
52 |         success = await audio_cache_service.clear_cache()
53 |         return {"success": success}
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY300
54 |     except Exception as e:
55 |         logger.error(f"Error al limpiar el caché: {e!s}")
   |

backend-call-automation\app\routers\audio_cache_router.py:56:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
54 |       except Exception as e:
55 |           logger.error(f"Error al limpiar el caché: {e!s}")
56 | /         raise HTTPException(
57 | |             status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
58 | |             detail=f"Error al limpiar el caché: {e!s}",
59 | |         )
   | |_________^ B904
   |

backend-call-automation\app\routers\auth_router.py:9:1: I001 [*] Import block is un-sorted or un-formatted
   |
 9 | / from fastapi import APIRouter, Body, Depends, HTTPException, status
10 | | from pydantic import BaseModel, EmailStr, Field
11 | |
12 | | from app.config.dependencies import get_supabase_client
13 | | from app.services.auth_service import AuthService
14 | | from app.utils.logging import app_logger as logger
15 | | from supabase import Client as SupabaseClient
16 | |
17 | | from typing import Optional, Any
   | |________________________________^ I001
18 |
19 |   router = APIRouter(prefix="/api/auth", tags=["auth"])
   |
   = help: Organize imports

backend-call-automation\app\routers\auth_router.py:17:20: F401 [*] `typing.Optional` imported but unused
   |
15 | from supabase import Client as SupabaseClient
16 |
17 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
18 |
19 | router = APIRouter(prefix="/api/auth", tags=["auth"])
   |
   = help: Remove unused import

backend-call-automation\app\routers\auth_router.py:17:30: F401 [*] `typing.Any` imported but unused
   |
15 | from supabase import Client as SupabaseClient
16 |
17 | from typing import Optional, Any
   |                              ^^^ F401
18 |
19 | router = APIRouter(prefix="/api/auth", tags=["auth"])
   |
   = help: Remove unused import

backend-call-automation\app\routers\auth_router.py:44:23: S105 Possible hardcoded password assigned to: "token_type"
   |
42 | class TokenResponse(BaseModel):
43 |     access_token: str
44 |     token_type: str = "bearer"
   |                       ^^^^^^^^ S105
45 |     expires_in: int
46 |     refresh_token: str
   |

backend-call-automation\app\routers\auth_router.py:93:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
91 |       except Exception as e:
92 |           logger.error(f"Error en login: {e!s}")
93 | /         raise HTTPException(
94 | |             status_code=status.HTTP_401_UNAUTHORIZED, detail="Credenciales inválidas"
95 | |         )
   | |_________^ B904
   |

backend-call-automation\app\routers\auth_router.py:137:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
135 |       except Exception as e:
136 |           logger.error(f"Error en registro: {e!s}")
137 | /         raise HTTPException(
138 | |             status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
139 | |             detail=f"Error al registrar usuario: {e!s}",
140 | |         )
    | |_________^ B904
    |

backend-call-automation\app\routers\auth_router.py:185:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
183 |       except Exception as e:
184 |           logger.error(f"Error al refrescar token: {e!s}")
185 | /         raise HTTPException(
186 | |             status_code=status.HTTP_401_UNAUTHORIZED, detail="Token de refresco inválido"
187 | |         )
    | |_________^ B904
    |

backend-call-automation\app\routers\auth_router.py:202:9: TRY300 Consider moving this statement to an `else` block
    |
200 |         supabase_client.auth.sign_out()
201 |
202 |         return {"success": True}
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ TRY300
203 |     except Exception as e:
204 |         logger.error(f"Error al cerrar sesión: {e!s}")
    |

backend-call-automation\app\routers\auth_router.py:205:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
203 |       except Exception as e:
204 |           logger.error(f"Error al cerrar sesión: {e!s}")
205 | /         raise HTTPException(
206 | |             status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
207 | |             detail=f"Error al cerrar sesión: {e!s}",
208 | |         )
    | |_________^ B904
    |

backend-call-automation\app\routers\auth_router.py:227:13: TRY301 Abstract `raise` to an inner function
    |
226 |         if not user:
227 |             raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="No autenticado")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
228 |
229 |         # Crear servicio de autenticación
    |

backend-call-automation\app\routers\auth_router.py:244:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
242 |     except Exception as e:
243 |         logger.error(f"Error al obtener usuario actual: {e!s}")
244 |         raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="No autenticado")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
    |

backend-call-automation\app\routers\cache_router.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from fastapi import APIRouter, HTTPException
2 | |
3 | | from app.models.cache_metrics import CacheMetrics
4 | | from app.services.cache_service import cache_service
5 | |
6 | | from typing import Optional, Any
  | |________________________________^ I001
7 |
8 |   router = APIRouter(
  |
  = help: Organize imports

backend-call-automation\app\routers\cache_router.py:6:20: F401 [*] `typing.Optional` imported but unused
  |
4 | from app.services.cache_service import cache_service
5 |
6 | from typing import Optional, Any
  |                    ^^^^^^^^ F401
7 |
8 | router = APIRouter(
  |
  = help: Remove unused import

backend-call-automation\app\routers\cache_router.py:6:30: F401 [*] `typing.Any` imported but unused
  |
4 | from app.services.cache_service import cache_service
5 |
6 | from typing import Optional, Any
  |                              ^^^ F401
7 |
8 | router = APIRouter(
  |
  = help: Remove unused import

backend-call-automation\app\routers\call_router.py:25:5: ERA001 Found commented-out code
   |
23 |     Crea una nueva llamada y la inicia con Twilio.
24 |     """
25 |     # twilio_response = await twilio_client.calls.create(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
26 |     #     to=call.phone_number,
27 |     #     from_=call.from_number,
   |
   = help: Remove commented-out code

backend-call-automation\app\routers\call_router.py:26:5: ERA001 Found commented-out code
   |
24 |     """
25 |     # twilio_response = await twilio_client.calls.create(
26 |     #     to=call.phone_number,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
27 |     #     from_=call.from_number,
28 |     #     url=call.webhook_url,
   |
   = help: Remove commented-out code

backend-call-automation\app\routers\call_router.py:27:5: ERA001 Found commented-out code
   |
25 |     # twilio_response = await twilio_client.calls.create(
26 |     #     to=call.phone_number,
27 |     #     from_=call.from_number,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
28 |     #     url=call.webhook_url,
29 |     #     status_callback=call.status_callback_url
   |
   = help: Remove commented-out code

backend-call-automation\app\routers\call_router.py:28:5: ERA001 Found commented-out code
   |
26 |     #     to=call.phone_number,
27 |     #     from_=call.from_number,
28 |     #     url=call.webhook_url,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
29 |     #     status_callback=call.status_callback_url
30 |     # )
   |
   = help: Remove commented-out code

backend-call-automation\app\routers\call_router.py:29:5: ERA001 Found commented-out code
   |
27 |     #     from_=call.from_number,
28 |     #     url=call.webhook_url,
29 |     #     status_callback=call.status_callback_url
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
30 |     # )
   |
   = help: Remove commented-out code

backend-call-automation\app\routers\call_router.py:30:5: ERA001 Found commented-out code
   |
28 |     #     url=call.webhook_url,
29 |     #     status_callback=call.status_callback_url
30 |     # )
   |     ^^^ ERA001
31 |
32 |     # call.twilio_sid = twilio_response.sid
   |
   = help: Remove commented-out code

backend-call-automation\app\routers\call_router.py:32:5: ERA001 Found commented-out code
   |
30 |     # )
31 |
32 |     # call.twilio_sid = twilio_response.sid
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
33 |
34 |     # Usar twilio_service.client en lugar de twilio_client directamente
   |
   = help: Remove commented-out code

backend-call-automation\app\routers\call_router.py:75:11: PLR0913 Too many arguments in function definition (10 > 5)
   |
74 | @router.get("/", response_model=dict[str, Any])
75 | async def list_calls(
   |           ^^^^^^^^^^ PLR0913
76 |     campaign_id: str | None = Query(None, description="Filtrar por ID de campaña"),
77 |     status: CallStatus | None = Query(None, description="Filtrar por estado de llamada"),
   |

backend-call-automation\app\routers\call_router.py:125:11: PLR0913 Too many arguments in function definition (6 > 5)
    |
124 | @router.patch("/{call_id}/status", response_model=Call)
125 | async def update_call_status(
    |           ^^^^^^^^^^^^^^^^^^ PLR0913
126 |     call_id: str = Path(..., description="ID de la llamada"),
127 |     status: CallStatus = Query(..., description="Nuevo estado de la llamada"),
    |

backend-call-automation\app\routers\call_router.py:201:26: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
199 |     """
200 |     # Verificar que la fecha es futura
201 |     if scheduled_time <= datetime.now():
    |                          ^^^^^^^^^^^^^^ DTZ005
202 |         raise HTTPException(
203 |             status_code=status.HTTP_400_BAD_REQUEST,
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\routers\call_router.py:232:20: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
230 |     # Si no se especifica end_date, usar fecha actual
231 |     if not end_date:
232 |         end_date = datetime.now()
    |                    ^^^^^^^^^^^^^^ DTZ005
233 |
234 |     # Si no se especifica start_date, usar 30 días antes de end_date
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\routers\call_router.py:261:13: TRY301 Abstract `raise` to an inner function
    |
260 |           if not call_sid or not call_status:
261 | /             raise HTTPException(
262 | |                 status_code=status.HTTP_400_BAD_REQUEST,
263 | |                 detail="CallSid y CallStatus son requeridos",
264 | |             )
    | |_____________^ TRY301
265 |
266 |           # Buscar la llamada por el SID de Twilio
    |

backend-call-automation\app\routers\call_router.py:270:101: E501 Line too long (112 > 100)
    |
269 |         if not call:
270 |             # Loguear pero no fallar, podría ser un callback para una llamada que aún no está en nuestro sistema
    |                                                                                                     ^^^^^^^^^^^^ E501
271 |             return JSONResponse(
272 |                 status_code=status.HTTP_200_OK,
    |

backend-call-automation\app\routers\call_router.py:345:13: TRY301 Abstract `raise` to an inner function
    |
343 |       try:
344 |           if "text" not in message:
345 | /             raise HTTPException(
346 | |                 status_code=status.HTTP_400_BAD_REQUEST,
347 | |                 detail="El campo 'text' es requerido en el mensaje",
348 | |             )
    | |_____________^ TRY301
349 |
350 |           # Verificar que la llamada existe y está activa
    |

backend-call-automation\app\routers\call_router.py:353:13: TRY301 Abstract `raise` to an inner function
    |
351 |           call = await call_service.get_call(call_id)
352 |           if not call:
353 | /             raise HTTPException(
354 | |                 status_code=status.HTTP_404_NOT_FOUND, detail="Llamada no encontrada"
355 | |             )
    | |_____________^ TRY301
356 |
357 |           if call.status != CallStatus.in_progress:
    |

backend-call-automation\app\routers\call_router.py:358:13: TRY301 Abstract `raise` to an inner function
    |
357 |           if call.status != CallStatus.in_progress:
358 | /             raise HTTPException(
359 | |                 status_code=status.HTTP_400_BAD_REQUEST,
360 | |                 detail=f"La llamada no está activa. Estado actual: {call.status}",
361 | |             )
    | |_____________^ TRY301
362 |
363 |           # Procesar la respuesta
    |

backend-call-automation\app\routers\call_router.py:372:26: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
370 |             "audio": audio_response,
371 |             "call_id": call_id,
372 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^ DTZ005
373 |         }
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\routers\call_router.py:378:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
376 |           raise
377 |       except Exception as e:
378 | /         raise HTTPException(
379 | |             status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
380 | |             detail=f"Error al procesar la respuesta: {e!s}",
381 | |         )
    | |_________^ B904
    |

backend-call-automation\app\routers\call_webhook.py:22:11: ANN201 Missing return type annotation for public function `handle_call_webhook`
   |
20 |     "/webhook", tags=["Webhooks"]
21 | )  # Asegúrate que la ruta coincida con la configurada en ElevenLabsService
22 | async def handle_call_webhook(
   |           ^^^^^^^^^^^^^^^^^^^ ANN201
23 |     request: Request,
24 |     call_service: CallService = Depends(get_call_service),  # Inyecta CallService
   |
   = help: Add return type annotation

backend-call-automation\app\routers\call_webhook.py:53:13: E722 Do not use bare `except`
   |
51 |             try:
52 |                 metadata = json.loads(metadata)
53 |             except:
   |             ^^^^^^ E722
54 |                 metadata = {}
   |

backend-call-automation\app\routers\call_webhook.py:68:13: ERA001 Found commented-out code
   |
66 |             logger.info(f"Llamada {call_id} finalizada con estado: {call_status}. Limpiando.")
67 |             # Ejecutar limpieza en segundo plano para no bloquear la respuesta
68 |             # background_tasks.add_task(call_service.handle_call_end, call_id) # Si usas BackgroundTasks
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
69 |             await call_service.handle_call_end(call_id)  # Corregido: Pasar solo call_id
70 |             return Response(content="", status_code=200)
   |
   = help: Remove commented-out code

backend-call-automation\app\routers\call_webhook.py:68:101: E501 Line too long (104 > 100)
   |
66 |             logger.info(f"Llamada {call_id} finalizada con estado: {call_status}. Limpiando.")
67 |             # Ejecutar limpieza en segundo plano para no bloquear la respuesta
68 |             # background_tasks.add_task(call_service.handle_call_end, call_id) # Si usas BackgroundTasks
   |                                                                                                     ^^^^ E501
69 |             await call_service.handle_call_end(call_id)  # Corregido: Pasar solo call_id
70 |             return Response(content="", status_code=200)
   |

backend-call-automation\app\routers\call_webhook.py:90:101: E501 Line too long (102 > 100)
   |
88 |         # 5. Manejar Otros Eventos
89 |         logger.info(
90 |             f"Evento intermedio para llamada {call_id}, estado: {call_status}. No se requiere acción."
   |                                                                                                     ^^ E501
91 |         )
92 |         # No se necesita devolver audio, respuesta vacía está bien.
   |

backend-call-automation\app\routers\call_webhook.py:97:9: TRY400 Use `logging.exception` instead of `logging.error`
   |
95 |     except StreamingError as e:
96 |         # Error específico durante la generación del stream (ya se intentó devolver fallback)
97 |         logger.error(f"Error de streaming manejado para call_id {call_id}: {e}")
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
98 |         # Devolver respuesta vacía o error 500
99 |         return Response(content="", status_code=500)
   |
   = help: Replace with `exception`

backend-call-automation\app\routers\call_webhook.py:101:84: TRY401 Redundant exception object included in `logging.exception` call
    |
 99 |         return Response(content="", status_code=500)
100 |     except Exception as e:
101 |         logger.exception(f"Error fatal procesando webhook para call_id {call_id}: {e!s}")
    |                                                                                    ^ TRY401
102 |         # Devolver una respuesta genérica de error 500
103 |         return Response(content="", status_code=500)
    |

backend-call-automation\app\routers\call_webhook.py:107:1: ERA001 Found commented-out code
    |
106 | # Asegúrate de incluir este router en tu app principal con el prefijo correcto:
107 | # from app.routers import call_webhook
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
    |
    = help: Remove commented-out code

backend-call-automation\app\routers\call_webhook.py:110:1: E402 Module level import not at top of file
    |
110 | from typing import Any
    | ^^^^^^^^^^^^^^^^^^^^^^ E402
111 |
112 | # app.include_router(call_webhook.router, prefix="/api/v1/calls") # Ajusta el prefijo
    |

backend-call-automation\app\routers\call_webhook.py:110:20: F401 [*] `typing.Any` imported but unused
    |
110 | from typing import Any
    |                    ^^^ F401
111 |
112 | # app.include_router(call_webhook.router, prefix="/api/v1/calls") # Ajusta el prefijo
    |
    = help: Remove unused import: `typing.Any`

backend-call-automation\app\routers\call_webhook.py:112:1: ERA001 Found commented-out code
    |
110 | from typing import Any
111 |
112 | # app.include_router(call_webhook.router, prefix="/api/v1/calls") # Ajusta el prefijo
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
    |
    = help: Remove commented-out code

backend-call-automation\app\routers\campaign_router.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from datetime import datetime
 2 | | from uuid import UUID
 3 | |
 4 | | from fastapi import APIRouter, Depends, status
 5 | |
 6 | | from app.config.database import get_supabase_client
 7 | | from app.models.campaign import Campaign, CampaignCreate, CampaignStatus, CampaignUpdate
 8 | | from app.services.campaign_service import CampaignService
 9 | |
10 | | from typing import Optional, Any
   | |________________________________^ I001
11 |
12 |   router = APIRouter(prefix="/api/campaigns", tags=["campaigns"])
   |
   = help: Organize imports

backend-call-automation\app\routers\campaign_router.py:10:20: F401 [*] `typing.Optional` imported but unused
   |
 8 | from app.services.campaign_service import CampaignService
 9 |
10 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
11 |
12 | router = APIRouter(prefix="/api/campaigns", tags=["campaigns"])
   |
   = help: Remove unused import

backend-call-automation\app\routers\campaign_router.py:10:30: F401 [*] `typing.Any` imported but unused
   |
 8 | from app.services.campaign_service import CampaignService
 9 |
10 | from typing import Optional, Any
   |                              ^^^ F401
11 |
12 | router = APIRouter(prefix="/api/campaigns", tags=["campaigns"])
   |
   = help: Remove unused import

backend-call-automation\app\routers\campaign_router.py:17:31: ANN001 Missing type annotation for function argument `supabase_client`
   |
15 | @router.post("/", response_model=Campaign, status_code=status.HTTP_201_CREATED)
16 | async def create_campaign(
17 |     campaign: CampaignCreate, supabase_client=Depends(get_supabase_client)
   |                               ^^^^^^^^^^^^^^^ ANN001
18 | ) -> Campaign:
19 |     """
   |

backend-call-automation\app\routers\campaign_router.py:40:43: ANN001 Missing type annotation for function argument `supabase_client`
   |
39 | @router.get("/{campaign_id}", response_model=Campaign)
40 | async def get_campaign(campaign_id: UUID, supabase_client=Depends(get_supabase_client)) -> Campaign:
   |                                           ^^^^^^^^^^^^^^^ ANN001
41 |     """
42 |     Obtiene una campaña por su ID.
   |

backend-call-automation\app\routers\campaign_router.py:49:11: PLR0913 Too many arguments in function definition (6 > 5)
   |
48 | @router.get("/", response_model=list[Campaign])
49 | async def list_campaigns(
   |           ^^^^^^^^^^^^^^ PLR0913
50 |     page: int = 1,
51 |     page_size: int = 10,
   |

backend-call-automation\app\routers\campaign_router.py:55:5: ANN001 Missing type annotation for function argument `supabase_client`
   |
53 |     start_date: datetime | None = None,
54 |     end_date: datetime | None = None,
55 |     supabase_client=Depends(get_supabase_client),
   |     ^^^^^^^^^^^^^^^ ANN001
56 | ) -> list[Campaign]:
57 |     """
   |

backend-call-automation\app\routers\campaign_router.py:75:57: ANN001 Missing type annotation for function argument `supabase_client`
   |
73 | @router.patch("/{campaign_id}", response_model=Campaign)
74 | async def update_campaign(
75 |     campaign_id: UUID, campaign_update: CampaignUpdate, supabase_client=Depends(get_supabase_client)
   |                                                         ^^^^^^^^^^^^^^^ ANN001
76 | ) -> Campaign:
77 |     """
   |

backend-call-automation\app\routers\campaign_router.py:98:46: ANN001 Missing type annotation for function argument `supabase_client`
    |
 97 | @router.delete("/{campaign_id}", status_code=status.HTTP_204_NO_CONTENT)
 98 | async def delete_campaign(campaign_id: UUID, supabase_client=Depends(get_supabase_client)) -> None:
    |                                              ^^^^^^^^^^^^^^^ ANN001
 99 |     """
100 |     Elimina una campaña.
    |

backend-call-automation\app\routers\campaign_router.py:107:11: PLR0913 Too many arguments in function definition (6 > 5)
    |
106 | @router.patch("/{campaign_id}/stats", response_model=Campaign)
107 | async def update_campaign_stats(
    |           ^^^^^^^^^^^^^^^^^^^^^ PLR0913
108 |     campaign_id: UUID,
109 |     total_calls: int,
    |

backend-call-automation\app\routers\campaign_router.py:113:5: ANN001 Missing type annotation for function argument `supabase_client`
    |
111 |     failed_calls: int,
112 |     pending_calls: int,
113 |     supabase_client=Depends(get_supabase_client),
    |     ^^^^^^^^^^^^^^^ ANN001
114 | ) -> Campaign:
115 |     """
    |

backend-call-automation\app\routers\contact_router.py:13:1: I001 [*] Import block is un-sorted or un-formatted
   |
13 | / from fastapi import APIRouter, Depends, File, HTTPException, UploadFile, status
14 | | from fastapi.responses import PlainTextResponse
15 | |
16 | | # Importaciones del proyecto
17 | | from app.dependencies import get_supabase_client
18 | | from app.models.contact import Contact, ContactCreate, ContactList, ContactListCreate, ContactUpdate
19 | | from app.services.contact_service import ContactService
20 | | from supabase import Client as SupabaseClient
21 | |
22 | | from typing import Optional, Any
   | |________________________________^ I001
23 |
24 |   router = APIRouter(prefix="/api/contacts", tags=["contacts"])
   |
   = help: Organize imports

backend-call-automation\app\routers\contact_router.py:22:20: F401 [*] `typing.Optional` imported but unused
   |
20 | from supabase import Client as SupabaseClient
21 |
22 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
23 |
24 | router = APIRouter(prefix="/api/contacts", tags=["contacts"])
   |
   = help: Remove unused import

backend-call-automation\app\routers\contact_router.py:22:30: F401 [*] `typing.Any` imported but unused
   |
20 | from supabase import Client as SupabaseClient
21 |
22 | from typing import Optional, Any
   |                              ^^^ F401
23 |
24 | router = APIRouter(prefix="/api/contacts", tags=["contacts"])
   |
   = help: Remove unused import

backend-call-automation\app\routers\contact_router.py:29:11: ANN201 Missing return type annotation for public function `list_contacts`
   |
27 | # Endpoints para contactos individuales
28 | @router.get("/", response_model=dict[str, object])
29 | async def list_contacts(
   |           ^^^^^^^^^^^^^ ANN201
30 |     skip: int = 0,
31 |     limit: int = 10,
   |
   = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:61:11: ANN201 Missing return type annotation for public function `search_contacts`
   |
60 | @router.get("/search", response_model=list[Contact])
61 | async def search_contacts(
   |           ^^^^^^^^^^^^^^^ ANN201
62 |     q: str, limit: int = 10, supabase_client: SupabaseClient = Depends(get_supabase_client)
63 | ):
   |
   = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:79:11: ANN201 Missing return type annotation for public function `get_contact`
   |
78 | @router.get("/{contact_id}", response_model=Contact)
79 | async def get_contact(
   |           ^^^^^^^^^^^ ANN201
80 |     contact_id: str, supabase_client: SupabaseClient = Depends(get_supabase_client)
81 | ):
   |
   = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:104:11: ANN201 Missing return type annotation for public function `create_contact`
    |
103 | @router.post("/", response_model=Contact, status_code=status.HTTP_201_CREATED)
104 | async def create_contact(
    |           ^^^^^^^^^^^^^^ ANN201
105 |     contact: ContactCreate, supabase_client: SupabaseClient = Depends(get_supabase_client)
106 | ):
    |
    = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:121:11: ANN201 Missing return type annotation for public function `update_contact`
    |
120 | @router.put("/{contact_id}", response_model=Contact)
121 | async def update_contact(
    |           ^^^^^^^^^^^^^^ ANN201
122 |     contact_id: str,
123 |     contact: ContactUpdate,
    |
    = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:149:11: ANN201 Missing return type annotation for public function `delete_contact`
    |
148 | @router.delete("/{contact_id}", response_model=dict[str, bool])
149 | async def delete_contact(
    |           ^^^^^^^^^^^^^^ ANN201
150 |     contact_id: str, supabase_client: SupabaseClient = Depends(get_supabase_client)
151 | ):
    |
    = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:178:11: ANN201 Missing return type annotation for public function `import_contacts`
    |
176 | # Endpoints para importación y exportación
177 | @router.post("/import", response_model=dict[str, int])
178 | async def import_contacts(
    |           ^^^^^^^^^^^^^^^ ANN201
179 |     file: UploadFile = File(...), supabase_client: SupabaseClient = Depends(get_supabase_client)
180 | ):
    |
    = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:197:12: RET504 Unnecessary assignment to `result` before `return` statement
    |
195 |     contact_service = ContactService(supabase_client)
196 |     result = await contact_service.import_contacts_from_csv(file)
197 |     return result
    |            ^^^^^^ RET504
    |
    = help: Remove unnecessary assignment

backend-call-automation\app\routers\contact_router.py:201:11: ANN201 Missing return type annotation for public function `export_contacts`
    |
200 | @router.get("/export", response_class=PlainTextResponse)
201 | async def export_contacts(
    |           ^^^^^^^^^^^^^^^ ANN201
202 |     list_id: str | None = None, supabase_client: SupabaseClient = Depends(get_supabase_client)
203 | ):
    |
    = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:223:11: ANN201 Missing return type annotation for public function `list_contact_lists`
    |
221 | # Endpoints para listas de contactos
222 | @router.get("/lists", response_model=list[ContactList])
223 | async def list_contact_lists(supabase_client: SupabaseClient = Depends(get_supabase_client)):
    |           ^^^^^^^^^^^^^^^^^^ ANN201
224 |     """
225 |     Lista todas las listas de contactos.
    |
    = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:235:11: ANN201 Missing return type annotation for public function `get_contact_list`
    |
234 | @router.get("/lists/{list_id}", response_model=ContactList)
235 | async def get_contact_list(
    |           ^^^^^^^^^^^^^^^^ ANN201
236 |     list_id: str, supabase_client: SupabaseClient = Depends(get_supabase_client)
237 | ):
    |
    = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:262:11: ANN201 Missing return type annotation for public function `create_contact_list`
    |
261 | @router.post("/lists", response_model=ContactList, status_code=status.HTTP_201_CREATED)
262 | async def create_contact_list(
    |           ^^^^^^^^^^^^^^^^^^^ ANN201
263 |     contact_list: ContactListCreate, supabase_client: SupabaseClient = Depends(get_supabase_client)
264 | ):
    |
    = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:279:11: ANN201 Missing return type annotation for public function `add_contacts_to_list`
    |
278 | @router.post("/lists/{list_id}/contacts", response_model=dict[str, int])
279 | async def add_contacts_to_list(
    |           ^^^^^^^^^^^^^^^^^^^^ ANN201
280 |     list_id: str,
281 |     contact_ids: list[str],
    |
    = help: Add return type annotation

backend-call-automation\app\routers\contact_router.py:304:11: ANN201 Missing return type annotation for public function `remove_contact_from_list`
    |
303 | @router.delete("/lists/{list_id}/contacts/{contact_id}", response_model=dict[str, bool])
304 | async def remove_contact_from_list(
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
305 |     list_id: str, contact_id: str, supabase_client: SupabaseClient = Depends(get_supabase_client)
306 | ):
    |
    = help: Add return type annotation

backend-call-automation\app\routers\report_router.py:107:20: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
105 |     # Si no se especifica end_date, usar fecha actual
106 |     if not end_date:
107 |         end_date = datetime.now()
    |                    ^^^^^^^^^^^^^^ DTZ005
108 |
109 |     # Si no se especifica start_date, usar 30 días antes de end_date
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\routers\report_router.py:153:11: PLR0913 Too many arguments in function definition (7 > 5)
    |
152 | @router.get("/call_history", response_model=dict[str, Any])
153 | async def get_call_history(
    |           ^^^^^^^^^^^^^^^^ PLR0913
154 |     campaign_id: str | None = Query(None, description="Filtrar por ID de campaña"),
155 |     contact_id: str | None = Query(None, description="Filtrar por ID de contacto"),
    |

backend-call-automation\app\routers\report_router.py:177:20: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
175 |     # Si no se especifica end_date, usar fecha actual
176 |     if not end_date:
177 |         end_date = datetime.now()
    |                    ^^^^^^^^^^^^^^ DTZ005
178 |
179 |     # Si no se especifica start_date, usar 30 días antes de end_date
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\routers\report_router.py:205:11: PLR0913 Too many arguments in function definition (7 > 5)
    |
204 | @router.get("/export/calls", response_class=StreamingResponse)
205 | async def export_call_history(
    |           ^^^^^^^^^^^^^^^^^^^ PLR0913
206 |     campaign_id: str | None = Query(None, description="Filtrar por ID de campaña"),
207 |     start_date: datetime | None = Query(None, description="Filtrar desde fecha (formato ISO)"),
    |

backend-call-automation\app\routers\report_router.py:212:5: ARG001 Unused function argument: `contact_service`
    |
210 |     call_service: CallService = Depends(get_call_service),
211 |     campaign_service: CampaignService = Depends(get_campaign_service),
212 |     contact_service: ContactService = Depends(get_contact_service),
    |     ^^^^^^^^^^^^^^^ ARG001
213 | ) -> StreamingResponse:
214 |     """
    |

backend-call-automation\app\routers\report_router.py:227:20: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
225 |     # Si no se especifica end_date, usar fecha actual
226 |     if not end_date:
227 |         end_date = datetime.now()
    |                    ^^^^^^^^^^^^^^ DTZ005
228 |
229 |     # Si no se especifica start_date, usar 30 días antes de end_date
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\routers\report_router.py:261:36: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
259 |         output.seek(0)
260 |
261 |         filename = f"call_history_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
    |                                    ^^^^^^^^^^^^^^ DTZ005
262 |         media_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\routers\report_router.py:274:32: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
272 |     output.seek(0)
273 |
274 |     filename = f"call_history_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    |                                ^^^^^^^^^^^^^^ DTZ005
275 |
276 |     return StreamingResponse(
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\routers\report_router.py:302:20: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
300 |     # Si no se especifica end_date, usar fecha actual
301 |     if not end_date:
302 |         end_date = datetime.now()
    |                    ^^^^^^^^^^^^^^ DTZ005
303 |
304 |     # Si no se especifica start_date, usar 30 días antes de end_date
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\routers\twilio_webhook_router.py:5:1: I001 [*] Import block is un-sorted or un-formatted
   |
 3 |   """
 4 |
 5 | / import logging
 6 | |
 7 | | from fastapi import APIRouter, Depends, HTTPException, Request, Response
 8 | | from fastapi.responses import PlainTextResponse
 9 | | from twilio.request_validator import RequestValidator
10 | | from twilio.twiml.voice_response import Gather, VoiceResponse
11 | |
12 | | from app.config.settings import settings
13 | | from app.dependencies.service_dependencies import get_call_service
14 | | from app.models.call import CallStatus
15 | | from app.services.call_service import CallService
16 | |
17 | | from typing import Any
   | |______________________^ I001
18 |
19 |   # Configurar logger
   |
   = help: Organize imports

backend-call-automation\app\routers\twilio_webhook_router.py:17:20: F401 [*] `typing.Any` imported but unused
   |
15 | from app.services.call_service import CallService
16 |
17 | from typing import Any
   |                    ^^^ F401
18 |
19 | # Configurar logger
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\routers\twilio_webhook_router.py:64:11: ANN201 Missing return type annotation for public function `twilio_webhook`
   |
63 | @router.post("/", response_class=PlainTextResponse)
64 | async def twilio_webhook(request: Request, call_service: CallService = Depends(get_call_service)):
   |           ^^^^^^^^^^^^^^ ANN201
65 |     """
66 |     Webhook principal para manejar llamadas de Twilio.
   |
   = help: Add return type annotation

backend-call-automation\app\routers\twilio_webhook_router.py:112:101: E501 Line too long (129 > 100)
    |
111 |     gather.say(
112 |         "Presione 1 si está interesado, 2 si desea que le llamemos más tarde, o diga 'interesado' para recibir más información.",
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
113 |         voice="woman",
114 |         language="es-ES",
    |

backend-call-automation\app\routers\twilio_webhook_router.py:132:11: ANN201 Missing return type annotation for public function `twilio_gather_webhook`
    |
131 | @router.post("/gather", response_class=PlainTextResponse)
132 | async def twilio_gather_webhook(
    |           ^^^^^^^^^^^^^^^^^^^^^ ANN201
133 |     request: Request, call_service: CallService = Depends(get_call_service)
134 | ):
    |
    = help: Add return type annotation

backend-call-automation\app\routers\twilio_webhook_router.py:165:101: E501 Line too long (126 > 100)
    |
163 |         # Usuario interesado
164 |         response.say(
165 |             "Gracias por su interés. Un representante se pondrá en contacto con usted pronto para brindarle más información.",
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
166 |             voice="woman",
167 |             language="es-ES",
    |

backend-call-automation\app\routers\twilio_webhook_router.py:187:101: E501 Line too long (107 > 100)
    |
185 |         # Respuesta no reconocida
186 |         response.say(
187 |             "No hemos podido entender su respuesta. Gracias por su tiempo, le llamaremos en otro momento.",
    |                                                                                                     ^^^^^^^ E501
188 |             voice="woman",
189 |             language="es-ES",
    |

backend-call-automation\app\routers\twilio_webhook_router.py:201:11: ANN201 Missing return type annotation for public function `call_status_webhook`
    |
200 | @router.post("/status", response_class=PlainTextResponse)
201 | async def call_status_webhook(
    |           ^^^^^^^^^^^^^^^^^^^ ANN201
202 |     request: Request, call_service: CallService = Depends(get_call_service)
203 | ):
    |
    = help: Add return type annotation

backend-call-automation\app\schemas\call.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from pydantic import BaseModel, ConfigDict, Field
2 | |
3 | | from app.models.call import CallStatus
4 | |
5 | |
6 | | from typing import Any
  | |______________________^ I001
7 |
8 |   class CallCreate(BaseModel):
  |
  = help: Organize imports

backend-call-automation\app\schemas\call.py:6:20: F401 [*] `typing.Any` imported but unused
  |
6 | from typing import Any
  |                    ^^^ F401
7 |
8 | class CallCreate(BaseModel):
  |
  = help: Remove unused import: `typing.Any`

backend-call-automation\app\schemas\campaign.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from datetime import datetime
 2 | | from uuid import UUID
 3 | |
 4 | | from pydantic import BaseModel, ConfigDict, Field, validator
 5 | |
 6 | | from app.models.campaign import CampaignStatus
 7 | |
 8 | |
 9 | | from typing import Optional, Any
   | |________________________________^ I001
10 |
11 |   class CampaignCreate(BaseModel):
   |
   = help: Organize imports

backend-call-automation\app\schemas\campaign.py:9:20: F401 [*] `typing.Optional` imported but unused
   |
 9 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
10 |
11 | class CampaignCreate(BaseModel):
   |
   = help: Remove unused import

backend-call-automation\app\schemas\campaign.py:9:30: F401 [*] `typing.Any` imported but unused
   |
 9 | from typing import Optional, Any
   |                              ^^^ F401
10 |
11 | class CampaignCreate(BaseModel):
   |
   = help: Remove unused import

backend-call-automation\app\schemas\campaign.py:31:31: N805 First argument of a method should be named `self`
   |
30 |     @validator("schedule_end")
31 |     def validate_schedule_end(cls, v: datetime, values: dict) -> datetime:
   |                               ^^^ N805
32 |         if "schedule_start" in values and v <= values["schedule_start"]:
33 |             raise ValueError("La fecha de fin debe ser posterior a la de inicio")
   |
   = help: Rename `cls` to `self`

backend-call-automation\app\schemas\campaign.py:33:19: TRY003 Avoid specifying long messages outside the exception class
   |
31 |     def validate_schedule_end(cls, v: datetime, values: dict) -> datetime:
32 |         if "schedule_start" in values and v <= values["schedule_start"]:
33 |             raise ValueError("La fecha de fin debe ser posterior a la de inicio")
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
34 |         return v
   |

backend-call-automation\app\schemas\campaign.py:37:32: N805 First argument of a method should be named `self`
   |
36 |     @validator("calling_hours_end")
37 |     def validate_calling_hours(cls, v: str, values: dict) -> str:
   |                                ^^^ N805
38 |         if "calling_hours_start" in values:
39 |             start = datetime.strptime(values["calling_hours_start"], "%H:%M").time()
   |
   = help: Rename `cls` to `self`

backend-call-automation\app\schemas\campaign.py:39:21: DTZ007 Naive datetime constructed using `datetime.datetime.strptime()` without %z
   |
37 |     def validate_calling_hours(cls, v: str, values: dict) -> str:
38 |         if "calling_hours_start" in values:
39 |             start = datetime.strptime(values["calling_hours_start"], "%H:%M").time()
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ007
40 |             end = datetime.strptime(v, "%H:%M").time()
41 |             if end <= start:
   |
   = help: Call `.replace(tzinfo=<timezone>)` or `.astimezone()` to convert to an aware datetime

backend-call-automation\app\schemas\campaign.py:40:19: DTZ007 Naive datetime constructed using `datetime.datetime.strptime()` without %z
   |
38 |         if "calling_hours_start" in values:
39 |             start = datetime.strptime(values["calling_hours_start"], "%H:%M").time()
40 |             end = datetime.strptime(v, "%H:%M").time()
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ007
41 |             if end <= start:
42 |                 raise ValueError("La hora de fin debe ser posterior a la de inicio")
   |
   = help: Call `.replace(tzinfo=<timezone>)` or `.astimezone()` to convert to an aware datetime

backend-call-automation\app\schemas\campaign.py:42:23: TRY003 Avoid specifying long messages outside the exception class
   |
40 |             end = datetime.strptime(v, "%H:%M").time()
41 |             if end <= start:
42 |                 raise ValueError("La hora de fin debe ser posterior a la de inicio")
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
43 |         return v
   |

backend-call-automation\app\schemas\client.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from datetime import datetime
2 | | from uuid import UUID
3 | |
4 | | from pydantic import BaseModel, EmailStr, Field
5 | |
6 | |
7 | | from typing import Optional, Any
  | |________________________________^ I001
8 |
9 |   class ClientBase(BaseModel):
  |
  = help: Organize imports

backend-call-automation\app\schemas\client.py:7:20: F401 [*] `typing.Optional` imported but unused
  |
7 | from typing import Optional, Any
  |                    ^^^^^^^^ F401
8 |
9 | class ClientBase(BaseModel):
  |
  = help: Remove unused import

backend-call-automation\app\schemas\client.py:7:30: F401 [*] `typing.Any` imported but unused
  |
7 | from typing import Optional, Any
  |                              ^^^ F401
8 |
9 | class ClientBase(BaseModel):
  |
  = help: Remove unused import

backend-call-automation\app\services\ai_conversation_service.py:7:25: F401 [*] `typing.Optional` imported but unused
  |
5 | import logging
6 | from datetime import datetime
7 | from typing import Any, Optional
  |                         ^^^^^^^^ F401
8 |
9 | from fastapi import HTTPException
  |
  = help: Remove unused import: `typing.Optional`

backend-call-automation\app\services\ai_conversation_service.py:25:24: ARG002 Unused method argument: `model_name`
   |
24 | class AIConversationService:
25 |     def __init__(self, model_name: str = "gpt-4") -> None:
   |                        ^^^^^^^^^^ ARG002
26 |         self.llm = ChatGoogleGenerativeAI(
27 |             model="gemini-pro",
   |

backend-call-automation\app\services\ai_conversation_service.py:35:101: E501 Line too long (105 > 100)
   |
33 |         self.prompt = PromptTemplate(
34 |             input_variables=["history", "input"],
35 |             template="""Eres un agente telefónico profesional y amable. Tu objetivo es ayudar al usuario.
   |                                                                                                     ^^^^^ E501
36 |
37 |             Historial de la conversación:
   |

backend-call-automation\app\services\ai_conversation_service.py:48:9: ARG002 Unused method argument: `context`
   |
46 |         message: str,
47 |         conversation_id: str | None = None,
48 |         context: dict[str, Any] | None = None,
   |         ^^^^^^^ ARG002
49 |     ) -> dict[str, Any]:
50 |         """Procesa un mensaje y genera una respuesta."""
   |

backend-call-automation\app\services\ai_conversation_service.py:97:17: TRY300 Consider moving this statement to an `else` block
    |
 95 |                       )
 96 |
 97 | /                 return {
 98 | |                     "response": response,
 99 | |                     "input_sentiment": input_sentiment,
100 | |                     "response_sentiment": response_sentiment,
101 | |                     "conversation_id": conversation_id,
102 | |                 }
    | |_________________^ TRY300
103 |               except Exception as e:
104 |                   logger.error(f"Error procesando mensaje: {e!s}")
    |

backend-call-automation\app\services\ai_conversation_service.py:104:17: TRY400 Use `logging.exception` instead of `logging.error`
    |
102 |                 }
103 |             except Exception as e:
104 |                 logger.error(f"Error procesando mensaje: {e!s}")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
105 |                 raise HTTPException(status_code=500, detail="Error procesando mensaje")
    |
    = help: Replace with `exception`

backend-call-automation\app\services\ai_conversation_service.py:105:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
103 |             except Exception as e:
104 |                 logger.error(f"Error procesando mensaje: {e!s}")
105 |                 raise HTTPException(status_code=500, detail="Error procesando mensaje")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
106 |
107 |     async def analyze_sentiment(self, text: str) -> dict[str, Any]:
    |

backend-call-automation\app\services\ai_conversation_service.py:115:101: E501 Line too long (130 > 100)
    |
113 |             template="""Analiza el sentimiento del siguiente texto y clasifícalo.
114 |             Texto: {text}
115 |             Devuelve un objeto JSON con la emoción primaria (primary_emotion) y su puntuación (score). \n{format_instructions}""",
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
116 |         )
    |

backend-call-automation\app\services\ai_conversation_service.py:122:38: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
    |
120 |             # Convertir la respuesta a string si es necesario
121 |             response_str = (
122 |                 str(response) if not isinstance(response, (str, bytes, bytearray)) else response
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
123 |             )
124 |             return json.loads(response_str)
    |
    = help: Convert to `X | Y`

backend-call-automation\app\services\ai_conversation_service.py:126:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
124 |             return json.loads(response_str)
125 |         except Exception as e:
126 |             logger.error(f"Error al analizar el sentimiento: {e}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
127 |             return {"primary_emotion": "neutral", "score": 0.5}
    |
    = help: Replace with `exception`

backend-call-automation\app\services\ai_conversation_service.py:148:26: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
146 |         interaction_data = {
147 |             "conversation_id": conversation_id,
148 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^ DTZ005
149 |             "message_length": len(message),
150 |             "response_length": len(response),
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\ai_conversation_service.py:165:9: ERA001 Found commented-out code
    |
163 |         # Implementación del guardado de métricas en la base de datos
164 |         # Ejemplo:
165 |         # try:
    |         ^^^^^^ ERA001
166 |         #     data, error = await supabase_client.table("conversation_metrics").insert(interaction_data).execute()
167 |         #     if error:
    |
    = help: Remove commented-out code

backend-call-automation\app\services\ai_conversation_service.py:166:9: ERA001 Found commented-out code
    |
164 |         # Ejemplo:
165 |         # try:
166 |         #     data, error = await supabase_client.table("conversation_metrics").insert(interaction_data).execute()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
167 |         #     if error:
168 |         #         logger.error(f"Error al guardar métricas en la base de datos: {error}")
    |
    = help: Remove commented-out code

backend-call-automation\app\services\ai_conversation_service.py:166:101: E501 Line too long (114 > 100)
    |
164 |         # Ejemplo:
165 |         # try:
166 |         #     data, error = await supabase_client.table("conversation_metrics").insert(interaction_data).execute()
    |                                                                                                     ^^^^^^^^^^^^^^ E501
167 |         #     if error:
168 |         #         logger.error(f"Error al guardar métricas en la base de datos: {error}")
    |

backend-call-automation\app\services\ai_conversation_service.py:168:9: ERA001 Found commented-out code
    |
166 |         #     data, error = await supabase_client.table("conversation_metrics").insert(interaction_data).execute()
167 |         #     if error:
168 |         #         logger.error(f"Error al guardar métricas en la base de datos: {error}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
169 |         # except Exception as e:
170 |         #     logger.error(f"Error al guardar métricas en la base de datos: {e}")
    |
    = help: Remove commented-out code

backend-call-automation\app\services\ai_conversation_service.py:169:9: ERA001 Found commented-out code
    |
167 |         #     if error:
168 |         #         logger.error(f"Error al guardar métricas en la base de datos: {error}")
169 |         # except Exception as e:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
170 |         #     logger.error(f"Error al guardar métricas en la base de datos: {e}")
    |
    = help: Remove commented-out code

backend-call-automation\app\services\ai_conversation_service.py:170:9: ERA001 Found commented-out code
    |
168 |         #         logger.error(f"Error al guardar métricas en la base de datos: {error}")
169 |         # except Exception as e:
170 |         #     logger.error(f"Error al guardar métricas en la base de datos: {e}")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
171 |
172 |     def extract_conversation_context(self, memory: ConversationBufferMemory) -> dict[str, Any]:
    |
    = help: Remove commented-out code

backend-call-automation\app\services\ai_conversation_service.py:172:44: ARG002 Unused method argument: `memory`
    |
170 |         #     logger.error(f"Error al guardar métricas en la base de datos: {e}")
171 |
172 |     def extract_conversation_context(self, memory: ConversationBufferMemory) -> dict[str, Any]:
    |                                            ^^^^^^ ARG002
173 |         """Extrae el contexto de la conversación.
    |

backend-call-automation\app\services\ai_conversation_service.py:184:49: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `get_from_cache`
    |
182 |         return {}
183 |
184 |     async def get_from_cache(self, key: str) -> Any:
    |                                                 ^^^ ANN401
185 |         """Recupera el valor de la caché."""
186 |         logger.info(f"Recuperando de la caché la clave: {key}")
    |

backend-call-automation\app\services\ai_conversation_service.py:190:51: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
    |
188 |         return None
189 |
190 |     async def set_in_cache(self, key: str, value: Any) -> None:
    |                                                   ^^^ ANN401
191 |         """Guarda el valor en la caché."""
192 |         logger.info(f"Guardando en la caché la clave: {key} con el valor: {value}")
    |

backend-call-automation\app\services\alert_service.py:1:101: E501 Line too long (104 > 100)
  |
1 | """Servicio de alertas para monitorear y notificar problemas en el sistema de llamadas automatizadas."""
  |                                                                                                     ^^^^ E501
2 |
3 | import logging
  |

backend-call-automation\app\services\alert_service.py:5:25: F401 [*] `typing.Optional` imported but unused
  |
3 | import logging
4 | from datetime import datetime, timedelta
5 | from typing import Any, Optional
  |                         ^^^^^^^^ F401
6 |
7 | logger = logging.getLogger(__name__)
  |
  = help: Remove unused import: `typing.Optional`

backend-call-automation\app\services\alert_service.py:41:26: DTZ005 `datetime.datetime.now()` called without a `tz` argument
   |
39 |         """
40 |         alert = {
41 |             "timestamp": datetime.now().isoformat(),
   |                          ^^^^^^^^^^^^^^ DTZ005
42 |             "level": level,
43 |             "message": message,
   |
   = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\alert_service.py:74:17: DTZ005 `datetime.datetime.now()` called without a `tz` argument
   |
72 |             alert
73 |             for alert in self.alerts_history
74 |             if (datetime.now() - datetime.fromisoformat(alert["timestamp"])).total_seconds()
   |                 ^^^^^^^^^^^^^^ DTZ005
75 |             < window_minutes * 60
76 |         ]
   |
   = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\alert_service.py:79:76: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
78 |         patterns = []
79 |         if len([a for a in recent_alerts if "latencia" in a["message"]]) > 3:
   |                                                                            ^ PLR2004
80 |             patterns.append(
81 |                 {
   |

backend-call-automation\app\services\alert_service.py:125:48: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
123 |             )
124 |
125 |         if metrics.get("audio_quality", 1.0) < 0.5:
    |                                                ^^^ PLR2004
126 |             await self.send_alert(
127 |                 level="warning",
    |

backend-call-automation\app\services\alert_service.py:145:24: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
143 |         # Por ahora, simulamos un cálculo basado en el historial de alertas
144 |
145 |         window_start = datetime.now() - timedelta(minutes=window_minutes)
    |                        ^^^^^^^^^^^^^^ DTZ005
146 |
147 |         # Contar errores en la ventana de tiempo
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\audio_cache_service.py:63:33: DTZ005 `datetime.datetime.now()` called without a `tz` argument
   |
61 |                 "files": {},
62 |                 "total_size": 0,
63 |                 "last_cleanup": datetime.now().isoformat(),
   |                                 ^^^^^^^^^^^^^^ DTZ005
64 |             }
65 |             self._save_metadata(metadata)
   |
   = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\audio_cache_service.py:78:13: TRY400 Use `logging.exception` instead of `logging.error`
   |
76 |                 json.dump(metadata, f)
77 |         except Exception as e:
78 |             logger.error(f"Error al guardar metadatos de caché de audio: {e!s}")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
79 |
80 |     def _load_metadata(self) -> dict[str, Any]:
   |
   = help: Replace with `exception`

backend-call-automation\app\services\audio_cache_service.py:91:13: TRY400 Use `logging.exception` instead of `logging.error`
   |
89 |                 return json.load(f)
90 |         except Exception as e:
91 |             logger.error(f"Error al cargar metadatos de caché de audio: {e!s}")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
92 |             return {"files": {}, "total_size": 0, "last_cleanup": datetime.now().isoformat()}
   |
   = help: Replace with `exception`

backend-call-automation\app\services\audio_cache_service.py:92:67: DTZ005 `datetime.datetime.now()` called without a `tz` argument
   |
90 |         except Exception as e:
91 |             logger.error(f"Error al cargar metadatos de caché de audio: {e!s}")
92 |             return {"files": {}, "total_size": 0, "last_cleanup": datetime.now().isoformat()}
   |                                                                   ^^^^^^^^^^^^^^ DTZ005
93 |
94 |     def _generate_cache_key(self, text: str, voice_id: str, language: str = "es") -> str:
   |
   = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\audio_cache_service.py:111:22: S324 Probable use of insecure hash functions in `hashlib`: `md5`
    |
109 |         # Crear hash del texto + voz + idioma
110 |         hash_input = f"{normalized_text}|{voice_id}|{language}"
111 |         hash_value = hashlib.md5(hash_input.encode()).hexdigest()
    |                      ^^^^^^^^^^^ S324
112 |
113 |         return hash_value
    |

backend-call-automation\app\services\audio_cache_service.py:113:16: RET504 Unnecessary assignment to `hash_value` before `return` statement
    |
111 |         hash_value = hashlib.md5(hash_input.encode()).hexdigest()
112 |
113 |         return hash_value
    |                ^^^^^^^^^^ RET504
114 |
115 |     def _get_file_path(self, cache_key: str) -> str:
    |
    = help: Remove unnecessary assignment

backend-call-automation\app\services\audio_cache_service.py:161:35: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
159 |                     "path": file_path,
160 |                     "size": file_size,
161 |                     "created_at": datetime.now().isoformat(),
    |                                   ^^^^^^^^^^^^^^ DTZ005
162 |                     "last_accessed": datetime.now().isoformat(),
163 |                     "access_count": 1,
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\audio_cache_service.py:162:38: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
160 |                     "size": file_size,
161 |                     "created_at": datetime.now().isoformat(),
162 |                     "last_accessed": datetime.now().isoformat(),
    |                                      ^^^^^^^^^^^^^^ DTZ005
163 |                     "access_count": 1,
164 |                     "text": text[:100] + "..." if len(text) > 100 else text,
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\audio_cache_service.py:164:63: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
162 |                     "last_accessed": datetime.now().isoformat(),
163 |                     "access_count": 1,
164 |                     "text": text[:100] + "..." if len(text) > 100 else text,
    |                                                               ^^^ PLR2004
165 |                     "voice_id": voice_id,
166 |                     "language": language,
    |

backend-call-automation\app\services\audio_cache_service.py:175:16: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
173 |             file_info = metadata["files"][cache_key]
174 |             created_at = datetime.fromisoformat(file_info["created_at"])
175 |             if datetime.now() - created_at > timedelta(seconds=self.cache_ttl):
    |                ^^^^^^^^^^^^^^ DTZ005
176 |                 # Eliminar archivo expirado
177 |                 await self.remove_from_cache(cache_key)
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\audio_cache_service.py:181:61: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
180 |             # Actualizar metadatos de acceso
181 |             metadata["files"][cache_key]["last_accessed"] = datetime.now().isoformat()
    |                                                             ^^^^^^^^^^^^^^ DTZ005
182 |             metadata["files"][cache_key]["access_count"] += 1
183 |             self._save_metadata(metadata)
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\audio_cache_service.py:186:13: TRY300 Consider moving this statement to an `else` block
    |
185 |             logger.info(f"Audio encontrado en caché: {cache_key}")
186 |             return file_path
    |             ^^^^^^^^^^^^^^^^ TRY300
187 |
188 |         except Exception as e:
    |

backend-call-automation\app\services\audio_cache_service.py:189:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
188 |         except Exception as e:
189 |             logger.error(f"Error al buscar audio en caché: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
190 |             return None
    |
    = help: Replace with `exception`

backend-call-automation\app\services\audio_cache_service.py:233:31: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
231 |                 "path": file_path,
232 |                 "size": file_size,
233 |                 "created_at": datetime.now().isoformat(),
    |                               ^^^^^^^^^^^^^^ DTZ005
234 |                 "last_accessed": datetime.now().isoformat(),
235 |                 "access_count": 0,
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\audio_cache_service.py:234:34: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
232 |                 "size": file_size,
233 |                 "created_at": datetime.now().isoformat(),
234 |                 "last_accessed": datetime.now().isoformat(),
    |                                  ^^^^^^^^^^^^^^ DTZ005
235 |                 "access_count": 0,
236 |                 "text": text[:100] + "..." if len(text) > 100 else text,
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\audio_cache_service.py:236:59: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
234 |                 "last_accessed": datetime.now().isoformat(),
235 |                 "access_count": 0,
236 |                 "text": text[:100] + "..." if len(text) > 100 else text,
    |                                                           ^^^ PLR2004
237 |                 "voice_id": voice_id,
238 |                 "language": language,
    |

backend-call-automation\app\services\audio_cache_service.py:245:13: TRY300 Consider moving this statement to an `else` block
    |
244 |             logger.info(f"Audio guardado en caché: {cache_key} ({file_size} bytes)")
245 |             return file_path
    |             ^^^^^^^^^^^^^^^^ TRY300
246 |
247 |         except Exception as e:
    |

backend-call-automation\app\services\audio_cache_service.py:248:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
247 |         except Exception as e:
248 |             logger.error(f"Error al guardar audio en caché: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
249 |             return ""
    |
    = help: Replace with `exception`

backend-call-automation\app\services\audio_cache_service.py:277:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
276 |         except Exception as e:
277 |             logger.error(f"Error al guardar archivo en caché: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
278 |             return ""
    |
    = help: Replace with `exception`

backend-call-automation\app\services\audio_cache_service.py:313:13: TRY300 Consider moving this statement to an `else` block
    |
312 |             logger.info(f"Audio eliminado de caché: {cache_key}")
313 |             return True
    |             ^^^^^^^^^^^ TRY300
314 |
315 |         except Exception as e:
    |

backend-call-automation\app\services\audio_cache_service.py:316:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
315 |         except Exception as e:
316 |             logger.error(f"Error al eliminar audio de caché: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
317 |             return False
    |
    = help: Replace with `exception`

backend-call-automation\app\services\audio_cache_service.py:370:40: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
369 |             # Guardar metadatos actualizados
370 |             metadata["last_cleanup"] = datetime.now().isoformat()
    |                                        ^^^^^^^^^^^^^^ DTZ005
371 |             self._save_metadata(metadata)
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\audio_cache_service.py:374:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
373 |         except Exception as e:
374 |             logger.error(f"Error al limpiar caché de audio: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
375 |
376 |     async def clear_cache(self) -> bool:
    |
    = help: Replace with `exception`

backend-call-automation\app\services\audio_cache_service.py:390:17: B007 Loop control variable `cache_key` not used within loop body
    |
389 |             # Eliminar todos los archivos
390 |             for cache_key, file_info in metadata["files"].items():
    |                 ^^^^^^^^^ B007
391 |                 file_path = file_info["path"]
392 |                 if os.path.exists(file_path):
    |
    = help: Rename unused `cache_key` to `_cache_key`

backend-call-automation\app\services\audio_cache_service.py:399:33: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
397 |                 "files": {},
398 |                 "total_size": 0,
399 |                 "last_cleanup": datetime.now().isoformat(),
    |                                 ^^^^^^^^^^^^^^ DTZ005
400 |             }
401 |             self._save_metadata(metadata)
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\audio_cache_service.py:404:13: TRY300 Consider moving this statement to an `else` block
    |
403 |             logger.info("Caché de audio limpiado completamente")
404 |             return True
    |             ^^^^^^^^^^^ TRY300
405 |
406 |         except Exception as e:
    |

backend-call-automation\app\services\audio_cache_service.py:407:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
406 |         except Exception as e:
407 |             logger.error(f"Error al limpiar caché de audio: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
408 |             return False
    |
    = help: Replace with `exception`

backend-call-automation\app\services\audio_cache_service.py:476:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
475 |         except Exception as e:
476 |             logger.error(f"Error al obtener estadísticas de caché de audio: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
477 |             return {"enabled": self.enabled, "error": str(e)}
    |
    = help: Replace with `exception`

backend-call-automation\app\services\auth_service.py:8:25: F401 [*] `typing.Optional` imported but unused
   |
 6 | """
 7 |
 8 | from typing import Any, Optional
   |                         ^^^^^^^^ F401
 9 |
10 | from fastapi import HTTPException, status
   |
   = help: Remove unused import: `typing.Optional`

backend-call-automation\app\services\auth_service.py:54:17: TRY301 Abstract `raise` to an inner function
   |
53 |               if not user:
54 | /                 raise HTTPException(
55 | |                     status_code=status.HTTP_404_NOT_FOUND, detail="Usuario no encontrado"
56 | |                 )
   | |_________________^ TRY301
57 |
58 |               return {
   |

backend-call-automation\app\services\auth_service.py:58:13: TRY300 Consider moving this statement to an `else` block
   |
56 |                   )
57 |
58 | /             return {
59 | |                 "id": user.id,
60 | |                 "email": user.email,
61 | |                 "phone": user.phone,
62 | |                 "created_at": user.created_at,
63 | |                 "updated_at": user.updated_at,
64 | |                 "last_sign_in_at": user.last_sign_in_at,
65 | |                 "app_metadata": user.app_metadata,
66 | |                 "user_metadata": user.user_metadata,
67 | |                 "identities": user.identities,
68 | |             }
   | |_____________^ TRY300
69 |           except Exception as e:
70 |               logger.error(f"Error al obtener usuario: {e!s}")
   |

backend-call-automation\app\services\auth_service.py:71:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
69 |           except Exception as e:
70 |               logger.error(f"Error al obtener usuario: {e!s}")
71 | /             raise HTTPException(
72 | |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
73 | |                 detail=f"Error al obtener usuario: {e!s}",
74 | |             )
   | |_____________^ B904
75 |
76 |       async def get_user_by_email(self, email: str) -> dict[str, Any]:
   |

backend-call-automation\app\services\auth_service.py:98:17: TRY301 Abstract `raise` to an inner function
    |
 97 |               if not user:
 98 | /                 raise HTTPException(
 99 | |                     status_code=status.HTTP_404_NOT_FOUND, detail="Usuario no encontrado"
100 | |                 )
    | |_________________^ TRY301
101 |
102 |               return {
    |

backend-call-automation\app\services\auth_service.py:102:13: TRY300 Consider moving this statement to an `else` block
    |
100 |                   )
101 |
102 | /             return {
103 | |                 "id": user.id,
104 | |                 "email": user.email,
105 | |                 "phone": user.phone,
106 | |                 "created_at": user.created_at,
107 | |                 "updated_at": user.updated_at,
108 | |                 "last_sign_in_at": user.last_sign_in_at,
109 | |                 "app_metadata": user.app_metadata,
110 | |                 "user_metadata": user.user_metadata,
111 | |                 "identities": user.identities,
112 | |             }
    | |_____________^ TRY300
113 |           except Exception as e:
114 |               logger.error(f"Error al obtener usuario por email: {e!s}")
    |

backend-call-automation\app\services\auth_service.py:115:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
113 |           except Exception as e:
114 |               logger.error(f"Error al obtener usuario por email: {e!s}")
115 | /             raise HTTPException(
116 | |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
117 | |                 detail=f"Error al obtener usuario por email: {e!s}",
118 | |             )
    | |_____________^ B904
119 |
120 |       async def get_user_roles(self, user_id: str) -> list[str]:
    |

backend-call-automation\app\services\auth_service.py:139:13: TRY300 Consider moving this statement to an `else` block
    |
137 |             roles = [item["role"] for item in response.data]
138 |
139 |             return roles
    |             ^^^^^^^^^^^^ TRY300
140 |         except Exception as e:
141 |             logger.error(f"Error al obtener roles de usuario: {e!s}")
    |

backend-call-automation\app\services\auth_service.py:139:20: RET504 Unnecessary assignment to `roles` before `return` statement
    |
137 |             roles = [item["role"] for item in response.data]
138 |
139 |             return roles
    |                    ^^^^^ RET504
140 |         except Exception as e:
141 |             logger.error(f"Error al obtener roles de usuario: {e!s}")
    |
    = help: Remove unnecessary assignment

backend-call-automation\app\services\auth_service.py:176:13: TRY300 Consider moving this statement to an `else` block
    |
174 |                     return True
175 |
176 |             return False
    |             ^^^^^^^^^^^^ TRY300
177 |         except Exception as e:
178 |             logger.error(f"Error al verificar permiso: {e!s}")
    |

backend-call-automation\app\services\auth_service.py:182:57: RUF013 PEP 484 prohibits implicit `Optional`
    |
181 |     async def create_user(
182 |         self, email: str, password: str, user_metadata: dict[str, Any] = None
    |                                                         ^^^^^^^^^^^^^^ RUF013
183 |     ) -> dict[str, Any]:
184 |         """
    |
    = help: Convert to `T | None`

backend-call-automation\app\services\auth_service.py:211:13: TRY300 Consider moving this statement to an `else` block
    |
209 |               user = response.user
210 |
211 | /             return {
212 | |                 "id": user.id,
213 | |                 "email": user.email,
214 | |                 "created_at": user.created_at,
215 | |                 "user_metadata": user.user_metadata,
216 | |             }
    | |_____________^ TRY300
217 |           except Exception as e:
218 |               logger.error(f"Error al crear usuario: {e!s}")
    |

backend-call-automation\app\services\auth_service.py:219:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
217 |           except Exception as e:
218 |               logger.error(f"Error al crear usuario: {e!s}")
219 | /             raise HTTPException(
220 | |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
221 | |                 detail=f"Error al crear usuario: {e!s}",
222 | |             )
    | |_____________^ B904
223 |
224 |       async def assign_role(self, user_id: str, role: str) -> bool:
    |

backend-call-automation\app\services\auth_service.py:252:13: TRY300 Consider moving this statement to an `else` block
    |
250 |             self.supabase.table("user_roles").insert({"user_id": user_id, "role": role}).execute()
251 |
252 |             return True
    |             ^^^^^^^^^^^ TRY300
253 |         except Exception as e:
254 |             logger.error(f"Error al asignar rol: {e!s}")
    |

backend-call-automation\app\services\auth_service.py:274:13: TRY300 Consider moving this statement to an `else` block
    |
272 |             ).execute()
273 |
274 |             return True
    |             ^^^^^^^^^^^ TRY300
275 |         except Exception as e:
276 |             logger.error(f"Error al eliminar rol: {e!s}")
    |

backend-call-automation\app\services\cache_service.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Servicio para gestionar la caché y su sincronización con Supabase."""
 2 |
 3 | / import asyncio
 4 | | import logging
 5 | | from datetime import datetime
 6 | |
 7 | | from app.config.redis_client import (
 8 | |     clear_cache,
 9 | |     get_cache_metrics,
10 | |     sync_to_supabase,
11 | | )
12 | | from app.models.cache_metrics import CacheMetrics
13 | | from typing import Optional, Any
   | |________________________________^ I001
14 |
15 |   logger = logging.getLogger(__name__)
   |
   = help: Organize imports

backend-call-automation\app\services\cache_service.py:13:20: F401 [*] `typing.Optional` imported but unused
   |
11 | )
12 | from app.models.cache_metrics import CacheMetrics
13 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
14 |
15 | logger = logging.getLogger(__name__)
   |
   = help: Remove unused import

backend-call-automation\app\services\cache_service.py:13:30: F401 [*] `typing.Any` imported but unused
   |
11 | )
12 | from app.models.cache_metrics import CacheMetrics
13 | from typing import Optional, Any
   |                              ^^^ F401
14 |
15 | logger = logging.getLogger(__name__)
   |
   = help: Remove unused import

backend-call-automation\app\services\cache_service.py:53:13: SIM105 Use `contextlib.suppress(asyncio.CancelledError)` instead of `try`-`except`-`pass`
   |
51 |               self._running = False
52 |               self.sync_task.cancel()
53 | /             try:
54 | |                 await self.sync_task
55 | |             except asyncio.CancelledError:
56 | |                 pass
   | |____________________^ SIM105
57 |               logger.info("Tarea de sincronización detenida")
   |
   = help: Replace with `contextlib.suppress(asyncio.CancelledError)`

backend-call-automation\app\services\cache_service.py:71:17: TRY400 Use `logging.exception` instead of `logging.error`
   |
69 |                 break
70 |             except Exception as e:
71 |                 logger.error(f"Error en bucle de sincronización: {e!s}")
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
72 |                 # Esperar un poco antes de reintentar
73 |                 await asyncio.sleep(10)
   |
   = help: Replace with `exception`

backend-call-automation\app\services\cache_service.py:115:20: PLR2004 Magic value used in comparison, consider replacing `9` with a constant variable
    |
113 |             for hour in range(24):
114 |                 # Simular mayor uso en horas laborales (9-18)
115 |                 if 9 <= hour <= 18:
    |                    ^ PLR2004
116 |                     day_stats[str(hour)] = float(50 + (day % 3) * 10)  # Valor alto para horas pico
117 |                 else:
    |

backend-call-automation\app\services\cache_service.py:115:33: PLR2004 Magic value used in comparison, consider replacing `18` with a constant variable
    |
113 |             for hour in range(24):
114 |                 # Simular mayor uso en horas laborales (9-18)
115 |                 if 9 <= hour <= 18:
    |                                 ^^ PLR2004
116 |                     day_stats[str(hour)] = float(50 + (day % 3) * 10)  # Valor alto para horas pico
117 |                 else:
    |

backend-call-automation\app\services\cache_service.py:125:28: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
123 |         """Optimización proactiva basada en predicciones"""
124 |         patterns = await self.predict_usage_patterns()
125 |         current_hour = str(datetime.now().hour)
    |                            ^^^^^^^^^^^^^^ DTZ005
126 |
127 |         # Ajustar TTL y tamaño de caché para horas pico
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\cache_service.py:150:101: E501 Line too long (129 > 100)
    |
148 |         # En un entorno real, esto restauraría la configuración predeterminada
149 |         logger.info(
150 |             f"Restaurando configuración normal: TTL={self.settings['DEFAULT_TTL']}, tamaño={self.settings['DEFAULT_CACHE_SIZE']}"
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
151 |         )
    |

backend-call-automation\app\services\cache_service.py:202:13: TRY300 Consider moving this statement to an `else` block
    |
200 |                 return await set_in_cache(cache_key, memory_data)
201 |
202 |             return False
    |             ^^^^^^^^^^^^ TRY300
203 |         except Exception as e:
204 |             logger.error(f"Error al precargar conversación: {e!s}")
    |

backend-call-automation\app\services\cache_service.py:204:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
202 |             return False
203 |         except Exception as e:
204 |             logger.error(f"Error al precargar conversación: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
205 |             return False
    |
    = help: Replace with `exception`

backend-call-automation\app\services\call_service.py:5:1: I001 [*] Import block is un-sorted or un-formatted
   |
 3 |   """
 4 |
 5 | / import logging
 6 | | import uuid
 7 | | from collections.abc import AsyncGenerator
 8 | | from datetime import UTC, datetime
 9 | | from typing import Optional, Any # Moved import here
10 | |
11 | | from fastapi import HTTPException
12 | |
13 | | from app.config.settings import settings
14 | | from app.models.call import Call, CallCreate, CallStatus, CallUpdate
15 | | from app.models.call_metrics import CallMetrics
16 | | from app.services.campaign_service import CampaignService
17 | | from app.services.contact_service import ContactService
18 | | from app.services.twilio_service import TwilioService
19 | |
20 | | from .ai_conversation_service import AIConversationService
21 | | from .elevenlabs_service import ElevenLabsService
22 | | from .fallback_service import FallbackService
23 | | from .monitoring_service import MonitoringService
   | |_________________________________________________^ I001
   |
   = help: Organize imports

backend-call-automation\app\services\call_service.py:9:20: F401 [*] `typing.Optional` imported but unused
   |
 7 | from collections.abc import AsyncGenerator
 8 | from datetime import UTC, datetime
 9 | from typing import Optional, Any # Moved import here
   |                    ^^^^^^^^ F401
10 |
11 | from fastapi import HTTPException
   |
   = help: Remove unused import

backend-call-automation\app\services\call_service.py:9:30: F401 [*] `typing.Any` imported but unused
   |
 7 | from collections.abc import AsyncGenerator
 8 | from datetime import UTC, datetime
 9 | from typing import Optional, Any # Moved import here
   |                              ^^^ F401
10 |
11 | from fastapi import HTTPException
   |
   = help: Remove unused import

backend-call-automation\app\services\call_service.py:39:24: ANN001 Missing type annotation for function argument `supabase_client`
   |
37 |     """
38 |
39 |     def __init__(self, supabase_client=None) -> None:
   |                        ^^^^^^^^^^^^^^^ ANN001
40 |         """
41 |         Inicializa el servicio de llamadas.
   |

backend-call-automation\app\services\call_service.py:65:13: TRY400 Use `logging.exception` instead of `logging.error`
   |
63 |             await self.elevenlabs_service.initiate_outbound_call(call_id)
64 |         except Exception as e:
65 |             logger.error(f"Error al iniciar llamada saliente {call_id}: {e!s}")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
66 |             raise HTTPException(status_code=500, detail=f"Error al iniciar llamada: {e!s}")
   |
   = help: Replace with `exception`

backend-call-automation\app\services\call_service.py:66:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
64 |         except Exception as e:
65 |             logger.error(f"Error al iniciar llamada saliente {call_id}: {e!s}")
66 |             raise HTTPException(status_code=500, detail=f"Error al iniciar llamada: {e!s}")
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
67 |
68 |     async def handle_call_response(
   |

backend-call-automation\app\services\call_service.py:108:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
107 |         except Exception as e:
108 |             logger.error(f"Error en streaming de llamada {call_id}: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
109 |             # Stream de audio de fallback
110 |             fallback_stream = self.fallback_service.get_audio_stream()
    |
    = help: Replace with `exception`

backend-call-automation\app\services\call_service.py:114:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
112 |             async for chunk in fallback_stream:
113 |                 yield chunk
114 |             raise StreamingError(f"Error en streaming: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
115 |
116 |     async def handle_call_end(self, call_id: str) -> None:
    |

backend-call-automation\app\services\call_service.py:114:19: TRY003 Avoid specifying long messages outside the exception class
    |
112 |             async for chunk in fallback_stream:
113 |                 yield chunk
114 |             raise StreamingError(f"Error en streaming: {e!s}")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
115 |
116 |     async def handle_call_end(self, call_id: str) -> None:
    |

backend-call-automation\app\services\call_service.py:131:65: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
129 |                 await (
130 |                     self.supabase.table("calls")
131 |                     .update({"status": "completed", "end_time": datetime.now().isoformat()})
    |                                                                 ^^^^^^^^^^^^^^ DTZ005
132 |                     .eq("id", call_id)
133 |                     .execute()
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\call_service.py:138:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
136 |             logger.info(f"Llamada {call_id} finalizada correctamente")
137 |         except Exception as e:
138 |             logger.error(f"Error al finalizar llamada {call_id}: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
139 |
140 |     async def start_call(self, call_id: str) -> None:
    |
    = help: Replace with `exception`

backend-call-automation\app\services\call_service.py:180:55: ARG002 Unused method argument: `audio_chunk`
    |
178 |             return getattr(settings, "ELEVENLABS_DEFAULT_VOICE", "default_voice")
179 |
180 |     async def handle_audio_stream(self, call_id: str, audio_chunk: bytes) -> bytes:
    |                                                       ^^^^^^^^^^^ ARG002
181 |         """
182 |         Maneja el streaming de audio y errores en tiempo real
    |

backend-call-automation\app\services\call_service.py:216:13: TRY300 Consider moving this statement to an `else` block
    |
214 |             )
215 |
216 |             return processed_audio
    |             ^^^^^^^^^^^^^^^^^^^^^^ TRY300
217 |
218 |         except StreamingError as e:
    |

backend-call-automation\app\services\call_service.py:222:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
220 |             return await self.fallback_service.get_audio_response()
221 |         except Exception as e:
222 |             logger.error(f"Error inesperado en streaming de audio para llamada {call_id}: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
223 |             return await self.fallback_service.get_audio_response()
    |
    = help: Replace with `exception`

backend-call-automation\app\services\call_service.py:243:38: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
241 |                         "error_type": type(error).__name__,
242 |                         "error_message": str(error),
243 |                         "timestamp": datetime.now().isoformat(),
    |                                      ^^^^^^^^^^^^^^ DTZ005
244 |                     }
245 |                 )
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\call_service.py:288:13: I001 [*] Import block is un-sorted or un-formatted
    |
286 |           """
287 |           try:
288 | /             import io
289 | |             import librosa
290 | |             import numpy as np
    | |______________________________^ I001
291 |
292 |               # Convertir bytes a array numpy usando librosa
    |
    = help: Organize imports

backend-call-automation\app\services\call_service.py:323:101: E501 Line too long (101 > 100)
    |
321 |     def check_stream_stability(self) -> float:
322 |         """
323 |         Verifica la estabilidad del stream de audio mediante análisis de jitter y pérdida de paquetes
    |                                                                                                     ^ E501
324 |
325 |         Returns:
    |

backend-call-automation\app\services\call_service.py:334:101: E501 Line too long (101 > 100)
    |
333 |         # Calculate stability score based on weights
334 |         stability_score = (0.4 * jitter_score) + (0.4 * packet_loss_score) + (0.2 * continuity_score)
    |                                                                                                     ^ E501
335 |
336 |         logger.debug(
    |

backend-call-automation\app\services\call_service.py:361:38: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
359 |                         "user_message": user_message,
360 |                         "ai_response": ai_response,
361 |                         "timestamp": datetime.now().isoformat(),
    |                                      ^^^^^^^^^^^^^^ DTZ005
362 |                     }
363 |                 )
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\call_service.py:383:19: TRY003 Avoid specifying long messages outside the exception class
    |
381 |         result = await self.supabase.table("calls").select("*").eq("id", call_id).execute()
382 |         if not result.data:
383 |             raise ValueError("Call not found")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
384 |
385 |         call_data = result.data[0]
    |

backend-call-automation\app\services\call_service.py:390:19: TRY003 Avoid specifying long messages outside the exception class
    |
388 |         # Validar que la llamada se puede reintentar
389 |         if call.status not in [CallStatus.FAILED.value, CallStatus.ERROR.value]:
390 |             raise ValueError(f"Cannot retry a call with status {call.status}")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
391 |
392 |         # Validar límite de reintentos
    |

backend-call-automation\app\services\call_service.py:394:19: TRY003 Avoid specifying long messages outside the exception class
    |
392 |         # Validar límite de reintentos
393 |         if call.retry_attempts >= call.max_retries:
394 |             raise ValueError("Maximum retry attempts reached")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
395 |
396 |         # Incrementar contador de reintentos
    |

backend-call-automation\app\services\call_service.py:427:16: RET504 Unnecessary assignment to `updated_call` before `return` statement
    |
425 |         updated_call = Call(**result.data[0])
426 |
427 |         return updated_call
    |                ^^^^^^^^^^^^ RET504
428 |
429 |     async def get_call_metrics(self, campaign_id: str | None = None) -> CallMetrics:
    |
    = help: Remove unnecessary assignment

backend-call-automation\app\services\call_service.py:487:9: F841 Local variable `audio` is assigned to but never used
    |
486 |         # Generar audio con ElevenLabs
487 |         audio = await self.elevenlabs_service.generate_audio(call_data.script_template)
    |         ^^^^^ F841
488 |
489 |         # Subir audio a un bucket público (opcional, dependiendo de tu configuración)
    |
    = help: Remove assignment to unused variable `audio`

backend-call-automation\app\services\call_service.py:490:9: ERA001 Found commented-out code
    |
489 |         # Subir audio a un bucket público (opcional, dependiendo de tu configuración)
490 |         # url_audio = await self.supabase.storage().from_("audios").upload(f"{call_data.id}.mp3", audio)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
491 |
492 |         # Preparar datos
    |
    = help: Remove commented-out code

backend-call-automation\app\services\call_service.py:490:101: E501 Line too long (104 > 100)
    |
489 |         # Subir audio a un bucket público (opcional, dependiendo de tu configuración)
490 |         # url_audio = await self.supabase.storage().from_("audios").upload(f"{call_data.id}.mp3", audio)
    |                                                                                                     ^^^^ E501
491 |
492 |         # Preparar datos
    |

backend-call-automation\app\services\call_service.py:496:27: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
494 |             "id": str(uuid.uuid4()),
495 |             "status": CallStatus.PENDING.value,
496 |             "created_at": datetime.now().isoformat(),
    |                           ^^^^^^^^^^^^^^ DTZ005
497 |             "updated_at": datetime.now().isoformat(),
498 |             "twilio_sid": call_data.twilio_sid,
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\call_service.py:497:27: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
495 |             "status": CallStatus.PENDING.value,
496 |             "created_at": datetime.now().isoformat(),
497 |             "updated_at": datetime.now().isoformat(),
    |                           ^^^^^^^^^^^^^^ DTZ005
498 |             "twilio_sid": call_data.twilio_sid,
499 |             # 'webhook_url': url_audio,  # Usar la URL del audio generado
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\call_service.py:499:13: ERA001 Found commented-out code
    |
497 |             "updated_at": datetime.now().isoformat(),
498 |             "twilio_sid": call_data.twilio_sid,
499 |             # 'webhook_url': url_audio,  # Usar la URL del audio generado
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
500 |             **call_data.model_dump(exclude={"twilio_sid", "script_template"}),
501 |         }
    |
    = help: Remove commented-out code

backend-call-automation\app\services\call_service.py:531:13: TRY300 Consider moving this statement to an `else` block
    |
529 |             if result.data and len(result.data) > 0:
530 |                 return Call(**result.data[0])
531 |             return None
    |             ^^^^^^^^^^^ TRY300
532 |         except Exception as e:
533 |             logger.error(f"Error al buscar llamada por SID de Twilio {twilio_sid}: {e!s}")
    |

backend-call-automation\app\services\call_service.py:533:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
531 |             return None
532 |         except Exception as e:
533 |             logger.error(f"Error al buscar llamada por SID de Twilio {twilio_sid}: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
534 |             return None
    |
    = help: Replace with `exception`

backend-call-automation\app\services\call_service.py:556:17: TRY301 Abstract `raise` to an inner function
    |
554 |               )
555 |               if not result.data or len(result.data) == 0:
556 | /                 raise HTTPException(
557 | |                     status_code=404, detail=f"Llamada con ID {call_id} no encontrada"
558 | |                 )
    | |_________________^ TRY301
559 |
560 |               contact_id = result.data[0]["contact_id"]
    |

backend-call-automation\app\services\call_service.py:565:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
563 |             return await self.contact_service.get_contact(contact_id)
564 |         except Exception as e:
565 |             logger.error(f"Error al obtener contacto para llamada {call_id}: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
566 |             raise HTTPException(status_code=500, detail=f"Error al obtener contacto: {e!s}")
    |
    = help: Replace with `exception`

backend-call-automation\app\services\call_service.py:566:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
564 |         except Exception as e:
565 |             logger.error(f"Error al obtener contacto para llamada {call_id}: {e!s}")
566 |             raise HTTPException(status_code=500, detail=f"Error al obtener contacto: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
567 |
568 |     async def update_call(self, call_id: str, update_data: dict) -> Call:
    |

backend-call-automation\app\services\call_service.py:585:41: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
583 |         try:
584 |             # Añadir timestamp de actualización
585 |             update_data["updated_at"] = datetime.now().isoformat()
    |                                         ^^^^^^^^^^^^^^ DTZ005
586 |
587 |             # Actualizar en la base de datos
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\call_service.py:592:17: TRY301 Abstract `raise` to an inner function
    |
590 |               )
591 |               if not result.data or len(result.data) == 0:
592 | /                 raise HTTPException(
593 | |                     status_code=404, detail=f"Llamada con ID {call_id} no encontrada"
594 | |                 )
    | |_________________^ TRY301
595 |
596 |               return Call(**result.data[0])
    |

backend-call-automation\app\services\call_service.py:598:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
596 |             return Call(**result.data[0])
597 |         except Exception as e:
598 |             logger.error(f"Error al actualizar llamada {call_id}: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
599 |             raise HTTPException(status_code=500, detail=f"Error al actualizar llamada: {e!s}")
    |
    = help: Replace with `exception`

backend-call-automation\app\services\call_service.py:599:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
597 |         except Exception as e:
598 |             logger.error(f"Error al actualizar llamada {call_id}: {e!s}")
599 |             raise HTTPException(status_code=500, detail=f"Error al actualizar llamada: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
600 |
601 |     async def update_call_notes(self, call_id: str, notes: str) -> Call:
    |

backend-call-automation\app\services\call_service.py:636:35: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
634 |                     "total_calls": total_calls,
635 |                     "completed_calls": completed_calls,
636 |                     "updated_at": datetime.now().isoformat(),
    |                                   ^^^^^^^^^^^^^^ DTZ005
637 |                 }
638 |             )
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\call_service.py:678:101: E501 Line too long (111 > 100)
    |
676 |         """
677 |         logger.debug(
678 |             f"Listando llamadas con campaign_id: {campaign_id}, status: {status}, skip: {skip}, limit: {limit}"
    |                                                                                                     ^^^^^^^^^^^ E501
679 |         )
680 |         query = self.supabase.table("calls").select("*")
    |

backend-call-automation\app\services\call_service.py:719:37: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
717 |         # Actualizar solo los campos proporcionados
718 |         update_data = call_data.model_dump(exclude_unset=True)
719 |         update_data["updated_at"] = datetime.now().isoformat()
    |                                     ^^^^^^^^^^^^^^ DTZ005
720 |
721 |         result = (
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\call_service.py:788:35: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
786 |                     "total_calls": total_calls,
787 |                     "completed_calls": completed_calls,
788 |                     "updated_at": datetime.now().isoformat(),
    |                                   ^^^^^^^^^^^^^^ DTZ005
789 |                 }
790 |             )
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\call_service.py:887:24: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
886 |         # Usar datetime.now() con timezone
887 |         current_time = datetime.now().replace(tzinfo=UTC).isoformat()
    |                        ^^^^^^^^^^^^^^ DTZ005
888 |
889 |         history.append(
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\campaign_scheduler.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import asyncio
 2 | | import logging
 3 | | from datetime import datetime, timedelta
 4 | |
 5 | | from app.models.call import CallCreate, CallStatus
 6 | | from app.models.campaign import Campaign, CampaignStatus
 7 | | from app.services.call_service import CallService
 8 | | from app.services.campaign_service import CampaignService
 9 | | from app.services.contact_service import ContactService
10 | |
11 | | from typing import Optional, Any
   | |________________________________^ I001
12 |
13 |   logging.basicConfig(level=logging.INFO)
   |
   = help: Organize imports

backend-call-automation\app\services\campaign_scheduler.py:11:20: F401 [*] `typing.Optional` imported but unused
   |
 9 | from app.services.contact_service import ContactService
10 |
11 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
12 |
13 | logging.basicConfig(level=logging.INFO)
   |
   = help: Remove unused import

backend-call-automation\app\services\campaign_scheduler.py:11:30: F401 [*] `typing.Any` imported but unused
   |
 9 | from app.services.contact_service import ContactService
10 |
11 | from typing import Optional, Any
   |                              ^^^ F401
12 |
13 | logging.basicConfig(level=logging.INFO)
   |
   = help: Remove unused import

backend-call-automation\app\services\campaign_scheduler.py:21:101: E501 Line too long (129 > 100)
   |
19 |     Planificador de campañas que gestiona y ejecuta campañas de llamadas automáticas.
20 |
21 |     Incluye la lógica para procesar campañas activas, reintentar llamadas fallidas y actualizar las estadísticas de las campañas.
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
22 |
23 |     Attributes:
   |

backend-call-automation\app\services\campaign_scheduler.py:36:9: PLR0913 Too many arguments in function definition (7 > 5)
   |
34 |     """
35 |
36 |     def __init__(
   |         ^^^^^^^^ PLR0913
37 |         self,
38 |         campaign_service: CampaignService,
   |

backend-call-automation\app\services\campaign_scheduler.py:82:19: TRY003 Avoid specifying long messages outside the exception class
   |
80 |         """
81 |         if self.is_running:
82 |             raise RuntimeError("El planificador ya está en ejecución")
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
83 |
84 |         self.is_running = True
   |

backend-call-automation\app\services\campaign_scheduler.py:101:13: SIM105 Use `contextlib.suppress(asyncio.CancelledError)` instead of `try`-`except`-`pass`
    |
 99 |           if self._task:
100 |               self._task.cancel()
101 | /             try:
102 | |                 await self._task
103 | |             except asyncio.CancelledError:
104 | |                 pass
    | |____________________^ SIM105
105 |           logger.info("Planificador de campañas detenido")
    |
    = help: Replace with `contextlib.suppress(asyncio.CancelledError)`

backend-call-automation\app\services\campaign_scheduler.py:122:17: TRY400 Use `logging.exception` instead of `logging.error`
    |
120 |                 await asyncio.sleep(self.check_interval)
121 |             except Exception as e:
122 |                 logger.error(f"Error en el planificador: {e!s}")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
123 |                 await asyncio.sleep(self.check_interval)
    |
    = help: Replace with `exception`

backend-call-automation\app\services\campaign_scheduler.py:142:19: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
140 |         try:
141 |             # Obtener campañas activas dentro del horario programado
142 |             now = datetime.now()
    |                   ^^^^^^^^^^^^^^ DTZ005
143 |             campaigns = await self.campaign_service.list_campaigns(
144 |                 status=CampaignStatus.ACTIVE, start_date=now, end_date=now
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\campaign_scheduler.py:151:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
150 |         except Exception as e:
151 |             logger.error(f"Error al procesar campañas activas: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
152 |
153 |     async def _process_campaign(self, campaign: Campaign) -> None:
    |
    = help: Replace with `exception`

backend-call-automation\app\services\campaign_scheduler.py:204:101: E501 Line too long (107 > 100)
    |
202 |                         campaign_id=campaign.id,
203 |                         phone_number=contact.phone_number,
204 |                         from_number="+15005550006",  # Número de Twilio (debería venir de la configuración)
    |                                                                                                     ^^^^^^^ E501
205 |                         webhook_url=f"https://api.example.com/webhook/{campaign.id}/{contact.id}",
206 |                         status_callback_url=f"https://api.example.com/callback/{campaign.id}/{contact.id}",
    |

backend-call-automation\app\services\campaign_scheduler.py:223:46: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
221 | …                     "campaign_id": campaign.id,
222 | …                     "contact_id": contact.id,
223 | …                     "called_at": datetime.now().isoformat(),
    |                                    ^^^^^^^^^^^^^^ DTZ005
224 | …                     "call_status": call.status.value,
225 | …                     "retry_count": call_data.retry_attempts + 1,
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\campaign_scheduler.py:232:21: TRY400 Use `logging.exception` instead of `logging.error`
    |
231 |                 except Exception as e:
232 |                     logger.error(f"Error al crear llamada para contacto {contact.id}: {e!s}")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
233 |                     continue
    |
    = help: Replace with `exception`

backend-call-automation\app\services\campaign_scheduler.py:236:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
235 |         except Exception as e:
236 |             logger.error(f"Error al procesar campaña {campaign.id}: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
237 |
238 |     async def _retry_failed_calls(self) -> None:
    |
    = help: Replace with `exception`

backend-call-automation\app\services\campaign_scheduler.py:254:19: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
252 |             failed_calls = await self.call_service.list_calls(status=CallStatus.FAILED)
253 |
254 |             now = datetime.now()
    |                   ^^^^^^^^^^^^^^ DTZ005
255 |             for call in failed_calls:
256 |                 # Verificar si se puede reintentar
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\campaign_scheduler.py:272:21: TRY400 Use `logging.exception` instead of `logging.error`
    |
270 |                     await self.call_service.retry_call(call.id)
271 |                 except Exception as e:
272 |                     logger.error(f"Error al reintentar llamada {call.id}: {e!s}")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
273 |
274 |         except Exception as e:
    |
    = help: Replace with `exception`

backend-call-automation\app\services\campaign_scheduler.py:275:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
274 |         except Exception as e:
275 |             logger.error(f"Error al procesar reintentos: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
276 |
277 |     async def update_campaign_stats(self, campaign_id: int) -> None:
    |
    = help: Replace with `exception`

backend-call-automation\app\services\campaign_scheduler.py:281:101: E501 Line too long (104 > 100)
    |
279 |         Actualiza las estadísticas de una campaña.
280 |
281 |         Obtiene las métricas de llamadas y actualiza las estadísticas de la campaña en la base de datos.
    |                                                                                                     ^^^^ E501
282 |
283 |         Args:
    |

backend-call-automation\app\services\campaign_scheduler.py:308:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
306 |             )
307 |         except Exception as e:
308 |             logger.error(f"Error al actualizar estadísticas de campaña {campaign_id}: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
    |
    = help: Replace with `exception`

backend-call-automation\app\services\campaign_service.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Servicio para la gestión de campañas de llamadas automatizadas."""
 2 |
 3 | / from datetime import datetime
 4 | | from uuid import UUID
 5 | |
 6 | | from fastapi import HTTPException, status
 7 | |
 8 | | from app.models.campaign import Campaign, CampaignCreate, CampaignStatus, CampaignUpdate
 9 | |
10 | |
11 | | from typing import Optional, Any
   | |________________________________^ I001
12 |
13 |   class CampaignService:
   |
   = help: Organize imports

backend-call-automation\app\services\campaign_service.py:11:20: F401 [*] `typing.Optional` imported but unused
   |
11 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
12 |
13 | class CampaignService:
   |
   = help: Remove unused import

backend-call-automation\app\services\campaign_service.py:11:30: F401 [*] `typing.Any` imported but unused
   |
11 | from typing import Optional, Any
   |                              ^^^ F401
12 |
13 | class CampaignService:
   |
   = help: Remove unused import

backend-call-automation\app\services\campaign_service.py:23:24: ANN001 Missing type annotation for function argument `supabase_client`
   |
21 |     """
22 |
23 |     def __init__(self, supabase_client) -> None:
   |                        ^^^^^^^^^^^^^^^ ANN001
24 |         """Inicializa el servicio de campañas.
   |

backend-call-automation\app\services\campaign_service.py:50:13: TRY301 Abstract `raise` to an inner function
   |
48 |               if result and result["data"]:
49 |                   return Campaign(**result["data"][0])
50 | /             raise HTTPException(
51 | |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
52 | |                 detail="Error al crear la campaña",
53 | |             )
   | |_____________^ TRY301
54 |           except Exception as e:
55 |               raise HTTPException(
   |

backend-call-automation\app\services\campaign_service.py:55:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
53 |               )
54 |           except Exception as e:
55 | /             raise HTTPException(
56 | |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
57 | |                 detail=f"Error al crear la campaña: {e!s}",
58 | |             )
   | |_____________^ B904
59 |
60 |       async def get_campaign(self, campaign_id: UUID) -> Campaign:
   |

backend-call-automation\app\services\campaign_service.py:81:13: TRY301 Abstract `raise` to an inner function
   |
79 |               if result and result["data"]:
80 |                   return Campaign(**result["data"][0])
81 | /             raise HTTPException(
82 | |                 status_code=status.HTTP_404_NOT_FOUND, detail="Campaña no encontrada"
83 | |             )
   | |_____________^ TRY301
84 |           except Exception as e:
85 |               if isinstance(e, HTTPException):
   |

backend-call-automation\app\services\campaign_service.py:87:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
85 |               if isinstance(e, HTTPException):
86 |                   raise
87 | /             raise HTTPException(
88 | |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
89 | |                 detail=f"Error al obtener la campaña: {e!s}",
90 | |             )
   | |_____________^ B904
91 |
92 |       async def list_campaigns(
   |

backend-call-automation\app\services\campaign_service.py:131:13: TRY300 Consider moving this statement to an `else` block
    |
129 |             if result and result["data"]:
130 |                 return [Campaign(**item) for item in result["data"]]
131 |             return []
    |             ^^^^^^^^^ TRY300
132 |         except Exception as e:
133 |             # Usar directamente el código de estado en lugar de acceder a través de CampaignStatus
    |

backend-call-automation\app\services\campaign_service.py:134:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
132 |           except Exception as e:
133 |               # Usar directamente el código de estado en lugar de acceder a través de CampaignStatus
134 | /             raise HTTPException(
135 | |                 status_code=500,  # HTTP_500_INTERNAL_SERVER_ERROR
136 | |                 detail=f"Error al listar las campañas: {e!s}",
137 | |             )
    | |_____________^ B904
138 |
139 |       async def update_campaign(self, campaign_id: UUID, campaign_update: CampaignUpdate) -> Campaign:
    |

backend-call-automation\app\services\campaign_service.py:157:27: C416 Unnecessary dict comprehension (rewrite using `dict()`)
    |
156 |             # Actualizamos solo los campos no nulos
157 |             update_data = {k: v for k, v in campaign_update.model_dump(exclude_unset=True).items()}
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ C416
158 |             result = (
159 |                 self.supabase.from_table(self.table_name)
    |
    = help: Rewrite using `dict()`

backend-call-automation\app\services\campaign_service.py:167:13: TRY301 Abstract `raise` to an inner function
    |
165 |               if result and result["data"]:
166 |                   return Campaign(**result["data"][0])
167 | /             raise HTTPException(
168 | |                 status_code=status.HTTP_404_NOT_FOUND, detail="Campaña no encontrada"
169 | |             )
    | |_____________^ TRY301
170 |           except Exception as e:
171 |               if isinstance(e, HTTPException):
    |

backend-call-automation\app\services\campaign_service.py:173:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
171 |               if isinstance(e, HTTPException):
172 |                   raise
173 | /             raise HTTPException(
174 | |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
175 | |                 detail=f"Error al actualizar la campaña: {e!s}",
176 | |             )
    | |_____________^ B904
177 |
178 |       async def delete_campaign(self, campaign_id: UUID) -> bool:
    |

backend-call-automation\app\services\campaign_service.py:200:13: SIM103 Return the condition `bool(result and result["data"])` directly
    |
198 |                   .execute()
199 |               )
200 | /             if result and result["data"]:
201 | |                 return True
202 | |             return False
    | |________________________^ SIM103
203 |           except Exception as e:
204 |               if isinstance(e, HTTPException):
    |
    = help: Replace with `return bool(result and result["data"])`

backend-call-automation\app\services\campaign_service.py:202:13: TRY300 Consider moving this statement to an `else` block
    |
200 |             if result and result["data"]:
201 |                 return True
202 |             return False
    |             ^^^^^^^^^^^^ TRY300
203 |         except Exception as e:
204 |             if isinstance(e, HTTPException):
    |

backend-call-automation\app\services\campaign_service.py:206:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
204 |               if isinstance(e, HTTPException):
205 |                   raise
206 | /             raise HTTPException(
207 | |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
208 | |                 detail=f"Error al eliminar la campaña: {e!s}",
209 | |             )
    | |_____________^ B904
210 |
211 |       async def update_campaign_stats(
    |

backend-call-automation\app\services\campaign_service.py:239:17: TRY301 Abstract `raise` to an inner function
    |
237 |                   x < 0 for x in [total_calls, successful_calls, failed_calls, pending_calls]
238 |               ):
239 | /                 raise HTTPException(
240 | |                     status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
241 | |                     detail="Estadísticas inválidas",
242 | |                 )
    | |_________________^ TRY301
243 |
244 |               stats = {
    |

backend-call-automation\app\services\campaign_service.py:259:13: TRY301 Abstract `raise` to an inner function
    |
257 |               if result and result["data"]:
258 |                   return Campaign(**result["data"][0])
259 | /             raise HTTPException(
260 | |                 status_code=status.HTTP_404_NOT_FOUND, detail="Campaña no encontrada"
261 | |             )
    | |_____________^ TRY301
262 |           except Exception as e:
263 |               if isinstance(e, HTTPException):
    |

backend-call-automation\app\services\campaign_service.py:265:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
263 |               if isinstance(e, HTTPException):
264 |                   raise
265 | /             raise HTTPException(
266 | |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
267 | |                 detail=f"Error al actualizar las estadísticas: {e!s}",
268 | |             )
    | |_____________^ B904
    |

backend-call-automation\app\services\contact_service.py:264:1: SyntaxError: Expected `except` or `finally` after `try` block
    |
262 |             # Procesar cada fila
263 |             contacts_to_import = []
264 | from typing import Any
    | ^
265 |
266 |             for row in csv_reader:
    |

backend-call-automation\app\services\contact_service.py:266:1: SyntaxError: Unexpected indentation
    |
264 | from typing import Any
265 |
266 |             for row in csv_reader:
    | ^
267 |                 stats["total"] += 1
    |

backend-call-automation\app\services\contact_service.py:300:1: SyntaxError: unindent does not match any outer indentation level
    |
298 |             return stats
299 |
300 |         except Exception as e:
    | ^
301 |             raise HTTPException(
302 |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
    |

backend-call-automation\app\services\contact_service.py:300:9: SyntaxError: Expected a statement
    |
298 |             return stats
299 |
300 |         except Exception as e:
    |         ^
301 |             raise HTTPException(
302 |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
    |

backend-call-automation\app\services\contact_service.py:300:26: SyntaxError: Expected a statement
    |
298 |             return stats
299 |
300 |         except Exception as e:
    |                          ^
301 |             raise HTTPException(
302 |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
    |

backend-call-automation\app\services\contact_service.py:300:31: SyntaxError: Expected an expression
    |
298 |             return stats
299 |
300 |         except Exception as e:
    |                               ^
301 |             raise HTTPException(
302 |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
    |

backend-call-automation\app\services\contact_service.py:301:1: SyntaxError: Unexpected indentation
    |
300 |         except Exception as e:
301 |             raise HTTPException(
    | ^
302 |                 status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
303 |                 detail=f"Error al importar contactos: {e!s}",
    |

backend-call-automation\app\services\contact_service.py:306:1: SyntaxError: unindent does not match any outer indentation level
    |
304 |             )
305 |
306 |     async def export_contacts_to_csv(self, list_id: str | None = None) -> str:
    | ^
307 |         """
308 |         Exporta contactos a formato CSV.
    |

backend-call-automation\app\services\contact_service.py:367:5: SyntaxError: unindent does not match any outer indentation level
    |
365 |             )
366 |
367 |     async def list_contact_lists(self) -> list[ContactList]:
    |     ^
368 |         """
369 |         Lista todas las listas de contactos.
    |

backend-call-automation\app\services\contact_service.py:383:5: SyntaxError: unindent does not match any outer indentation level
    |
381 |             )
382 |
383 |     async def get_contact_list(self, list_id: str) -> ContactList:
    |     ^
384 |         """
385 |         Obtiene una lista de contactos por su ID.
    |

backend-call-automation\app\services\contact_service.py:419:5: SyntaxError: unindent does not match any outer indentation level
    |
417 |             )
418 |
419 |     async def create_contact_list(self, list_data: ContactListCreate) -> ContactList:
    |     ^
420 |         """
421 |         Crea una nueva lista de contactos.
    |

backend-call-automation\app\services\contact_service.py:441:5: SyntaxError: unindent does not match any outer indentation level
    |
439 |             )
440 |
441 |     async def add_contacts_to_list(self, list_id: str, contact_ids: list[str]) -> int:
    |     ^
442 |         """
443 |         Agrega contactos a una lista existente.
    |

backend-call-automation\app\services\contact_service.py:484:5: SyntaxError: unindent does not match any outer indentation level
    |
482 |             )
483 |
484 |     async def remove_contact_from_list(self, list_id: str, contact_id: str) -> bool:
    |     ^
485 |         """
486 |         Elimina un contacto de una lista.
    |

backend-call-automation\app\services\contact_service.py:513:1: SyntaxError: Expected dedent, found end of file
    |
511 |                 detail=f"Error al eliminar el contacto de la lista: {e!s}",
512 |             )
    |              ^
    |

backend-call-automation\app\services\elevenlabs_service.py:6:25: F401 [*] `typing.Optional` imported but unused
  |
4 | import time
5 | from collections.abc import AsyncGenerator
6 | from typing import Any, Optional
  |                         ^^^^^^^^ F401
7 |
8 | from httpx import AsyncClient
  |
  = help: Remove unused import: `typing.Optional`

backend-call-automation\app\services\elevenlabs_service.py:67:101: E501 Line too long (103 > 100)
   |
65 |                 error=e,
66 |                 context={
67 |                     "message": "Failed to read ElevenLabs settings for ConnectionPool. Using defaults."
   |                                                                                                     ^^^ E501
68 |                 },
69 |             )
   |

backend-call-automation\app\services\elevenlabs_service.py:113:101: E501 Line too long (105 > 100)
    |
111 |             "twilio_auth_token": settings.TWILIO_AUTH_TOKEN,
112 |             "from_number": getattr(settings, "TWILIO_FROM_NUMBER", settings.TWILIO_PHONE_NUMBER),
113 |             "webhook_url": f"{getattr(settings, 'APP_BASE_URL', settings.APP_URL)}/api/v1/calls/webhook",
    |                                                                                                     ^^^^^ E501
114 |             "metadata": metadata or {},
115 |         }
    |

backend-call-automation\app\services\elevenlabs_service.py:134:17: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
    |
132 |                   )
133 |
134 | /                 async with self._pool.acquire() as session:
135 | |                     async with AsyncClient() as client:
    | |_______________________________________________________^ SIM117
136 |                           response = await client.post(url, json=payload, headers=headers)
    |
    = help: Combine `with` statements

backend-call-automation\app\services\elevenlabs_service.py:134:52: F841 Local variable `session` is assigned to but never used
    |
132 |                 )
133 |
134 |                 async with self._pool.acquire() as session:
    |                                                    ^^^^^^^ F841
135 |                     async with AsyncClient() as client:
136 |                         response = await client.post(url, json=payload, headers=headers)
    |
    = help: Remove assignment to unused variable `session`

backend-call-automation\app\services\elevenlabs_service.py:138:52: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
136 |                         response = await client.post(url, json=payload, headers=headers)
137 |
138 |                         if response.status_code != 200:
    |                                                    ^^^ PLR2004
139 |                             error_msg = response.json().get("error", "Unknown error")
140 |                             logger.log_error(
    |

backend-call-automation\app\services\elevenlabs_service.py:143:29: TRY301 Abstract `raise` to an inner function
    |
141 |                                 method=method_name, error=Exception(error_msg), context=params
142 |                             )
143 |                             raise ElevenLabsAPIError(f"Error initiating call: {error_msg}")
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
144 |
145 |                         result = response.json()
    |

backend-call-automation\app\services\elevenlabs_service.py:143:35: TRY003 Avoid specifying long messages outside the exception class
    |
141 |                                 method=method_name, error=Exception(error_msg), context=params
142 |                             )
143 |                             raise ElevenLabsAPIError(f"Error initiating call: {error_msg}")
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
144 |
145 |                         result = response.json()
    |

backend-call-automation\app\services\elevenlabs_service.py:168:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
166 |                 elevenlabs_requests_total.labels(method=method_name, status="error").inc()
167 |                 elevenlabs_errors_total.labels(error_type=error_type).inc()
168 |                 raise ElevenLabsAPIError(f"Failed to initiate call: {e!s}")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
169 |             finally:
170 |                 elevenlabs_pool_connections_active.dec()
    |

backend-call-automation\app\services\elevenlabs_service.py:168:23: TRY003 Avoid specifying long messages outside the exception class
    |
166 |                 elevenlabs_requests_total.labels(method=method_name, status="error").inc()
167 |                 elevenlabs_errors_total.labels(error_type=error_type).inc()
168 |                 raise ElevenLabsAPIError(f"Failed to initiate call: {e!s}")
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
169 |             finally:
170 |                 elevenlabs_pool_connections_active.dec()
    |

backend-call-automation\app\services\elevenlabs_service.py:177:15: PLR0915 Too many statements (60 > 50)
    |
176 |     @with_retry(max_attempts=3, base_wait=1.0)
177 |     async def generate_stream(
    |               ^^^^^^^^^^^^^^^ PLR0915
178 |         self, text: str, voice_id: str = "default_voice", language: str = "es"
179 |     ) -> AsyncGenerator[bytes, None]:
    |

backend-call-automation\app\services\elevenlabs_service.py:227:17: TRY300 Consider moving this statement to an `else` block
    |
225 |                     response_info={"from_cache": True, "file_path": cached_file_path},
226 |                 )
227 |                 return
    |                 ^^^^^^ TRY300
228 |             except Exception as e:
229 |                 # Si hay un error al leer el caché, continuar con la API
    |

backend-call-automation\app\services\elevenlabs_service.py:264:17: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
    |
262 |                   all_chunks = []
263 |
264 | /                 async with self._pool.acquire() as session:
265 | |                     async with AsyncClient() as client:
    | |_______________________________________________________^ SIM117
266 |                           async with client.stream(
267 |                               "POST", url, json=payload, headers=headers
    |
    = help: Combine `with` statements

backend-call-automation\app\services\elevenlabs_service.py:264:52: F841 Local variable `session` is assigned to but never used
    |
262 |                 all_chunks = []
263 |
264 |                 async with self._pool.acquire() as session:
    |                                                    ^^^^^^^ F841
265 |                     async with AsyncClient() as client:
266 |                         async with client.stream(
    |
    = help: Remove assignment to unused variable `session`

backend-call-automation\app\services\elevenlabs_service.py:269:56: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
267 |                             "POST", url, json=payload, headers=headers
268 |                         ) as response:
269 |                             if response.status_code != 200:
    |                                                        ^^^ PLR2004
270 |                                 error_msg = await response.json()
271 |                                 error_msg = error_msg.get("error", "Unknown error")
    |

backend-call-automation\app\services\elevenlabs_service.py:275:33: TRY301 Abstract `raise` to an inner function
    |
273 |                                       method=method_name, error=Exception(error_msg), context=params
274 |                                   )
275 | /                                 raise ElevenLabsAPIError(
276 | |                                     f"Error generating audio stream: {error_msg}"
277 | |                                 )
    | |_________________________________^ TRY301
278 |
279 |                               async for chunk in response.aiter_bytes():
    |

backend-call-automation\app\services\elevenlabs_service.py:275:39: TRY003 Avoid specifying long messages outside the exception class
    |
273 |                                       method=method_name, error=Exception(error_msg), context=params
274 |                                   )
275 |                                   raise ElevenLabsAPIError(
    |  _______________________________________^
276 | |                                     f"Error generating audio stream: {error_msg}"
277 | |                                 )
    | |_________________________________^ TRY003
278 |
279 |                               async for chunk in response.aiter_bytes():
    |

backend-call-automation\app\services\elevenlabs_service.py:296:29: RUF006 Store a reference to the return value of `asyncio.create_task`
    |
295 |                               # Guardar en caché de forma asíncrona
296 | /                             asyncio.create_task(
297 | |                                 audio_cache_service.save_to_cache(
298 | |                                     text, voice_id, audio_data, language
299 | |                                 )
300 | |                             )
    | |_____________________________^ RUF006
301 |
302 |                               logger.log_api_call(
    |

backend-call-automation\app\services\elevenlabs_service.py:329:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
327 |                 elevenlabs_requests_total.labels(method=method_name, status="error").inc()
328 |                 elevenlabs_errors_total.labels(error_type=error_type).inc()
329 |                 raise ElevenLabsAPIError(f"Failed to generate audio stream: {e!s}")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
330 |             finally:
331 |                 elevenlabs_pool_connections_active.dec()
    |

backend-call-automation\app\services\elevenlabs_service.py:329:23: TRY003 Avoid specifying long messages outside the exception class
    |
327 |                 elevenlabs_requests_total.labels(method=method_name, status="error").inc()
328 |                 elevenlabs_errors_total.labels(error_type=error_type).inc()
329 |                 raise ElevenLabsAPIError(f"Failed to generate audio stream: {e!s}")
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
330 |             finally:
331 |                 elevenlabs_pool_connections_active.dec()
    |

backend-call-automation\app\services\elevenlabs_service.py:370:44: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
368 |                 response = await client.post(url, json=payload, headers=headers)
369 |
370 |                 if response.status_code != 200:
    |                                            ^^^ PLR2004
371 |                     error_msg = response.json().get("error", "Unknown error")
372 |                     logger.log_error(
    |

backend-call-automation\app\services\elevenlabs_service.py:377:21: TRY301 Abstract `raise` to an inner function
    |
375 |                         context={"voice_id": voice_id},
376 |                     )
377 |                     raise ElevenLabsAPIError(f"Error starting conversation: {error_msg}")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
378 |
379 |                 result = response.json()
    |

backend-call-automation\app\services\elevenlabs_service.py:377:27: TRY003 Avoid specifying long messages outside the exception class
    |
375 |                         context={"voice_id": voice_id},
376 |                     )
377 |                     raise ElevenLabsAPIError(f"Error starting conversation: {error_msg}")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
378 |
379 |                 result = response.json()
    |

backend-call-automation\app\services\elevenlabs_service.py:400:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
398 |                 method=method_name, params={"voice_id": voice_id}, duration=duration, success=False
399 |             )
400 |             raise ElevenLabsAPIError(f"Failed to start conversation: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
401 |
402 |     async def generate_audio(self, text: str, voice_id: str = "default_voice") -> bytes:
    |

backend-call-automation\app\services\elevenlabs_service.py:400:19: TRY003 Avoid specifying long messages outside the exception class
    |
398 |                 method=method_name, params={"voice_id": voice_id}, duration=duration, success=False
399 |             )
400 |             raise ElevenLabsAPIError(f"Failed to start conversation: {e!s}")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
401 |
402 |     async def generate_audio(self, text: str, voice_id: str = "default_voice") -> bytes:
    |

backend-call-automation\app\services\elevenlabs_service.py:442:17: TRY300 Consider moving this statement to an `else` block
    |
440 |                     response_info={"from_cache": True, "file_path": cached_file_path},
441 |                 )
442 |                 return audio_data
    |                 ^^^^^^^^^^^^^^^^^ TRY300
443 |             except Exception as e:
444 |                 # Si hay un error al leer el caché, continuar con la API
    |

backend-call-automation\app\services\elevenlabs_service.py:476:17: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
    |
474 |                   )
475 |
476 | /                 async with self._pool.acquire() as session:
477 | |                     async with AsyncClient() as client:
    | |_______________________________________________________^ SIM117
478 |                           response = await client.post(url, json=payload, headers=headers)
    |
    = help: Combine `with` statements

backend-call-automation\app\services\elevenlabs_service.py:476:52: F841 Local variable `session` is assigned to but never used
    |
474 |                 )
475 |
476 |                 async with self._pool.acquire() as session:
    |                                                    ^^^^^^^ F841
477 |                     async with AsyncClient() as client:
478 |                         response = await client.post(url, json=payload, headers=headers)
    |
    = help: Remove assignment to unused variable `session`

backend-call-automation\app\services\elevenlabs_service.py:480:52: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
478 |                         response = await client.post(url, json=payload, headers=headers)
479 |
480 |                         if response.status_code != 200:
    |                                                    ^^^ PLR2004
481 |                             error_msg = response.json().get("error", "Unknown error")
482 |                             logger.log_error(
    |

backend-call-automation\app\services\elevenlabs_service.py:485:29: TRY301 Abstract `raise` to an inner function
    |
483 |                                 method=method_name, error=Exception(error_msg), context=params
484 |                             )
485 |                             raise ElevenLabsAPIError(f"Error generating audio: {error_msg}")
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
486 |
487 |                         # Leer el contenido de la respuesta
    |

backend-call-automation\app\services\elevenlabs_service.py:485:35: TRY003 Avoid specifying long messages outside the exception class
    |
483 |                                 method=method_name, error=Exception(error_msg), context=params
484 |                             )
485 |                             raise ElevenLabsAPIError(f"Error generating audio: {error_msg}")
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
486 |
487 |                         # Leer el contenido de la respuesta
    |

backend-call-automation\app\services\elevenlabs_service.py:494:25: RUF006 Store a reference to the return value of `asyncio.create_task`
    |
493 |                           # Guardar en caché de forma asíncrona
494 | /                         asyncio.create_task(
495 | |                             audio_cache_service.save_to_cache(text, voice_id, audio_data)
496 | |                         )
    | |_________________________^ RUF006
497 |
498 |                           duration = time.time() - start_time
    |

backend-call-automation\app\services\elevenlabs_service.py:519:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
517 |                 elevenlabs_requests_total.labels(method=method_name, status="error").inc()
518 |                 elevenlabs_errors_total.labels(error_type=error_type).inc()
519 |                 raise ElevenLabsAPIError(f"Failed to generate audio: {e!s}")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
520 |             finally:
521 |                 elevenlabs_pool_connections_active.dec()
    |

backend-call-automation\app\services\elevenlabs_service.py:519:23: TRY003 Avoid specifying long messages outside the exception class
    |
517 |                 elevenlabs_requests_total.labels(method=method_name, status="error").inc()
518 |                 elevenlabs_errors_total.labels(error_type=error_type).inc()
519 |                 raise ElevenLabsAPIError(f"Failed to generate audio: {e!s}")
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
520 |             finally:
521 |                 elevenlabs_pool_connections_active.dec()
    |

backend-call-automation\app\services\elevenlabs_service.py:552:44: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
550 |                 response = await client.post(url, headers=headers)
551 |
552 |                 if response.status_code != 200:
    |                                            ^^^ PLR2004
553 |                     error_msg = response.json().get("error", "Unknown error")
554 |                     logger.log_error(
    |

backend-call-automation\app\services\elevenlabs_service.py:559:21: TRY301 Abstract `raise` to an inner function
    |
557 |                         context={"conversation_id": self.conversation},
558 |                     )
559 |                     raise ElevenLabsAPIError(f"Error closing conversation: {error_msg}")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY301
560 |
561 |                 duration = time.time() - start_time
    |

backend-call-automation\app\services\elevenlabs_service.py:559:27: TRY003 Avoid specifying long messages outside the exception class
    |
557 |                         context={"conversation_id": self.conversation},
558 |                     )
559 |                     raise ElevenLabsAPIError(f"Error closing conversation: {error_msg}")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
560 |
561 |                 duration = time.time() - start_time
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:10:25: F401 [*] `typing.Optional` imported but unused
   |
 8 | import json
 9 | import logging
10 | from typing import Any, Optional
   |                         ^^^^^^^^ F401
11 |
12 | from fastapi import HTTPException
   |
   = help: Remove unused import: `typing.Optional`

backend-call-automation\app\services\enhanced_ai_conversation_service.py:39:34: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_initialize_llm`
   |
37 |         self.prompt_templates = self._load_prompt_templates()
38 |
39 |     def _initialize_llm(self) -> Any:
   |                                  ^^^ ANN401
40 |         """
41 |         Inicializa el modelo de lenguaje según la configuración.
   |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:61:15: TRY003 Avoid specifying long messages outside the exception class
   |
59 |                 convert_system_message_to_human=True,
60 |             )
61 |         raise ValueError(f"Proveedor de LLM no soportado: {self.settings.LLM_PROVIDER}")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
62 |
63 |     def _load_prompt_templates(self) -> dict[str, PromptTemplate]:
   |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:145:17: TRY300 Consider moving this statement to an `else` block
    |
143 |                       )
144 |
145 | /                 return {
146 | |                     "response": response,
147 | |                     "input_sentiment": input_sentiment,
148 | |                     "response_sentiment": response_sentiment,
149 | |                     "suggested_actions": suggested_actions,
150 | |                     "conversation_id": conversation_id,
151 | |                     "campaign_type": campaign_type,
152 | |                 }
    | |_________________^ TRY300
153 |
154 |               except Exception as e:
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:155:17: TRY400 Use `logging.exception` instead of `logging.error`
    |
154 |             except Exception as e:
155 |                 logger.error(f"Error al procesar mensaje: {e!s}")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
156 |                 raise HTTPException(status_code=500, detail=f"Error al procesar mensaje: {e!s}")
    |
    = help: Replace with `exception`

backend-call-automation\app\services\enhanced_ai_conversation_service.py:156:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
154 |             except Exception as e:
155 |                 logger.error(f"Error al procesar mensaje: {e!s}")
156 |                 raise HTTPException(status_code=500, detail=f"Error al procesar mensaje: {e!s}")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
157 |
158 |     async def _get_conversation_history(self, conversation_id: str | None) -> str:
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:176:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
174 |             return ""
175 |         except Exception as e:
176 |             logger.error(f"Error al recuperar historial de conversación: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
177 |             return ""
    |
    = help: Replace with `exception`

backend-call-automation\app\services\enhanced_ai_conversation_service.py:207:101: E501 Line too long (101 > 100)
    |
205 |                 variables[var] = self.settings.DEFAULT_VALUES[var]
206 |             elif var not in variables:
207 |                 # Si es una variable requerida y no está en el contexto ni en los valores por defecto
    |                                                                                                     ^ E501
208 |                 logger.warning(
209 |                     f"Variable requerida '{var}' no proporcionada para prompt de tipo '{campaign_type}'"
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:209:101: E501 Line too long (104 > 100)
    |
207 |                 # Si es una variable requerida y no está en el contexto ni en los valores por defecto
208 |                 logger.warning(
209 |                     f"Variable requerida '{var}' no proporcionada para prompt de tipo '{campaign_type}'"
    |                                                                                                     ^^^^ E501
210 |                 )
211 |                 variables[var] = f"[{var} no proporcionado]"
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:233:13: TRY300 Consider moving this statement to an `else` block
    |
231 |             response = await self.llm.ainvoke(prompt)
232 |
233 |             return response
    |             ^^^^^^^^^^^^^^^ TRY300
234 |         except Exception as e:
235 |             logger.error(f"Error al generar respuesta: {e!s}")
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:233:20: RET504 Unnecessary assignment to `response` before `return` statement
    |
231 |             response = await self.llm.ainvoke(prompt)
232 |
233 |             return response
    |                    ^^^^^^^^ RET504
234 |         except Exception as e:
235 |             logger.error(f"Error al generar respuesta: {e!s}")
    |
    = help: Remove unnecessary assignment

backend-call-automation\app\services\enhanced_ai_conversation_service.py:235:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
233 |             return response
234 |         except Exception as e:
235 |             logger.error(f"Error al generar respuesta: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
236 |             return "Lo siento, no pude generar una respuesta en este momento. Por favor, inténtelo de nuevo más tarde."
    |
    = help: Replace with `exception`

backend-call-automation\app\services\enhanced_ai_conversation_service.py:236:101: E501 Line too long (119 > 100)
    |
234 |         except Exception as e:
235 |             logger.error(f"Error al generar respuesta: {e!s}")
236 |             return "Lo siento, no pude generar una respuesta en este momento. Por favor, inténtelo de nuevo más tarde."
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^ E501
237 |
238 |     async def _update_conversation_history(
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:239:44: ARG002 Unused method argument: `message`
    |
238 |     async def _update_conversation_history(
239 |         self, conversation_id: str | None, message: str, response: str
    |                                            ^^^^^^^ ARG002
240 |     ) -> None:
241 |         """
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:239:58: ARG002 Unused method argument: `response`
    |
238 |     async def _update_conversation_history(
239 |         self, conversation_id: str | None, message: str, response: str
    |                                                          ^^^^^^^^ ARG002
240 |     ) -> None:
241 |         """
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:256:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
254 |             pass
255 |         except Exception as e:
256 |             logger.error(f"Error al actualizar historial de conversación: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
257 |
258 |     async def analyze_sentiment(self, text: str) -> dict[str, Any]:
    |
    = help: Replace with `exception`

backend-call-automation\app\services\enhanced_ai_conversation_service.py:274:101: E501 Line too long (130 > 100)
    |
272 |             template="""Analiza el sentimiento del siguiente texto y clasifícalo.
273 |             Texto: {text}
274 |             Devuelve un objeto JSON con la emoción primaria (primary_emotion) y su puntuación (score). \n{format_instructions}""",
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
275 |         )
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:281:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
279 |             return json.loads(response)
280 |         except Exception as e:
281 |             logger.error(f"Error al analizar el sentimiento: {e}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
282 |             return {"primary_emotion": "neutral", "score": 0.5}
    |
    = help: Replace with `exception`

backend-call-automation\app\services\enhanced_ai_conversation_service.py:322:101: E501 Line too long (121 > 100)
    |
320 |                 [
321 |                     {{
322 |                         "action_type": "continue_conversation/offer_callback/escalate/end_conversation/send_information",
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^ E501
323 |                         "priority": "high/medium/low",
324 |                         "description": "descripción de la acción",
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:343:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
341 |             return json.loads(response)
342 |         except Exception as e:
343 |             logger.error(f"Error al sugerir acciones: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
344 |             return [
345 |                 {
    |
    = help: Replace with `exception`

backend-call-automation\app\services\enhanced_ai_conversation_service.py:353:15: PLR0913 Too many arguments in function definition (6 > 5)
    |
351 |             ]
352 |
353 |     async def _save_conversation_metrics(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0913
354 |         self,
355 |         conversation_id: str,
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:355:9: ARG002 Unused method argument: `conversation_id`
    |
353 |     async def _save_conversation_metrics(
354 |         self,
355 |         conversation_id: str,
    |         ^^^^^^^^^^^^^^^ ARG002
356 |         message: str,
357 |         response: str,
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:356:9: ARG002 Unused method argument: `message`
    |
354 |         self,
355 |         conversation_id: str,
356 |         message: str,
    |         ^^^^^^^ ARG002
357 |         response: str,
358 |         input_sentiment: dict[str, Any],
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:357:9: ARG002 Unused method argument: `response`
    |
355 |         conversation_id: str,
356 |         message: str,
357 |         response: str,
    |         ^^^^^^^^ ARG002
358 |         input_sentiment: dict[str, Any],
359 |         response_sentiment: dict[str, Any],
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:358:9: ARG002 Unused method argument: `input_sentiment`
    |
356 |         message: str,
357 |         response: str,
358 |         input_sentiment: dict[str, Any],
    |         ^^^^^^^^^^^^^^^ ARG002
359 |         response_sentiment: dict[str, Any],
360 |         campaign_type: str,
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:359:9: ARG002 Unused method argument: `response_sentiment`
    |
357 |         response: str,
358 |         input_sentiment: dict[str, Any],
359 |         response_sentiment: dict[str, Any],
    |         ^^^^^^^^^^^^^^^^^^ ARG002
360 |         campaign_type: str,
361 |     ) -> None:
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:360:9: ARG002 Unused method argument: `campaign_type`
    |
358 |         input_sentiment: dict[str, Any],
359 |         response_sentiment: dict[str, Any],
360 |         campaign_type: str,
    |         ^^^^^^^^^^^^^ ARG002
361 |     ) -> None:
362 |         """
    |

backend-call-automation\app\services\enhanced_ai_conversation_service.py:377:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
375 |             pass
376 |         except Exception as e:
377 |             logger.error(f"Error al guardar métricas de conversación: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
    |
    = help: Replace with `exception`

backend-call-automation\app\services\fallback_service.py:1:101: E501 Line too long (122 > 100)
  |
1 | """Servicio de respaldo (fallback) para manejar errores y proporcionar alternativas cuando el servicio principal falla."""
  |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^ E501
2 |
3 | import asyncio
  |

backend-call-automation\app\services\fallback_service.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Servicio de respaldo (fallback) para manejar errores y proporcionar alternativas cuando el servicio principal falla."""
 2 |
 3 | / import asyncio
 4 | | import logging
 5 | | import os
 6 | | from collections.abc import AsyncGenerator
 7 | | from datetime import datetime, timedelta
 8 | |
 9 | | from elevenlabs.client import ElevenLabs  # Importar la clase correcta
10 | | from prometheus_client import Counter, Gauge, Histogram
11 | |
12 | | from typing import Optional, Any
   | |________________________________^ I001
13 |
14 |   logger = logging.getLogger(__name__)
   |
   = help: Organize imports

backend-call-automation\app\services\fallback_service.py:12:20: F401 [*] `typing.Optional` imported but unused
   |
10 | from prometheus_client import Counter, Gauge, Histogram
11 |
12 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
13 |
14 | logger = logging.getLogger(__name__)
   |
   = help: Remove unused import

backend-call-automation\app\services\fallback_service.py:12:30: F401 [*] `typing.Any` imported but unused
   |
10 | from prometheus_client import Counter, Gauge, Histogram
11 |
12 | from typing import Optional, Any
   |                              ^^^ F401
13 |
14 | logger = logging.getLogger(__name__)
   |
   = help: Remove unused import

backend-call-automation\app\services\fallback_service.py:35:101: E501 Line too long (142 > 100)
   |
33 | …
34 | …
35 | …icultades técnicas. ¿Podría contactar con uno de nuestros representantes de ventas?",
   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
36 | …ntinuar con su soporte, le conectaré con un agente humano.",
37 | …dríamos reagendar esta encuesta para otro momento?",
   |

backend-call-automation\app\services\fallback_service.py:36:101: E501 Line too long (117 > 100)
   |
34 | …     self.fallback_responses = {
35 | …         "sales": "Lo siento, estoy experimentando dificultades técnicas. ¿Podría contactar con uno de nuestros representantes de ven…
36 | …         "support": "Disculpe la interrupción. Para continuar con su soporte, le conectaré con un agente humano.",
   |                                                                                                   ^^^^^^^^^^^^^^^^^ E501
37 | …         "survey": "Perdón por los inconvenientes. ¿Podríamos reagendar esta encuesta para otro momento?",
38 | …     }
   |

backend-call-automation\app\services\fallback_service.py:37:101: E501 Line too long (109 > 100)
   |
35 | …         "sales": "Lo siento, estoy experimentando dificultades técnicas. ¿Podría contactar con uno de nuestros representantes de ven…
36 | …         "support": "Disculpe la interrupción. Para continuar con su soporte, le conectaré con un agente humano.",
37 | …         "survey": "Perdón por los inconvenientes. ¿Podríamos reagendar esta encuesta para otro momento?",
   |                                                                                                   ^^^^^^^^^ E501
38 | …     }
39 | …     self.default_fallback = (
   |

backend-call-automation\app\services\fallback_service.py:68:34: DTZ005 `datetime.datetime.now()` called without a `tz` argument
   |
66 |         """
67 |         self.consecutive_failures += 1
68 |         self.last_failure_time = datetime.now()
   |                                  ^^^^^^^^^^^^^^ DTZ005
69 |
70 |         # Registrar métricas para monitoreo
   |
   = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\fallback_service.py:83:101: E501 Line too long (101 > 100)
   |
81 |         ):
82 |             logger.warning(
83 |                 f"Circuit Breaker abierto después de {self.consecutive_failures} fallos consecutivos"
   |                                                                                                     ^ E501
84 |             )
85 |             self.circuit_breaker_state = "OPEN"
   |

backend-call-automation\app\services\fallback_service.py:100:26: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
 98 |         # En un entorno real, esto registraría en una base de datos o sistema de monitoreo
 99 |         error_info = {
100 |             "timestamp": datetime.now().isoformat(),
    |                          ^^^^^^^^^^^^^^ DTZ005
101 |             "error_type": type(error).__name__,
102 |             "error_message": str(error),
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\fallback_service.py:123:40: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
122 |         # Si el circuito está abierto, verificar si ha pasado el tiempo de espera
123 |         if self.last_failure_time and (datetime.now() - self.last_failure_time) > timedelta(
    |                                        ^^^^^^^^^^^^^^ DTZ005
124 |             seconds=self.retry_timeout
125 |         ):
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\fallback_service.py:154:63: ARG002 Unused method argument: `context`
    |
152 |             self.circuit_breaker_state_gauge.set(0)
153 |
154 |     async def get_fallback_response(self, campaign_type: str, context: dict[str, str]) -> str:
    |                                                               ^^^^^^^ ARG002
155 |         """
156 |         Obtiene una respuesta de fallback apropiada según el tipo de campaña
    |

backend-call-automation\app\services\fallback_service.py:198:13: TRY300 Consider moving this statement to an `else` block
    |
196 |             await self.record_success()
197 |
198 |             return audio
    |             ^^^^^^^^^^^^ TRY300
199 |
200 |         except Exception as e:
    |

backend-call-automation\app\services\fallback_service.py:211:101: E501 Line too long (106 > 100)
    |
209 |         Proporciona un generador asíncrono de chunks de audio para streaming en caso de fallback.
210 |
211 |         Este método es útil para mantener la continuidad del streaming cuando el servicio principal falla.
    |                                                                                                     ^^^^^^ E501
212 |
213 |         Returns:
    |

backend-call-automation\app\services\fallback_service.py:237:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
236 |         except Exception as e:
237 |             logger.error(f"Error en streaming de audio de fallback: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
238 |             # En caso de error, devolver un chunk vacío
239 |             yield b""
    |
    = help: Replace with `exception`

backend-call-automation\app\services\fallback_service.py:256:13: TRY300 Consider moving this statement to an `else` block
    |
254 |         try:
255 |             audio = self.client.generate(text=self.default_fallback, voice=self.default_voice)
256 |             return audio
    |             ^^^^^^^^^^^^ TRY300
257 |         except Exception as e:
258 |             logger.error(f"Error al generar audio de fallback: {e!s}")
    |

backend-call-automation\app\services\fallback_service.py:256:20: RET504 Unnecessary assignment to `audio` before `return` statement
    |
254 |         try:
255 |             audio = self.client.generate(text=self.default_fallback, voice=self.default_voice)
256 |             return audio
    |                    ^^^^^ RET504
257 |         except Exception as e:
258 |             logger.error(f"Error al generar audio de fallback: {e!s}")
    |
    = help: Remove unnecessary assignment

backend-call-automation\app\services\fallback_service.py:258:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
256 |             return audio
257 |         except Exception as e:
258 |             logger.error(f"Error al generar audio de fallback: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
259 |             # Devolver un archivo de audio vacío como último recurso
260 |             return b""
    |
    = help: Replace with `exception`

backend-call-automation\app\services\metrics_service.py:4:25: F401 [*] `typing.Optional` imported but unused
  |
2 | import time
3 | from datetime import datetime
4 | from typing import Any, Optional
  |                         ^^^^^^^^ F401
5 |
6 | from prometheus_client import Counter, Gauge, Histogram, Summary
  |
  = help: Remove unused import: `typing.Optional`

backend-call-automation\app\services\metrics_service.py:110:38: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
108 |                     {
109 |                         "conversation_id": conversation_id,
110 |                         "timestamp": datetime.now().isoformat(),
    |                                      ^^^^^^^^^^^^^^ DTZ005
111 |                         "input_sentiment": metrics["input_sentiment"],
112 |                         "response_sentiment": metrics["response_sentiment"],
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\app\services\metrics_service.py:128:13: TRY400 Use `logging.exception` instead of `logging.error`
    |
126 |             )
127 |         except Exception as e:
128 |             logger.error(f"Error registrando métricas: {e!s}")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
    |
    = help: Replace with `exception`

backend-call-automation\app\services\monitoring_service.py:5:25: F401 [*] `typing.Optional` imported but unused
  |
3 | import logging
4 | import time
5 | from typing import Any, Optional
  |                         ^^^^^^^^ F401
6 |
7 | from prometheus_client import Counter, Gauge, Histogram, Summary
  |
  = help: Remove unused import: `typing.Optional`

backend-call-automation\app\services\monitoring_service.py:65:38: F821 Undefined name `CounterWrapper`
   |
63 |         logger.debug(f"Prometheus gauge: {name}={value} {labels}")
64 |
65 |     def counter(self, name: str) -> "CounterWrapper":
   |                                      ^^^^^^^^^^^^^^ F821
66 |         """Devuelve un contador que puede incrementarse.
   |

backend-call-automation\app\services\monitoring_service.py:100:41: F821 Undefined name `Span`
    |
 98 |         pass
 99 |
100 |     def start_span(self, name: str) -> "Span":
    |                                         ^^^^ F821
101 |         """Inicia un span de trazabilidad.
    |

backend-call-automation\app\services\monitoring_service.py:116:32: ANN001 Missing type annotation for function argument `exc_type`
    |
114 |                 return self
115 |
116 |             def __exit__(self, exc_type, exc_val, exc_tb) -> None:
    |                                ^^^^^^^^ ANN001
117 |                 """Método para finalizar el span al salir del contexto."""
118 |                 logger.info(f"OpenTelemetry: Ending span {name}")
    |

backend-call-automation\app\services\monitoring_service.py:116:42: ANN001 Missing type annotation for function argument `exc_val`
    |
114 |                 return self
115 |
116 |             def __exit__(self, exc_type, exc_val, exc_tb) -> None:
    |                                          ^^^^^^^ ANN001
117 |                 """Método para finalizar el span al salir del contexto."""
118 |                 logger.info(f"OpenTelemetry: Ending span {name}")
    |

backend-call-automation\app\services\monitoring_service.py:116:51: ANN001 Missing type annotation for function argument `exc_tb`
    |
114 |                 return self
115 |
116 |             def __exit__(self, exc_type, exc_val, exc_tb) -> None:
    |                                                   ^^^^^^ ANN001
117 |                 """Método para finalizar el span al salir del contexto."""
118 |                 logger.info(f"OpenTelemetry: Ending span {name}")
    |

backend-call-automation\app\services\monitoring_service.py:120:54: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
    |
118 |                 logger.info(f"OpenTelemetry: Ending span {name}")
119 |
120 |             def set_attribute(self, key: str, value: Any) -> None:
    |                                                      ^^^ ANN401
121 |                 """Establece un atributo en el span.
    |

backend-call-automation\app\services\monitoring_service.py:172:101: E501 Line too long (111 > 100)
    |
170 |         Args:
171 |             call_id (str): Identificador único de la llamada
172 |             context (dict[str, Any]): Contexto adicional para la traza, como sentimiento del usuario y duración
    |                                                                                                     ^^^^^^^^^^^ E501
173 |         """
174 |         with self.tracing_client.start_span(f"call_{call_id}") as span:
    |

backend-call-automation\app\services\twilio_service.py:6:25: F401 [*] `typing.Optional` imported but unused
  |
5 | import logging
6 | from typing import Any, Optional
  |                         ^^^^^^^^ F401
7 |
8 | from twilio.base.exceptions import TwilioRestException
  |
  = help: Remove unused import: `typing.Optional`

backend-call-automation\app\services\twilio_service.py:60:17: TRY301 Abstract `raise` to an inner function
   |
58 |           try:
59 |               if not self.client:
60 | /                 raise ValueError(
61 | |                     "Twilio client not initialized. Check TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN environment variables."
62 | |                 )
   | |_________________^ TRY301
63 |
64 |               logger.debug(f"Realizando llamada a {to} desde {from_}")
   |

backend-call-automation\app\services\twilio_service.py:60:23: TRY003 Avoid specifying long messages outside the exception class
   |
58 |           try:
59 |               if not self.client:
60 |                   raise ValueError(
   |  _______________________^
61 | |                     "Twilio client not initialized. Check TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN environment variables."
62 | |                 )
   | |_________________^ TRY003
63 |
64 |               logger.debug(f"Realizando llamada a {to} desde {from_}")
   |

backend-call-automation\app\services\twilio_service.py:61:101: E501 Line too long (122 > 100)
   |
59 |             if not self.client:
60 |                 raise ValueError(
61 |                     "Twilio client not initialized. Check TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN environment variables."
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^ E501
62 |                 )
   |

backend-call-automation\app\services\twilio_service.py:70:13: TRY300 Consider moving this statement to an `else` block
   |
69 |               logger.debug(f"Llamada creada con SID: {call.sid}")
70 | /             return {
71 | |                 "sid": call.sid,
72 | |                 "status": call.status,
73 | |                 "direction": call.direction,
74 | |                 "from": call.from_,
75 | |                 "to": call.to,
76 | |                 "duration": call.duration,
77 | |             }
   | |_____________^ TRY300
78 |
79 |           except TwilioRestException as e:
   |

backend-call-automation\app\services\twilio_service.py:80:73: TRY401 Redundant exception object included in `logging.exception` call
   |
79 |         except TwilioRestException as e:
80 |             logger.exception(f"Error de Twilio al realizar la llamada: {e!s}")
   |                                                                         ^ TRY401
81 |             raise Exception(f"Twilio error: {e!s}") from e
   |

backend-call-automation\app\services\twilio_service.py:81:19: TRY002 Create your own exception
   |
79 |         except TwilioRestException as e:
80 |             logger.exception(f"Error de Twilio al realizar la llamada: {e!s}")
81 |             raise Exception(f"Twilio error: {e!s}") from e
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY002
82 |
83 |         except Exception as e:
   |

backend-call-automation\app\services\twilio_service.py:81:19: TRY003 Avoid specifying long messages outside the exception class
   |
79 |         except TwilioRestException as e:
80 |             logger.exception(f"Error de Twilio al realizar la llamada: {e!s}")
81 |             raise Exception(f"Twilio error: {e!s}") from e
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
82 |
83 |         except Exception as e:
   |

backend-call-automation\app\services\twilio_service.py:84:63: TRY401 Redundant exception object included in `logging.exception` call
   |
83 |         except Exception as e:
84 |             logger.exception(f"Error al realizar la llamada: {e!s}")
   |                                                               ^ TRY401
85 |             raise
   |

backend-call-automation\app\utils\__init__.py:1:20: F401 `typing.Any` imported but unused
  |
1 | from typing import Any
  |                    ^^^ F401
2 |
3 | """
  |
  = help: Remove unused import: `typing.Any`

backend-call-automation\app\utils\connection_pool.py:20:32: ANN401 Dynamically typed expressions (typing.Any) are disallowed in `acquire`
   |
19 |     @asynccontextmanager
20 |     async def acquire(self) -> Any:
   |                                ^^^ ANN401
21 |         """
22 |         Adquiere una conexión del pool.
   |

backend-call-automation\app\utils\connection_pool.py:31:101: E501 Line too long (105 > 100)
   |
29 |                 # In a real scenario, you might get an existing idle connection
30 |                 # or create a new one if the pool is not full.
31 |                 # For simplicity here, we just yield self, assuming the pool manages sessions implicitly.
   |                                                                                                     ^^^^^ E501
32 |                 yield self
33 |             finally:
   |

backend-call-automation\app\utils\decorators.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import functools
2 | | import logging
3 | | from collections.abc import Awaitable, Callable
4 | | from typing import TypeVar, cast, Any
5 | |
6 | | from tenacity import RetryError, retry, stop_after_attempt, wait_exponential
  | |____________________________________________________________________________^ I001
7 |
8 |   T = TypeVar("T")
  |
  = help: Organize imports

backend-call-automation\app\utils\decorators.py:4:35: F401 [*] `typing.Any` imported but unused
  |
2 | import logging
3 | from collections.abc import Awaitable, Callable
4 | from typing import TypeVar, cast, Any
  |                                   ^^^ F401
5 |
6 | from tenacity import RetryError, retry, stop_after_attempt, wait_exponential
  |
  = help: Remove unused import: `typing.Any`

backend-call-automation\app\utils\decorators.py:22:27: ANN002 Missing type annotation for `*args`
   |
20 |     def decorator(func: Callable[..., Awaitable[T]]) -> Callable[..., Awaitable[T]]:
21 |         @functools.wraps(func)
22 |         async def wrapper(*args, **kwargs) -> T:
   |                           ^^^^^ ANN002
23 |             try:
   |

backend-call-automation\app\utils\decorators.py:22:34: ANN003 Missing type annotation for `**kwargs`
   |
20 |     def decorator(func: Callable[..., Awaitable[T]]) -> Callable[..., Awaitable[T]]:
21 |         @functools.wraps(func)
22 |         async def wrapper(*args, **kwargs) -> T:
   |                                  ^^^^^^^^ ANN003
23 |             try:
   |

backend-call-automation\app\utils\decorators.py:33:27: ANN202 Missing return type annotation for private function `retry_func`
   |
31 |                     ),
32 |                 )
33 |                 async def retry_func():
   |                           ^^^^^^^^^^ ANN202
34 |                     return await func(*args, **kwargs)
   |
   = help: Add return type annotation

backend-call-automation\app\utils\decorators.py:39:17: TRY400 Use `logging.exception` instead of `logging.error`
   |
37 |                 return cast(T, result)
38 |             except RetryError as e:
39 |                 logger.error(f"Max retries reached for {func.__name__}: {e!s}")
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY400
40 |                 raise
   |
   = help: Replace with `exception`

backend-call-automation\app\utils\logger.py:5:1: I001 [*] Import block is un-sorted or un-formatted
   |
 3 |   """
 4 |
 5 | / import logging
 6 | |
 7 | |
 8 | | from typing import Any
   | |______________________^ I001
 9 |
10 |   def get_logger(name: str) -> logging.Logger:
   |
   = help: Organize imports

backend-call-automation\app\utils\logger.py:8:20: F401 [*] `typing.Any` imported but unused
   |
 8 | from typing import Any
   |                    ^^^ F401
 9 |
10 | def get_logger(name: str) -> logging.Logger:
   |
   = help: Remove unused import: `typing.Any`

backend-call-automation\app\utils\logging.py:47:26: DTZ003 `datetime.datetime.utcnow()` used
   |
45 |         """
46 |         log_data = {
47 |             "timestamp": datetime.utcnow().isoformat(),
   |                          ^^^^^^^^^^^^^^^^^ DTZ003
48 |             "level": record.levelname,
49 |             "message": record.getMessage(),
   |
   = help: Use `datetime.datetime.now(tz=...)` instead

backend-call-automation\app\utils\logging.py:199:13: TRY300 Consider moving this statement to an `else` block
    |
197 |             response.headers["X-Request-ID"] = request_id
198 |
199 |             return response
    |             ^^^^^^^^^^^^^^^ TRY300
200 |
201 |         except Exception as e:
    |

backend-call-automation\app\utils\logging.py:230:9: ANN202 Missing return type annotation for private function `decorator`
    |
228 |     """
229 |
230 |     def decorator(func: Callable):
    |         ^^^^^^^^^ ANN202
231 |         @wraps(func)
232 |         async def async_wrapper(*args, **kwargs):
    |
    = help: Add return type annotation

backend-call-automation\app\utils\logging.py:232:19: ANN202 Missing return type annotation for private function `async_wrapper`
    |
230 |     def decorator(func: Callable):
231 |         @wraps(func)
232 |         async def async_wrapper(*args, **kwargs):
    |                   ^^^^^^^^^^^^^ ANN202
233 |             # Generar ID de operación
234 |             operation_id = str(uuid.uuid4())
    |
    = help: Add return type annotation

backend-call-automation\app\utils\logging.py:232:33: ANN002 Missing type annotation for `*args`
    |
230 |     def decorator(func: Callable):
231 |         @wraps(func)
232 |         async def async_wrapper(*args, **kwargs):
    |                                 ^^^^^ ANN002
233 |             # Generar ID de operación
234 |             operation_id = str(uuid.uuid4())
    |

backend-call-automation\app\utils\logging.py:232:40: ANN003 Missing type annotation for `**kwargs`
    |
230 |     def decorator(func: Callable):
231 |         @wraps(func)
232 |         async def async_wrapper(*args, **kwargs):
    |                                        ^^^^^^^^ ANN003
233 |             # Generar ID de operación
234 |             operation_id = str(uuid.uuid4())
    |

backend-call-automation\app\utils\logging.py:271:17: TRY300 Consider moving this statement to an `else` block
    |
269 |                 )
270 |
271 |                 return result
    |                 ^^^^^^^^^^^^^ TRY300
272 |
273 |             except Exception as e:
    |

backend-call-automation\app\utils\logging.py:294:13: ANN202 Missing return type annotation for private function `sync_wrapper`
    |
293 |         @wraps(func)
294 |         def sync_wrapper(*args, **kwargs):
    |             ^^^^^^^^^^^^ ANN202
295 |             # Generar ID de operación
296 |             operation_id = str(uuid.uuid4())
    |
    = help: Add return type annotation

backend-call-automation\app\utils\logging.py:294:26: ANN002 Missing type annotation for `*args`
    |
293 |         @wraps(func)
294 |         def sync_wrapper(*args, **kwargs):
    |                          ^^^^^ ANN002
295 |             # Generar ID de operación
296 |             operation_id = str(uuid.uuid4())
    |

backend-call-automation\app\utils\logging.py:294:33: ANN003 Missing type annotation for `**kwargs`
    |
293 |         @wraps(func)
294 |         def sync_wrapper(*args, **kwargs):
    |                                 ^^^^^^^^ ANN003
295 |             # Generar ID de operación
296 |             operation_id = str(uuid.uuid4())
    |

backend-call-automation\app\utils\logging.py:333:17: TRY300 Consider moving this statement to an `else` block
    |
331 |                 )
332 |
333 |                 return result
    |                 ^^^^^^^^^^^^^ TRY300
334 |
335 |             except Exception as e:
    |

backend-call-automation\app\utils\logging.py:381:15: ANN202 Missing return type annotation for private function `startup_event`
    |
379 |     # Añadir evento de inicio
380 |     @app.on_event("startup")
381 |     async def startup_event():
    |               ^^^^^^^^^^^^^ ANN202
382 |         logger.info(
383 |             "Application startup",
    |
    = help: Add return type annotation: `None`

backend-call-automation\app\utils\logging.py:391:15: ANN202 Missing return type annotation for private function `shutdown_event`
    |
389 |     # Añadir evento de cierre
390 |     @app.on_event("shutdown")
391 |     async def shutdown_event():
    |               ^^^^^^^^^^^^^^ ANN202
392 |         logger.info(
393 |             "Application shutdown",
    |
    = help: Add return type annotation: `None`

backend-call-automation\app\utils\logging.py:401:1: E402 Module level import not at top of file
    |
400 | # Crear logger global
401 | import asyncio
    | ^^^^^^^^^^^^^^ E402
402 | import os
    |

backend-call-automation\app\utils\logging.py:402:1: E402 Module level import not at top of file
    |
400 | # Crear logger global
401 | import asyncio
402 | import os
    | ^^^^^^^^^ E402
403 |
404 | # from typing import Optional, Any  # No se utilizan
    |

backend-call-automation\app\utils\logging.py:404:1: ERA001 Found commented-out code
    |
402 | import os
403 |
404 | # from typing import Optional, Any  # No se utilizan
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
405 |
406 | # Asegurarse de que el directorio de logs existe
    |
    = help: Remove commented-out code

backend-call-automation\app\utils\logging_config.py:4:25: F401 [*] `typing.Optional` imported but unused
  |
2 | import logging
3 | from datetime import datetime
4 | from typing import Any, Optional
  |                         ^^^^^^^^ F401
5 |
6 | # Configure root logger or specific loggers as needed
  |
  = help: Remove unused import: `typing.Optional`

backend-call-automation\app\utils\logging_config.py:33:26: DTZ003 `datetime.datetime.utcnow()` used
   |
31 |         """Helper to create a structured log entry."""
32 |         entry = {
33 |             "timestamp": datetime.utcnow().isoformat(),
   |                          ^^^^^^^^^^^^^^^^^ DTZ003
34 |             "level": level,
35 |             "service": "ElevenLabsService",
   |
   = help: Use `datetime.datetime.now(tz=...)` instead

backend-call-automation\app\utils\logging_config.py:115:1: ERA001 Found commented-out code
    |
114 | # Global instance (optional, could be instantiated per service instance)
115 | # elevenlabs_logger = ElevenLabsLogger()
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
    |
    = help: Remove commented-out code

backend-call-automation\docs\conf.py:5:1: I001 [*] Import block is un-sorted or un-formatted
   |
 3 |   """
 4 |
 5 | / import os
 6 | | import sys
 7 | |
 8 | | from typing import Optional, Any
   | |________________________________^ I001
 9 |
10 |   sys.path.insert(0, os.path.abspath(".."))
   |
   = help: Organize imports

backend-call-automation\docs\conf.py:8:20: F401 [*] `typing.Optional` imported but unused
   |
 6 | import sys
 7 |
 8 | from typing import Optional, Any
   |                    ^^^^^^^^ F401
 9 |
10 | sys.path.insert(0, os.path.abspath(".."))
   |
   = help: Remove unused import

backend-call-automation\docs\conf.py:8:30: F401 [*] `typing.Any` imported but unused
   |
 6 | import sys
 7 |
 8 | from typing import Optional, Any
   |                              ^^^ F401
 9 |
10 | sys.path.insert(0, os.path.abspath(".."))
   |
   = help: Remove unused import

backend-call-automation\docs\conf.py:53:1: ERA001 Found commented-out code
   |
51 | html_static_path = ["_static"]
52 |
53 | # plantuml_path = '/usr/bin/plantuml'
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
54 |
55 | # Configuración de autodoc
   |
   = help: Remove commented-out code

backend-call-automation\scripts\validate_env.py:13:9: S101 Use of `assert` detected
   |
11 |     # Validar Database
12 |     try:
13 |         assert settings.DATABASE_URL.startswith("postgresql://")
   |         ^^^^^^ S101
14 |         validation_results["database"] = "OK"
15 |     except Exception as e:
   |

backend-call-automation\scripts\validate_env.py:20:9: S101 Use of `assert` detected
   |
18 |     # Validar Supabase
19 |     try:
20 |         assert settings.SUPABASE_URL.startswith("https://")
   |         ^^^^^^ S101
21 |         assert len(settings.SUPABASE_KEY) > 50
22 |         validation_results["supabase"] = "OK"
   |

backend-call-automation\scripts\validate_env.py:21:9: S101 Use of `assert` detected
   |
19 |     try:
20 |         assert settings.SUPABASE_URL.startswith("https://")
21 |         assert len(settings.SUPABASE_KEY) > 50
   |         ^^^^^^ S101
22 |         validation_results["supabase"] = "OK"
23 |     except Exception as e:
   |

backend-call-automation\scripts\validate_env.py:21:45: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
   |
19 |     try:
20 |         assert settings.SUPABASE_URL.startswith("https://")
21 |         assert len(settings.SUPABASE_KEY) > 50
   |                                             ^^ PLR2004
22 |         validation_results["supabase"] = "OK"
23 |     except Exception as e:
   |

backend-call-automation\scripts\validate_env.py:28:9: S101 Use of `assert` detected
   |
26 |     # Validar Twilio
27 |     try:
28 |         assert settings.TWILIO_ACCOUNT_SID.startswith("AC")
   |         ^^^^^^ S101
29 |         assert len(settings.TWILIO_AUTH_TOKEN) > 0
30 |         validation_results["twilio"] = "OK"
   |

backend-call-automation\scripts\validate_env.py:29:9: S101 Use of `assert` detected
   |
27 |     try:
28 |         assert settings.TWILIO_ACCOUNT_SID.startswith("AC")
29 |         assert len(settings.TWILIO_AUTH_TOKEN) > 0
   |         ^^^^^^ S101
30 |         validation_results["twilio"] = "OK"
31 |     except Exception as e:
   |

backend-call-automation\setup.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from setuptools import find_packages, setup
2 | |
3 | | from typing import Any
  | |______________________^ I001
4 |
5 |   setup(
  |
  = help: Organize imports

backend-call-automation\setup.py:3:20: F401 [*] `typing.Any` imported but unused
  |
1 | from setuptools import find_packages, setup
2 |
3 | from typing import Any
  |                    ^^^ F401
4 |
5 | setup(
  |
  = help: Remove unused import: `typing.Any`

backend-call-automation\tests\app\config\test_redis_client.py:6:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
  |
6 | @pytest.mark.asyncio()
  | ^^^^^^^^^^^^^^^^^^^^^^ PT023
7 | class TestRedisClient:
8 |     async def test_generate_cache_key(self):
  |
  = help: Remove parentheses

backend-call-automation\tests\app\config\test_redis_client.py:8:15: ANN201 Missing return type annotation for public function `test_generate_cache_key`
   |
 6 | @pytest.mark.asyncio()
 7 | class TestRedisClient:
 8 |     async def test_generate_cache_key(self):
   |               ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
 9 |         """Prueba la generación de claves de caché."""
10 |         conv_id = "test-123"
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\config\test_redis_client.py:15:15: ANN201 Missing return type annotation for public function `test_cache_operations`
   |
13 |         assert isinstance(key, str)
14 |
15 |     async def test_cache_operations(self):
   |               ^^^^^^^^^^^^^^^^^^^^^ ANN201
16 |         """Prueba operaciones básicas de caché."""
17 |         test_key = "test-key"
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\config\test_redis_client.py:34:15: ANN201 Missing return type annotation for public function `test_invalid_cache_key`
   |
32 |         assert expired_data is None
33 |
34 |     async def test_invalid_cache_key(self):
   |               ^^^^^^^^^^^^^^^^^^^^^^ ANN201
35 |         """Prueba el manejo de claves inválidas."""
36 |         invalid_data = await get_from_cache("nonexistent-key")
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\config\test_settings.py:13:5: ANN201 Missing return type annotation for public function `test_settings_loaded`
   |
13 | def test_settings_loaded():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
14 |     """
15 |     Verifica que la configuración básica de la aplicación se cargue correctamente.
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\config\test_settings.py:27:5: ANN201 Missing return type annotation for public function `test_database_config`
   |
27 | def test_database_config():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
28 |     """
29 |     Verifica que la configuración de la base de datos se cargue correctamente.
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\config\test_settings.py:39:5: ANN201 Missing return type annotation for public function `test_supabase_config`
   |
39 | def test_supabase_config():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
40 |     """
41 |     Verifica que la configuración de Supabase se cargue correctamente.
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\config\test_settings.py:54:5: ANN201 Missing return type annotation for public function `test_twilio_config`
   |
54 | def test_twilio_config():
   |     ^^^^^^^^^^^^^^^^^^ ANN201
55 |     """
56 |     Verifica que la configuración de Twilio se cargue correctamente.
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\models\test_campaign.py:16:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
16 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
17 | def sample_campaign_data() -> dict:
18 |     campaign_id = uuid4()
   |
   = help: Remove parentheses

backend-call-automation\tests\app\models\test_campaign.py:24:27: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
22 |         "description": "Campaña de ventas para el primer trimestre",
23 |         "status": CampaignStatus.ACTIVE,
24 |         "schedule_start": datetime(2025, 1, 25),
   |                           ^^^^^^^^^^^^^^^^^^^^^ DTZ001
25 |         "schedule_end": datetime(2025, 2, 25),
26 |         "contact_list_ids": [contact_id],
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

backend-call-automation\tests\app\models\test_campaign.py:25:25: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
23 |         "status": CampaignStatus.ACTIVE,
24 |         "schedule_start": datetime(2025, 1, 25),
25 |         "schedule_end": datetime(2025, 2, 25),
   |                         ^^^^^^^^^^^^^^^^^^^^^ DTZ001
26 |         "contact_list_ids": [contact_id],
27 |         "script_template": "Hola {nombre}, le llamamos de...",
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

backend-call-automation\tests\app\models\test_campaign.py:37:23: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
35 |         "failed_calls": 15,
36 |         "pending_calls": 10,
37 |         "created_at": datetime(2025, 1, 24, 20, 52, 51),
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ001
38 |         "updated_at": datetime(2025, 1, 24, 20, 52, 51),
39 |     }
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

backend-call-automation\tests\app\models\test_campaign.py:38:23: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
36 |         "pending_calls": 10,
37 |         "created_at": datetime(2025, 1, 24, 20, 52, 51),
38 |         "updated_at": datetime(2025, 1, 24, 20, 52, 51),
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ001
39 |     }
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

backend-call-automation\tests\app\models\test_campaign.py:42:5: ANN201 Missing return type annotation for public function `test_campaign_base`
   |
42 | def test_campaign_base(sample_campaign_data):
   |     ^^^^^^^^^^^^^^^^^^ ANN201
43 |     data = {
44 |         k: v
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\models\test_campaign.py:42:24: ANN001 Missing type annotation for function argument `sample_campaign_data`
   |
42 | def test_campaign_base(sample_campaign_data):
   |                        ^^^^^^^^^^^^^^^^^^^^ ANN001
43 |     data = {
44 |         k: v
   |

backend-call-automation\tests\app\models\test_campaign.py:61:39: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
59 |     assert campaign.name == "Campaña de Ventas Q1"
60 |     assert campaign.status == CampaignStatus.ACTIVE
61 |     assert campaign.schedule_start == datetime(2025, 1, 25)
   |                                       ^^^^^^^^^^^^^^^^^^^^^ DTZ001
62 |     assert isinstance(campaign.contact_list_ids[0], UUID)
63 |     assert campaign.calling_hours_start == "09:00"
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

backend-call-automation\tests\app\models\test_campaign.py:67:5: ANN201 Missing return type annotation for public function `test_campaign_create`
   |
67 | def test_campaign_create(sample_campaign_data):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
68 |     data = {
69 |         k: v
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\models\test_campaign.py:67:26: ANN001 Missing type annotation for function argument `sample_campaign_data`
   |
67 | def test_campaign_create(sample_campaign_data):
   |                          ^^^^^^^^^^^^^^^^^^^^ ANN001
68 |     data = {
69 |         k: v
   |

backend-call-automation\tests\app\models\test_campaign.py:89:5: ANN201 Missing return type annotation for public function `test_campaign_update`
   |
89 | def test_campaign_update(sample_campaign_data):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
90 |     data = {"name": "Campaña Actualizada", "status": CampaignStatus.PAUSED, "max_retries": 2}
91 |     campaign = CampaignUpdate(**data)
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\models\test_campaign.py:89:26: ANN001 Missing type annotation for function argument `sample_campaign_data`
   |
89 | def test_campaign_update(sample_campaign_data):
   |                          ^^^^^^^^^^^^^^^^^^^^ ANN001
90 |     data = {"name": "Campaña Actualizada", "status": CampaignStatus.PAUSED, "max_retries": 2}
91 |     campaign = CampaignUpdate(**data)
   |

backend-call-automation\tests\app\models\test_campaign.py:89:26: ARG001 Unused function argument: `sample_campaign_data`
   |
89 | def test_campaign_update(sample_campaign_data):
   |                          ^^^^^^^^^^^^^^^^^^^^ ARG001
90 |     data = {"name": "Campaña Actualizada", "status": CampaignStatus.PAUSED, "max_retries": 2}
91 |     campaign = CampaignUpdate(**data)
   |

backend-call-automation\tests\app\models\test_campaign.py:94:36: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
92 |     assert campaign.name == "Campaña Actualizada"
93 |     assert campaign.status == CampaignStatus.PAUSED
94 |     assert campaign.max_retries == 2
   |                                    ^ PLR2004
   |

backend-call-automation\tests\app\models\test_campaign.py:97:5: ANN201 Missing return type annotation for public function `test_campaign`
   |
97 | def test_campaign(sample_campaign_data):
   |     ^^^^^^^^^^^^^ ANN201
98 |     campaign = Campaign(**sample_campaign_data)
99 |     assert campaign.name == "Campaña de Ventas Q1"
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\models\test_campaign.py:97:19: ANN001 Missing type annotation for function argument `sample_campaign_data`
   |
97 | def test_campaign(sample_campaign_data):
   |                   ^^^^^^^^^^^^^^^^^^^^ ANN001
98 |     campaign = Campaign(**sample_campaign_data)
99 |     assert campaign.name == "Campaña de Ventas Q1"
   |

backend-call-automation\tests\app\models\test_campaign.py:102:36: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
100 |     assert campaign.status == CampaignStatus.ACTIVE
101 |     assert isinstance(campaign.id, UUID)
102 |     assert campaign.total_calls == 100
    |                                    ^^^ PLR2004
103 |     assert campaign.successful_calls == 75
104 |     assert campaign.failed_calls == 15
    |

backend-call-automation\tests\app\models\test_campaign.py:103:41: PLR2004 Magic value used in comparison, consider replacing `75` with a constant variable
    |
101 |     assert isinstance(campaign.id, UUID)
102 |     assert campaign.total_calls == 100
103 |     assert campaign.successful_calls == 75
    |                                         ^^ PLR2004
104 |     assert campaign.failed_calls == 15
105 |     assert campaign.pending_calls == 10
    |

backend-call-automation\tests\app\models\test_campaign.py:104:37: PLR2004 Magic value used in comparison, consider replacing `15` with a constant variable
    |
102 |     assert campaign.total_calls == 100
103 |     assert campaign.successful_calls == 75
104 |     assert campaign.failed_calls == 15
    |                                     ^^ PLR2004
105 |     assert campaign.pending_calls == 10
    |

backend-call-automation\tests\app\models\test_campaign.py:105:38: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
103 |     assert campaign.successful_calls == 75
104 |     assert campaign.failed_calls == 15
105 |     assert campaign.pending_calls == 10
    |                                      ^^ PLR2004
    |

backend-call-automation\tests\app\models\test_campaign.py:108:5: ANN201 Missing return type annotation for public function `test_invalid_campaign_status`
    |
108 | def test_invalid_campaign_status():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
109 |     with pytest.raises(ValidationError):
110 |         CampaignBase(
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\models\test_campaign.py:113:28: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
    |
111 |             name="Test",
112 |             status="invalid_status",
113 |             schedule_start=datetime(2025, 1, 25),
    |                            ^^^^^^^^^^^^^^^^^^^^^ DTZ001
114 |             schedule_end=datetime(2025, 2, 25),
115 |             contact_list_ids=[uuid4()],
    |
    = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

backend-call-automation\tests\app\models\test_campaign.py:114:26: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
    |
112 |             status="invalid_status",
113 |             schedule_start=datetime(2025, 1, 25),
114 |             schedule_end=datetime(2025, 2, 25),
    |                          ^^^^^^^^^^^^^^^^^^^^^ DTZ001
115 |             contact_list_ids=[uuid4()],
116 |             script_template="Test script",
    |
    = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

backend-call-automation\tests\app\models\test_campaign.py:124:5: ANN201 Missing return type annotation for public function `test_invalid_dates`
    |
124 | def test_invalid_dates():
    |     ^^^^^^^^^^^^^^^^^^ ANN201
125 |     with pytest.raises(ValidationError):
126 |         CampaignBase(
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\models\test_campaign.py:129:28: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
    |
127 |             name="Test",
128 |             status=CampaignStatus.DRAFT,
129 |             schedule_start=datetime(2025, 2, 25),
    |                            ^^^^^^^^^^^^^^^^^^^^^ DTZ001
130 |             schedule_end=datetime(2025, 1, 25),  # End before start
131 |             contact_list_ids=[uuid4()],
    |
    = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

backend-call-automation\tests\app\models\test_campaign.py:130:26: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
    |
128 |             status=CampaignStatus.DRAFT,
129 |             schedule_start=datetime(2025, 2, 25),
130 |             schedule_end=datetime(2025, 1, 25),  # End before start
    |                          ^^^^^^^^^^^^^^^^^^^^^ DTZ001
131 |             contact_list_ids=[uuid4()],
132 |             script_template="Test script",
    |
    = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

backend-call-automation\tests\app\models\test_campaign.py:140:5: ANN201 Missing return type annotation for public function `test_invalid_calling_hours`
    |
140 | def test_invalid_calling_hours():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
141 |     with pytest.raises(ValidationError):
142 |         CampaignBase(
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\models\test_campaign.py:145:28: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
    |
143 |             name="Test",
144 |             status=CampaignStatus.DRAFT,
145 |             schedule_start=datetime(2025, 1, 25),
    |                            ^^^^^^^^^^^^^^^^^^^^^ DTZ001
146 |             schedule_end=datetime(2025, 2, 25),
147 |             contact_list_ids=[uuid4()],
    |
    = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

backend-call-automation\tests\app\models\test_campaign.py:146:26: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
    |
144 |             status=CampaignStatus.DRAFT,
145 |             schedule_start=datetime(2025, 1, 25),
146 |             schedule_end=datetime(2025, 2, 25),
    |                          ^^^^^^^^^^^^^^^^^^^^^ DTZ001
147 |             contact_list_ids=[uuid4()],
148 |             script_template="Test script",
    |
    = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

backend-call-automation\tests\app\routers\test_campaign_router.py:8:5: ANN201 Missing return type annotation for public function `test_pagination`
   |
 8 | def test_pagination(test_client: TestClient):
   |     ^^^^^^^^^^^^^^^ ANN201
 9 |     logger.info("Iniciando test de paginación")
10 |     # Crear múltiples campañas
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\routers\test_campaign_router.py:26:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
25 |     response = test_client.get("/api/campaigns/?page=1&page_size=10")
26 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
27 |     data = response.json()
28 |     assert len(data) <= 10
   |

backend-call-automation\tests\app\routers\test_campaign_router.py:28:25: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
26 |     assert response.status_code == 200
27 |     data = response.json()
28 |     assert len(data) <= 10
   |                         ^^ PLR2004
   |

backend-call-automation\tests\app\routers\test_campaign_router.py:31:5: ANN201 Missing return type annotation for public function `test_filter_by_status`
   |
31 | def test_filter_by_status(test_client: TestClient):
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
32 |     logger.info("Iniciando test de filtrado por estado")
33 |     # Crear campañas con diferentes estados
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\routers\test_campaign_router.py:50:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
49 |     response = test_client.get("/api/campaigns/?status=active")
50 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
51 |     data = response.json()
52 |     assert all(campaign["status"] == "active" for campaign in data)
   |

backend-call-automation\tests\app\routers\test_campaign_router.py:55:5: ANN201 Missing return type annotation for public function `test_filter_by_date_range`
   |
55 | def test_filter_by_date_range(test_client: TestClient):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
56 |     logger.info("Iniciando test de filtrado por rango de fechas")
57 |     dates = [
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\routers\test_campaign_router.py:79:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
77 |         "/api/campaigns/?start_date=2025-01-01T00:00:00&end_date=2025-06-30T23:59:59"
78 |     )
79 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
80 |     data = response.json()
81 |     assert all(campaign["schedule_start"] <= "2025-06-30T23:59:59" for campaign in data)
   |

backend-call-automation\tests\app\services\test_ai_conversation_service.py:8:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
 8 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
 9 | async def mock_llm():
10 |     mock = AsyncMock()
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_ai_conversation_service.py:9:11: ANN201 Missing return type annotation for public function `mock_llm`
   |
 8 | @pytest.fixture()
 9 | async def mock_llm():
   |           ^^^^^^^^ ANN201
10 |     mock = AsyncMock()
11 |     mock.predict.return_value = "Respuesta de prueba"
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_ai_conversation_service.py:15:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
15 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
16 | async def mock_redis():
17 |     mock = AsyncMock()
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_ai_conversation_service.py:16:11: ANN201 Missing return type annotation for public function `mock_redis`
   |
15 | @pytest.fixture()
16 | async def mock_redis():
   |           ^^^^^^^^^^ ANN201
17 |     mock = AsyncMock()
18 |     mock.get.return_value = None
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_ai_conversation_service.py:23:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
23 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
24 | async def ai_service(mock_llm, mock_redis):
25 |     service = AIConversationService(model_name="gpt-4", redis_client=mock_redis)
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_ai_conversation_service.py:24:11: ANN201 Missing return type annotation for public function `ai_service`
   |
23 | @pytest.fixture()
24 | async def ai_service(mock_llm, mock_redis):
   |           ^^^^^^^^^^ ANN201
25 |     service = AIConversationService(model_name="gpt-4", redis_client=mock_redis)
26 |     service.llm = mock_llm
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_ai_conversation_service.py:24:22: ANN001 Missing type annotation for function argument `mock_llm`
   |
23 | @pytest.fixture()
24 | async def ai_service(mock_llm, mock_redis):
   |                      ^^^^^^^^ ANN001
25 |     service = AIConversationService(model_name="gpt-4", redis_client=mock_redis)
26 |     service.llm = mock_llm
   |

backend-call-automation\tests\app\services\test_ai_conversation_service.py:24:32: ANN001 Missing type annotation for function argument `mock_redis`
   |
23 | @pytest.fixture()
24 | async def ai_service(mock_llm, mock_redis):
   |                                ^^^^^^^^^^ ANN001
25 |     service = AIConversationService(model_name="gpt-4", redis_client=mock_redis)
26 |     service.llm = mock_llm
   |

backend-call-automation\tests\app\services\test_ai_conversation_service.py:31:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
30 | class TestAIConversationService:
31 |     @pytest.mark.asyncio()
   |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
32 |     async def test_process_message_basic(self, ai_service):
33 |         """Prueba el procesamiento básico de un mensaje."""
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_ai_conversation_service.py:32:15: ANN201 Missing return type annotation for public function `test_process_message_basic`
   |
30 | class TestAIConversationService:
31 |     @pytest.mark.asyncio()
32 |     async def test_process_message_basic(self, ai_service):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
33 |         """Prueba el procesamiento básico de un mensaje."""
34 |         response = await ai_service.process_message(
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_ai_conversation_service.py:32:48: ANN001 Missing type annotation for function argument `ai_service`
   |
30 | class TestAIConversationService:
31 |     @pytest.mark.asyncio()
32 |     async def test_process_message_basic(self, ai_service):
   |                                                ^^^^^^^^^^ ANN001
33 |         """Prueba el procesamiento básico de un mensaje."""
34 |         response = await ai_service.process_message(
   |

backend-call-automation\tests\app\services\test_ai_conversation_service.py:44:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
42 |         assert response["conversation_id"] == "test-123"
43 |
44 |     @pytest.mark.asyncio()
   |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
45 |     async def test_sentiment_analysis(self, ai_service):
46 |         """Prueba el análisis de sentimientos."""
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_ai_conversation_service.py:45:15: ANN201 Missing return type annotation for public function `test_sentiment_analysis`
   |
44 |     @pytest.mark.asyncio()
45 |     async def test_sentiment_analysis(self, ai_service):
   |               ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
46 |         """Prueba el análisis de sentimientos."""
47 |         test_messages = [
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_ai_conversation_service.py:45:45: ANN001 Missing type annotation for function argument `ai_service`
   |
44 |     @pytest.mark.asyncio()
45 |     async def test_sentiment_analysis(self, ai_service):
   |                                             ^^^^^^^^^^ ANN001
46 |         """Prueba el análisis de sentimientos."""
47 |         test_messages = [
   |

backend-call-automation\tests\app\services\test_ai_conversation_service.py:53:22: B007 Loop control variable `expected_sentiment` not used within loop body
   |
51 |         ]
52 |
53 |         for message, expected_sentiment in test_messages:
   |                      ^^^^^^^^^^^^^^^^^^ B007
54 |             sentiment = await ai_service.analyze_sentiment(message)
55 |             assert "primary_emotion" in sentiment
   |
   = help: Rename unused `expected_sentiment` to `_expected_sentiment`

backend-call-automation\tests\app\services\test_ai_conversation_service.py:60:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
58 |             assert 0 <= sentiment["score"] <= 1
59 |
60 |     @pytest.mark.asyncio()
   |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
61 |     async def test_error_handling(self, ai_service, mock_llm):
62 |         """Prueba el manejo de errores."""
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_ai_conversation_service.py:61:15: ANN201 Missing return type annotation for public function `test_error_handling`
   |
60 |     @pytest.mark.asyncio()
61 |     async def test_error_handling(self, ai_service, mock_llm):
   |               ^^^^^^^^^^^^^^^^^^^ ANN201
62 |         """Prueba el manejo de errores."""
63 |         mock_llm.predict.side_effect = Exception("Error de API")
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_ai_conversation_service.py:61:41: ANN001 Missing type annotation for function argument `ai_service`
   |
60 |     @pytest.mark.asyncio()
61 |     async def test_error_handling(self, ai_service, mock_llm):
   |                                         ^^^^^^^^^^ ANN001
62 |         """Prueba el manejo de errores."""
63 |         mock_llm.predict.side_effect = Exception("Error de API")
   |

backend-call-automation\tests\app\services\test_ai_conversation_service.py:61:53: ANN001 Missing type annotation for function argument `mock_llm`
   |
60 |     @pytest.mark.asyncio()
61 |     async def test_error_handling(self, ai_service, mock_llm):
   |                                                     ^^^^^^^^ ANN001
62 |         """Prueba el manejo de errores."""
63 |         mock_llm.predict.side_effect = Exception("Error de API")
   |

backend-call-automation\tests\app\services\test_ai_conversation_service.py:65:28: PT011 `pytest.raises(Exception)` is too broad, set the `match` parameter or use a more specific exception
   |
63 |         mock_llm.predict.side_effect = Exception("Error de API")
64 |
65 |         with pytest.raises(Exception) as exc_info:
   |                            ^^^^^^^^^ PT011
66 |             await ai_service.process_message("test message")
   |

backend-call-automation\tests\app\services\test_ai_conversation_service.py:70:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
68 |         assert "Error procesando mensaje" in str(exc_info.value)
69 |
70 |     @pytest.mark.asyncio()
   |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
71 |     async def test_conversation_caching(self, ai_service, mock_redis):
72 |         """Prueba el sistema de caché de conversaciones."""
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_ai_conversation_service.py:71:15: ANN201 Missing return type annotation for public function `test_conversation_caching`
   |
70 |     @pytest.mark.asyncio()
71 |     async def test_conversation_caching(self, ai_service, mock_redis):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
72 |         """Prueba el sistema de caché de conversaciones."""
73 |         conv_id = "cache-test-123"
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_ai_conversation_service.py:71:47: ANN001 Missing type annotation for function argument `ai_service`
   |
70 |     @pytest.mark.asyncio()
71 |     async def test_conversation_caching(self, ai_service, mock_redis):
   |                                               ^^^^^^^^^^ ANN001
72 |         """Prueba el sistema de caché de conversaciones."""
73 |         conv_id = "cache-test-123"
   |

backend-call-automation\tests\app\services\test_ai_conversation_service.py:71:59: ANN001 Missing type annotation for function argument `mock_redis`
   |
70 |     @pytest.mark.asyncio()
71 |     async def test_conversation_caching(self, ai_service, mock_redis):
   |                                                           ^^^^^^^^^^ ANN001
72 |         """Prueba el sistema de caché de conversaciones."""
73 |         conv_id = "cache-test-123"
   |

backend-call-automation\tests\app\services\test_ai_conversation_service.py:82:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
80 |         mock_redis.setex.assert_called_once()
81 |
82 |     @pytest.mark.asyncio()
   |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
83 |     async def test_context_handling(self, ai_service):
84 |         """Prueba el manejo de contexto adicional."""
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_ai_conversation_service.py:83:15: ANN201 Missing return type annotation for public function `test_context_handling`
   |
82 |     @pytest.mark.asyncio()
83 |     async def test_context_handling(self, ai_service):
   |               ^^^^^^^^^^^^^^^^^^^^^ ANN201
84 |         """Prueba el manejo de contexto adicional."""
85 |         context = {"campaign_id": "camp-123", "user_preferences": {"language": "es"}}
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_ai_conversation_service.py:83:43: ANN001 Missing type annotation for function argument `ai_service`
   |
82 |     @pytest.mark.asyncio()
83 |     async def test_context_handling(self, ai_service):
   |                                           ^^^^^^^^^^ ANN001
84 |         """Prueba el manejo de contexto adicional."""
85 |         context = {"campaign_id": "camp-123", "user_preferences": {"language": "es"}}
   |

backend-call-automation\tests\app\services\test_call_service.py:18:9: ANN204 Missing return type annotation for special method `__init__`
   |
17 | class MockTwilioCall:
18 |     def __init__(self, sid: str, status: str):
   |         ^^^^^^^^ ANN204
19 |         self.sid = sid
20 |         self.status = status
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:23:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
23 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
24 | def test_campaign():
25 |     now = datetime.now()
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:24:5: ANN201 Missing return type annotation for public function `test_campaign`
   |
23 | @pytest.fixture()
24 | def test_campaign():
   |     ^^^^^^^^^^^^^ ANN201
25 |     now = datetime.now()
26 |     return Campaign(
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_call_service.py:25:11: DTZ005 `datetime.datetime.now()` called without a `tz` argument
   |
23 | @pytest.fixture()
24 | def test_campaign():
25 |     now = datetime.now()
   |           ^^^^^^^^^^^^^^ DTZ005
26 |     return Campaign(
27 |         id=1,
   |
   = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\tests\app\services\test_call_service.py:44:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
44 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
45 | def mock_twilio_client():
46 |     class MockTwilio:
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:45:5: ANN201 Missing return type annotation for public function `mock_twilio_client`
   |
44 | @pytest.fixture()
45 | def mock_twilio_client():
   |     ^^^^^^^^^^^^^^^^^^ ANN201
46 |     class MockTwilio:
47 |         def __init__(self):
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_call_service.py:47:13: ANN204 Missing return type annotation for special method `__init__`
   |
45 | def mock_twilio_client():
46 |     class MockTwilio:
47 |         def __init__(self):
   |             ^^^^^^^^ ANN204
48 |             self.calls = Mock()
49 |             self.calls.create = AsyncMock()
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:55:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
55 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
56 | def mock_supabase_client():
57 |     class MockSupabase:
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:56:5: ANN201 Missing return type annotation for public function `mock_supabase_client`
   |
55 | @pytest.fixture()
56 | def mock_supabase_client():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
57 |     class MockSupabase:
58 |         def __init__(self):
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_call_service.py:58:13: ANN204 Missing return type annotation for special method `__init__`
   |
56 | def mock_supabase_client():
57 |     class MockSupabase:
58 |         def __init__(self):
   |             ^^^^^^^^ ANN204
59 |             self.responses = []
60 |             self.current_response = 0
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:67:13: ANN202 Missing return type annotation for private function `set_responses`
   |
65 |             self.is_single = False
66 |
67 |         def set_responses(self, *responses):
   |             ^^^^^^^^^^^^^ ANN202
68 |             self.responses = []
69 |             for response in responses:
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:67:33: ANN002 Missing type annotation for `*responses`
   |
65 |             self.is_single = False
66 |
67 |         def set_responses(self, *responses):
   |                                 ^^^^^^^^^^ ANN002
68 |             self.responses = []
69 |             for response in responses:
   |

backend-call-automation\tests\app\services\test_call_service.py:77:13: ANN202 Missing return type annotation for private function `from_`
   |
75 |             logger.debug(f"Configuradas {len(self.responses)} respuestas: {self.responses}")
76 |
77 |         def from_(self, table):
   |             ^^^^^ ANN202
78 |             logger.debug(f"Llamado from_ con tabla: {table}")
79 |             self.last_table = table
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_call_service.py:77:25: ANN001 Missing type annotation for function argument `table`
   |
75 |             logger.debug(f"Configuradas {len(self.responses)} respuestas: {self.responses}")
76 |
77 |         def from_(self, table):
   |                         ^^^^^ ANN001
78 |             logger.debug(f"Llamado from_ con tabla: {table}")
79 |             self.last_table = table
   |

backend-call-automation\tests\app\services\test_call_service.py:85:13: ANN202 Missing return type annotation for private function `select`
   |
83 |             return self
84 |
85 |         def select(self, *args):
   |             ^^^^^^ ANN202
86 |             logger.debug(f"Llamado select con args: {args}")
87 |             self.last_operation = "select"
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_call_service.py:85:26: ANN002 Missing type annotation for `*args`
   |
83 |             return self
84 |
85 |         def select(self, *args):
   |                          ^^^^^ ANN002
86 |             logger.debug(f"Llamado select con args: {args}")
87 |             self.last_operation = "select"
   |

backend-call-automation\tests\app\services\test_call_service.py:90:13: ANN202 Missing return type annotation for private function `insert`
   |
88 |             return self
89 |
90 |         def insert(self, data):
   |             ^^^^^^ ANN202
91 |             logger.debug(f"Llamado insert con data: {data}")
92 |             self.last_operation = "insert"
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_call_service.py:90:26: ANN001 Missing type annotation for function argument `data`
   |
88 |             return self
89 |
90 |         def insert(self, data):
   |                          ^^^^ ANN001
91 |             logger.debug(f"Llamado insert con data: {data}")
92 |             self.last_operation = "insert"
   |

backend-call-automation\tests\app\services\test_call_service.py:96:13: ANN202 Missing return type annotation for private function `update`
   |
94 |             return self
95 |
96 |         def update(self, data):
   |             ^^^^^^ ANN202
97 |             logger.debug(f"Llamado update con data: {data}")
98 |             self.last_operation = "update"
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_call_service.py:96:26: ANN001 Missing type annotation for function argument `data`
   |
94 |             return self
95 |
96 |         def update(self, data):
   |                          ^^^^ ANN001
97 |             logger.debug(f"Llamado update con data: {data}")
98 |             self.last_operation = "update"
   |

backend-call-automation\tests\app\services\test_call_service.py:102:13: ANN202 Missing return type annotation for private function `eq`
    |
100 |             return self
101 |
102 |         def eq(self, column, value):
    |             ^^ ANN202
103 |             logger.debug(f"Llamado eq con column: {column}, value: {value}")
104 |             if not hasattr(self, "conditions"):
    |
    = help: Add return type annotation

backend-call-automation\tests\app\services\test_call_service.py:102:22: ANN001 Missing type annotation for function argument `column`
    |
100 |             return self
101 |
102 |         def eq(self, column, value):
    |                      ^^^^^^ ANN001
103 |             logger.debug(f"Llamado eq con column: {column}, value: {value}")
104 |             if not hasattr(self, "conditions"):
    |

backend-call-automation\tests\app\services\test_call_service.py:102:30: ANN001 Missing type annotation for function argument `value`
    |
100 |             return self
101 |
102 |         def eq(self, column, value):
    |                              ^^^^^ ANN001
103 |             logger.debug(f"Llamado eq con column: {column}, value: {value}")
104 |             if not hasattr(self, "conditions"):
    |

backend-call-automation\tests\app\services\test_call_service.py:109:13: ANN202 Missing return type annotation for private function `single`
    |
107 |             return self
108 |
109 |         def single(self):
    |             ^^^^^^ ANN202
110 |             logger.debug("Llamado single")
111 |             self.is_single = True
    |
    = help: Add return type annotation

backend-call-automation\tests\app\services\test_call_service.py:114:19: ANN202 Missing return type annotation for private function `execute`
    |
112 |             return self
113 |
114 |         async def execute(self):
    |                   ^^^^^^^ ANN202
115 |             logger.debug(
116 |                 f"Ejecutando con operación: {self.last_operation}, tabla: {self.last_table}"
    |
    = help: Add return type annotation

backend-call-automation\tests\app\services\test_call_service.py:119:101: E501 Line too long (105 > 100)
    |
117 |             )
118 |             logger.debug(
119 |                 f"Estado actual - is_single: {self.is_single}, current_response: {self.current_response}"
    |                                                                                                     ^^^^^ E501
120 |             )
    |

backend-call-automation\tests\app\services\test_call_service.py:129:101: E501 Line too long (105 > 100)
    |
127 |             logger.debug(f"Respuesta inicial: {response}")
128 |
129 |             # Si es una operación de insert o update, actualizar los datos con los valores proporcionados
    |                                                                                                     ^^^^^ E501
130 |             if self.last_operation in ["insert", "update"] and self.last_data:
131 |                 logger.debug(f"Actualizando datos para {self.last_operation}")
    |

backend-call-automation\tests\app\services\test_call_service.py:171:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
170 | class TestCallService:
171 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
172 |     async def test_handle_webhooks(self, mock_twilio_client, mock_supabase_client, test_campaign):
173 |         """
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:172:15: ANN201 Missing return type annotation for public function `test_handle_webhooks`
    |
170 | class TestCallService:
171 |     @pytest.mark.asyncio()
172 |     async def test_handle_webhooks(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |               ^^^^^^^^^^^^^^^^^^^^ ANN201
173 |         """
174 |         Prueba el manejo de webhooks de Twilio.
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:172:42: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
170 | class TestCallService:
171 |     @pytest.mark.asyncio()
172 |     async def test_handle_webhooks(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                          ^^^^^^^^^^^^^^^^^^ ANN001
173 |         """
174 |         Prueba el manejo de webhooks de Twilio.
    |

backend-call-automation\tests\app\services\test_call_service.py:172:62: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
170 | class TestCallService:
171 |     @pytest.mark.asyncio()
172 |     async def test_handle_webhooks(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                              ^^^^^^^^^^^^^^^^^^^^ ANN001
173 |         """
174 |         Prueba el manejo de webhooks de Twilio.
    |

backend-call-automation\tests\app\services\test_call_service.py:172:84: ANN001 Missing type annotation for function argument `test_campaign`
    |
170 | class TestCallService:
171 |     @pytest.mark.asyncio()
172 |     async def test_handle_webhooks(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                                                    ^^^^^^^^^^^^^ ANN001
173 |         """
174 |         Prueba el manejo de webhooks de Twilio.
    |

backend-call-automation\tests\app\services\test_call_service.py:193:33: PLR2004 Magic value used in comparison, consider replacing `120` with a constant variable
    |
191 |         call = await call_service.get_call("TEST_SID_12345")
192 |         assert call.status == CallStatus.COMPLETED
193 |         assert call.duration == 120
    |                                 ^^^ PLR2004
194 |         assert call.recording_url == "http://example.com/recording"
    |

backend-call-automation\tests\app\services\test_call_service.py:204:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
202 |         # Test webhook with invalid status
203 |         mock_twilio_client.calls.get.return_value = AsyncMock(status="invalid_status")
204 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
205 |             await call_service.handle_call_webhook("TEST_SID_12345")
    |

backend-call-automation\tests\app\services\test_call_service.py:219:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
217 |         # Test webhook with campaign inactive
218 |         test_campaign.status = "inactive"
219 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
220 |             await call_service.handle_call_webhook("TEST_SID_12345")
    |

backend-call-automation\tests\app\services\test_call_service.py:222:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
220 |             await call_service.handle_call_webhook("TEST_SID_12345")
221 |
222 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
223 |     async def test_create_call(self, mock_twilio_client, mock_supabase_client, test_campaign):
224 |         """
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:223:15: ANN201 Missing return type annotation for public function `test_create_call`
    |
222 |     @pytest.mark.asyncio()
223 |     async def test_create_call(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |               ^^^^^^^^^^^^^^^^ ANN201
224 |         """
225 |         Prueba la creación de llamadas.
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:223:38: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
222 |     @pytest.mark.asyncio()
223 |     async def test_create_call(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                      ^^^^^^^^^^^^^^^^^^ ANN001
224 |         """
225 |         Prueba la creación de llamadas.
    |

backend-call-automation\tests\app\services\test_call_service.py:223:58: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
222 |     @pytest.mark.asyncio()
223 |     async def test_create_call(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                          ^^^^^^^^^^^^^^^^^^^^ ANN001
224 |         """
225 |         Prueba la creación de llamadas.
    |

backend-call-automation\tests\app\services\test_call_service.py:223:80: ANN001 Missing type annotation for function argument `test_campaign`
    |
222 |     @pytest.mark.asyncio()
223 |     async def test_create_call(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                                                ^^^^^^^^^^^^^ ANN001
224 |         """
225 |         Prueba la creación de llamadas.
    |

backend-call-automation\tests\app\services\test_call_service.py:264:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
262 |         )
263 |
264 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
265 |     async def test_get_call(self, mock_twilio_client, mock_supabase_client, test_campaign):
266 |         call_service = CallService(
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:265:15: ANN201 Missing return type annotation for public function `test_get_call`
    |
264 |     @pytest.mark.asyncio()
265 |     async def test_get_call(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |               ^^^^^^^^^^^^^ ANN201
266 |         call_service = CallService(
267 |             twilio_client=mock_twilio_client, supabase_client=mock_supabase_client
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:265:35: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
264 |     @pytest.mark.asyncio()
265 |     async def test_get_call(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                   ^^^^^^^^^^^^^^^^^^ ANN001
266 |         call_service = CallService(
267 |             twilio_client=mock_twilio_client, supabase_client=mock_supabase_client
    |

backend-call-automation\tests\app\services\test_call_service.py:265:55: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
264 |     @pytest.mark.asyncio()
265 |     async def test_get_call(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                       ^^^^^^^^^^^^^^^^^^^^ ANN001
266 |         call_service = CallService(
267 |             twilio_client=mock_twilio_client, supabase_client=mock_supabase_client
    |

backend-call-automation\tests\app\services\test_call_service.py:265:77: ANN001 Missing type annotation for function argument `test_campaign`
    |
264 |     @pytest.mark.asyncio()
265 |     async def test_get_call(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                                             ^^^^^^^^^^^^^ ANN001
266 |         call_service = CallService(
267 |             twilio_client=mock_twilio_client, supabase_client=mock_supabase_client
    |

backend-call-automation\tests\app\services\test_call_service.py:288:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
287 |         # Test getting a non-existent call
288 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
289 |             await call_service.get_call(999)
    |

backend-call-automation\tests\app\services\test_call_service.py:299:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
297 |         assert hasattr(retrieved_call, "updated_at")
298 |
299 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
300 |     async def test_list_calls(self, mock_twilio_client, mock_supabase_client, test_campaign):
301 |         """
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:300:15: ANN201 Missing return type annotation for public function `test_list_calls`
    |
299 |     @pytest.mark.asyncio()
300 |     async def test_list_calls(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |               ^^^^^^^^^^^^^^^ ANN201
301 |         """
302 |         Escenarios a probar:
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:300:37: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
299 |     @pytest.mark.asyncio()
300 |     async def test_list_calls(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                     ^^^^^^^^^^^^^^^^^^ ANN001
301 |         """
302 |         Escenarios a probar:
    |

backend-call-automation\tests\app\services\test_call_service.py:300:57: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
299 |     @pytest.mark.asyncio()
300 |     async def test_list_calls(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                         ^^^^^^^^^^^^^^^^^^^^ ANN001
301 |         """
302 |         Escenarios a probar:
    |

backend-call-automation\tests\app\services\test_call_service.py:300:79: ANN001 Missing type annotation for function argument `test_campaign`
    |
299 |     @pytest.mark.asyncio()
300 |     async def test_list_calls(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                                               ^^^^^^^^^^^^^ ANN001
301 |         """
302 |         Escenarios a probar:
    |

backend-call-automation\tests\app\services\test_call_service.py:333:9: F841 Local variable `call2` is assigned to but never used
    |
331 |             status_callback_url="http://example.com/callback",
332 |         )
333 |         call2 = await call_service.create_call(call_data2)
    |         ^^^^^ F841
334 |
335 |         call_data3 = CallCreate(
    |
    = help: Remove assignment to unused variable `call2`

backend-call-automation\tests\app\services\test_call_service.py:342:9: F841 Local variable `call3` is assigned to but never used
    |
340 |             status_callback_url="http://example.com/callback",
341 |         )
342 |         call3 = await call_service.create_call(call_data3)
    |         ^^^^^ F841
343 |
344 |         # Test listing all calls
    |
    = help: Remove assignment to unused variable `call3`

backend-call-automation\tests\app\services\test_call_service.py:346:30: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
344 |         # Test listing all calls
345 |         calls = await call_service.list_calls()
346 |         assert len(calls) == 3
    |                              ^ PLR2004
347 |
348 |         # Test filtering by campaign_id
    |

backend-call-automation\tests\app\services\test_call_service.py:350:39: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
348 |         # Test filtering by campaign_id
349 |         campaign_calls = await call_service.list_calls(campaign_id=test_campaign.id)
350 |         assert len(campaign_calls) == 2
    |                                       ^ PLR2004
351 |
352 |         # Test filtering by status
    |

backend-call-automation\tests\app\services\test_call_service.py:367:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
365 |         assert len(combined_filtered_calls) == 1
366 |
367 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
368 |     async def test_update_call_status(
369 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:368:15: ANN201 Missing return type annotation for public function `test_update_call_status`
    |
367 |     @pytest.mark.asyncio()
368 |     async def test_update_call_status(
    |               ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
369 |         self, mock_twilio_client, mock_supabase_client, test_campaign
370 |     ):
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:369:15: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
367 |     @pytest.mark.asyncio()
368 |     async def test_update_call_status(
369 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |               ^^^^^^^^^^^^^^^^^^ ANN001
370 |     ):
371 |         call_service = CallService(
    |

backend-call-automation\tests\app\services\test_call_service.py:369:35: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
367 |     @pytest.mark.asyncio()
368 |     async def test_update_call_status(
369 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |                                   ^^^^^^^^^^^^^^^^^^^^ ANN001
370 |     ):
371 |         call_service = CallService(
    |

backend-call-automation\tests\app\services\test_call_service.py:369:57: ANN001 Missing type annotation for function argument `test_campaign`
    |
367 |     @pytest.mark.asyncio()
368 |     async def test_update_call_status(
369 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |                                                         ^^^^^^^^^^^^^ ANN001
370 |     ):
371 |         call_service = CallService(
    |

backend-call-automation\tests\app\services\test_call_service.py:396:41: PLR2004 Magic value used in comparison, consider replacing `120` with a constant variable
    |
394 |             recording_url="http://example.com/recording",
395 |         )
396 |         assert updated_call.duration == 120
    |                                         ^^^ PLR2004
397 |         assert updated_call.recording_url == "http://example.com/recording"
    |

backend-call-automation\tests\app\services\test_call_service.py:400:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
399 |         # Test invalid status
400 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
401 |             await call_service.update_call_status(call.id, status="invalid_status")
    |

backend-call-automation\tests\app\services\test_call_service.py:408:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
406 |         assert updated_call.updated_at > initial_updated_at
407 |
408 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
409 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
410 |         call_service = CallService(
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:409:15: ANN201 Missing return type annotation for public function `test_get_call_metrics`
    |
408 |     @pytest.mark.asyncio()
409 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |               ^^^^^^^^^^^^^^^^^^^^^ ANN201
410 |         call_service = CallService(
411 |             twilio_client=mock_twilio_client, supabase_client=mock_supabase_client
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:409:43: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
408 |     @pytest.mark.asyncio()
409 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                           ^^^^^^^^^^^^^^^^^^ ANN001
410 |         call_service = CallService(
411 |             twilio_client=mock_twilio_client, supabase_client=mock_supabase_client
    |

backend-call-automation\tests\app\services\test_call_service.py:409:63: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
408 |     @pytest.mark.asyncio()
409 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                               ^^^^^^^^^^^^^^^^^^^^ ANN001
410 |         call_service = CallService(
411 |             twilio_client=mock_twilio_client, supabase_client=mock_supabase_client
    |

backend-call-automation\tests\app\services\test_call_service.py:409:85: ANN001 Missing type annotation for function argument `test_campaign`
    |
408 |     @pytest.mark.asyncio()
409 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                                                     ^^^^^^^^^^^^^ ANN001
410 |         call_service = CallService(
411 |             twilio_client=mock_twilio_client, supabase_client=mock_supabase_client
    |

backend-call-automation\tests\app\services\test_call_service.py:451:42: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
449 |         # Test metrics without filters
450 |         metrics = await call_service.get_call_metrics()
451 |         assert metrics["total_calls"] == 3
    |                                          ^ PLR2004
452 |         assert metrics["average_duration"] == 150
453 |         assert metrics["status_counts"][CallStatus.COMPLETED] == 2
    |

backend-call-automation\tests\app\services\test_call_service.py:452:47: PLR2004 Magic value used in comparison, consider replacing `150` with a constant variable
    |
450 |         metrics = await call_service.get_call_metrics()
451 |         assert metrics["total_calls"] == 3
452 |         assert metrics["average_duration"] == 150
    |                                               ^^^ PLR2004
453 |         assert metrics["status_counts"][CallStatus.COMPLETED] == 2
454 |         assert metrics["status_counts"][CallStatus.FAILED] == 1
    |

backend-call-automation\tests\app\services\test_call_service.py:453:66: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
451 |         assert metrics["total_calls"] == 3
452 |         assert metrics["average_duration"] == 150
453 |         assert metrics["status_counts"][CallStatus.COMPLETED] == 2
    |                                                                  ^ PLR2004
454 |         assert metrics["status_counts"][CallStatus.FAILED] == 1
    |

backend-call-automation\tests\app\services\test_call_service.py:458:42: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
456 |         # Test metrics filtered by campaign
457 |         metrics = await call_service.get_call_metrics(campaign_id=test_campaign.id)
458 |         assert metrics["total_calls"] == 2
    |                                          ^ PLR2004
459 |         assert metrics["average_duration"] == 120
460 |         assert metrics["status_counts"][CallStatus.COMPLETED] == 1
    |

backend-call-automation\tests\app\services\test_call_service.py:459:47: PLR2004 Magic value used in comparison, consider replacing `120` with a constant variable
    |
457 |         metrics = await call_service.get_call_metrics(campaign_id=test_campaign.id)
458 |         assert metrics["total_calls"] == 2
459 |         assert metrics["average_duration"] == 120
    |                                               ^^^ PLR2004
460 |         assert metrics["status_counts"][CallStatus.COMPLETED] == 1
461 |         assert metrics["status_counts"][CallStatus.FAILED] == 1
    |

backend-call-automation\tests\app\services\test_call_service.py:463:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
461 |         assert metrics["status_counts"][CallStatus.FAILED] == 1
462 |
463 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
464 |     async def test_get_call_metrics(self, mock_supabase_client):
465 |         # Configurar múltiples llamadas con diferentes estados y duraciones
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:464:15: ANN201 Missing return type annotation for public function `test_get_call_metrics`
    |
463 |     @pytest.mark.asyncio()
464 |     async def test_get_call_metrics(self, mock_supabase_client):
    |               ^^^^^^^^^^^^^^^^^^^^^ ANN201
465 |         # Configurar múltiples llamadas con diferentes estados y duraciones
466 |         calls_data = [
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:464:15: F811 Redefinition of unused `test_get_call_metrics` from line 409
    |
463 |     @pytest.mark.asyncio()
464 |     async def test_get_call_metrics(self, mock_supabase_client):
    |               ^^^^^^^^^^^^^^^^^^^^^ F811
465 |         # Configurar múltiples llamadas con diferentes estados y duraciones
466 |         calls_data = [
    |
    = help: Remove definition: `test_get_call_metrics`

backend-call-automation\tests\app\services\test_call_service.py:464:43: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
463 |     @pytest.mark.asyncio()
464 |     async def test_get_call_metrics(self, mock_supabase_client):
    |                                           ^^^^^^^^^^^^^^^^^^^^ ANN001
465 |         # Configurar múltiples llamadas con diferentes estados y duraciones
466 |         calls_data = [
    |

backend-call-automation\tests\app\services\test_call_service.py:472:31: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
470 |                 "status": CallStatus.COMPLETED.value,
471 |                 "duration": 120,
472 |                 "created_at": datetime.now().isoformat(),
    |                               ^^^^^^^^^^^^^^ DTZ005
473 |             },
474 |             {
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\tests\app\services\test_call_service.py:479:31: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
477 |                 "status": CallStatus.FAILED.value,
478 |                 "duration": None,
479 |                 "created_at": datetime.now().isoformat(),
    |                               ^^^^^^^^^^^^^^ DTZ005
480 |             },
481 |             {
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\tests\app\services\test_call_service.py:486:31: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
484 |                 "status": CallStatus.COMPLETED.value,
485 |                 "duration": 180,
486 |                 "created_at": datetime.now().isoformat(),
    |                               ^^^^^^^^^^^^^^ DTZ005
487 |             },
488 |         ]
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\tests\app\services\test_call_service.py:497:42: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
495 |         # Obtener métricas globales
496 |         metrics = await call_service.get_call_metrics()
497 |         assert metrics["total_calls"] == 3
    |                                          ^ PLR2004
498 |         assert metrics["average_duration"] == 150
499 |         assert metrics["status_counts"][CallStatus.COMPLETED] == 2
    |

backend-call-automation\tests\app\services\test_call_service.py:498:47: PLR2004 Magic value used in comparison, consider replacing `150` with a constant variable
    |
496 |         metrics = await call_service.get_call_metrics()
497 |         assert metrics["total_calls"] == 3
498 |         assert metrics["average_duration"] == 150
    |                                               ^^^ PLR2004
499 |         assert metrics["status_counts"][CallStatus.COMPLETED] == 2
500 |         assert metrics["status_counts"][CallStatus.FAILED] == 1
    |

backend-call-automation\tests\app\services\test_call_service.py:499:66: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
497 |         assert metrics["total_calls"] == 3
498 |         assert metrics["average_duration"] == 150
499 |         assert metrics["status_counts"][CallStatus.COMPLETED] == 2
    |                                                                  ^ PLR2004
500 |         assert metrics["status_counts"][CallStatus.FAILED] == 1
    |

backend-call-automation\tests\app\services\test_call_service.py:504:53: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
502 |         # Obtener métricas filtradas por campaña
503 |         metrics_campaign_1 = await call_service.get_call_metrics(campaign_id=1)
504 |         assert metrics_campaign_1["total_calls"] == 2
    |                                                     ^ PLR2004
505 |         assert metrics_campaign_1["status_counts"][CallStatus.COMPLETED] == 1
506 |         assert metrics_campaign_1["status_counts"][CallStatus.FAILED] == 1
    |

backend-call-automation\tests\app\services\test_call_service.py:513:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
511 |         assert metrics_campaign_2["status_counts"][CallStatus.FAILED] == 0
512 |
513 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
514 |     async def test_retry_mechanism(self, mock_twilio_client, mock_supabase_client):
515 |         # Configurar una llamada que fallará y será reintentada
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:514:15: ANN201 Missing return type annotation for public function `test_retry_mechanism`
    |
513 |     @pytest.mark.asyncio()
514 |     async def test_retry_mechanism(self, mock_twilio_client, mock_supabase_client):
    |               ^^^^^^^^^^^^^^^^^^^^ ANN201
515 |         # Configurar una llamada que fallará y será reintentada
516 |         call_data = {
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:514:42: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
513 |     @pytest.mark.asyncio()
514 |     async def test_retry_mechanism(self, mock_twilio_client, mock_supabase_client):
    |                                          ^^^^^^^^^^^^^^^^^^ ANN001
515 |         # Configurar una llamada que fallará y será reintentada
516 |         call_data = {
    |

backend-call-automation\tests\app\services\test_call_service.py:514:62: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
513 |     @pytest.mark.asyncio()
514 |     async def test_retry_mechanism(self, mock_twilio_client, mock_supabase_client):
    |                                                              ^^^^^^^^^^^^^^^^^^^^ ANN001
515 |         # Configurar una llamada que fallará y será reintentada
516 |         call_data = {
    |

backend-call-automation\tests\app\services\test_call_service.py:533:47: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
531 |         # Reintento exitoso después de fallo
532 |         retried_call = await call_service.retry_call(call_data["id"])
533 |         assert retried_call.retry_attempts == 2
    |                                               ^ PLR2004
534 |         assert retried_call.status == CallStatus.PENDING
    |

backend-call-automation\tests\app\services\test_call_service.py:539:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
537 |         call_data["retry_attempts"] = 3
538 |         mock_supabase_client.set_responses(call_data)
539 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
540 |             await call_service.retry_call(call_data["id"])
    |

backend-call-automation\tests\app\services\test_call_service.py:546:47: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
544 |         mock_supabase_client.set_responses(call_data)
545 |         retried_call = await call_service.retry_call(call_data["id"])
546 |         assert retried_call.retry_attempts == 2
    |                                               ^ PLR2004
547 |
548 |         # Estado final después de reintento exitoso/fallido
    |

backend-call-automation\tests\app\services\test_call_service.py:554:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
552 |         assert retried_call.status == CallStatus.COMPLETED
553 |
554 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
555 |     async def test_campaign_stats_update(self, mock_supabase_client):
556 |         # Configurar campaña inicial
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:555:15: ANN201 Missing return type annotation for public function `test_campaign_stats_update`
    |
554 |     @pytest.mark.asyncio()
555 |     async def test_campaign_stats_update(self, mock_supabase_client):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
556 |         # Configurar campaña inicial
557 |         campaign_data = {"id": 1, "total_calls": 10, "successful_calls": 5}
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:555:48: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
554 |     @pytest.mark.asyncio()
555 |     async def test_campaign_stats_update(self, mock_supabase_client):
    |                                                ^^^^^^^^^^^^^^^^^^^^ ANN001
556 |         # Configurar campaña inicial
557 |         campaign_data = {"id": 1, "total_calls": 10, "successful_calls": 5}
    |

backend-call-automation\tests\app\services\test_call_service.py:567:48: PLR2004 Magic value used in comparison, consider replacing `11` with a constant variable
    |
565 |         await call_service.update_campaign_stats(1, CallStatus.COMPLETED)
566 |         updated_campaign = await call_service.get_campaign(1)
567 |         assert updated_campaign.total_calls == 11
    |                                                ^^ PLR2004
568 |         assert updated_campaign.successful_calls == 6
    |

backend-call-automation\tests\app\services\test_call_service.py:568:53: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
    |
566 |         updated_campaign = await call_service.get_campaign(1)
567 |         assert updated_campaign.total_calls == 11
568 |         assert updated_campaign.successful_calls == 6
    |                                                     ^ PLR2004
569 |
570 |         # Actualización después de llamada fallida
    |

backend-call-automation\tests\app\services\test_call_service.py:573:48: PLR2004 Magic value used in comparison, consider replacing `12` with a constant variable
    |
571 |         await call_service.update_campaign_stats(1, CallStatus.FAILED)
572 |         updated_campaign = await call_service.get_campaign(1)
573 |         assert updated_campaign.total_calls == 12
    |                                                ^^ PLR2004
574 |         assert updated_campaign.successful_calls == 6
    |

backend-call-automation\tests\app\services\test_call_service.py:574:53: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
    |
572 |         updated_campaign = await call_service.get_campaign(1)
573 |         assert updated_campaign.total_calls == 12
574 |         assert updated_campaign.successful_calls == 6
    |                                                     ^ PLR2004
575 |
576 |         # Manejo de estados intermedios
    |

backend-call-automation\tests\app\services\test_call_service.py:579:48: PLR2004 Magic value used in comparison, consider replacing `13` with a constant variable
    |
577 |         await call_service.update_campaign_stats(1, CallStatus.IN_PROGRESS)
578 |         updated_campaign = await call_service.get_campaign(1)
579 |         assert updated_campaign.total_calls == 13
    |                                                ^^ PLR2004
580 |         assert updated_campaign.successful_calls == 6
    |

backend-call-automation\tests\app\services\test_call_service.py:580:53: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
    |
578 |         updated_campaign = await call_service.get_campaign(1)
579 |         assert updated_campaign.total_calls == 13
580 |         assert updated_campaign.successful_calls == 6
    |                                                     ^ PLR2004
581 |
582 |         # Concurrencia en actualizaciones
    |

backend-call-automation\tests\app\services\test_call_service.py:584:15: F821 Undefined name `asyncio`
    |
582 |         # Concurrencia en actualizaciones
583 |         # Simular múltiples actualizaciones concurrentes
584 |         await asyncio.gather(
    |               ^^^^^^^ F821
585 |             call_service.update_campaign_stats(1, CallStatus.COMPLETED),
586 |             call_service.update_campaign_stats(1, CallStatus.FAILED),
    |

backend-call-automation\tests\app\services\test_call_service.py:590:48: PLR2004 Magic value used in comparison, consider replacing `16` with a constant variable
    |
588 |         )
589 |         updated_campaign = await call_service.get_campaign(1)
590 |         assert updated_campaign.total_calls == 16
    |                                                ^^ PLR2004
591 |         assert updated_campaign.successful_calls == 7
    |

backend-call-automation\tests\app\services\test_call_service.py:591:53: PLR2004 Magic value used in comparison, consider replacing `7` with a constant variable
    |
589 |         updated_campaign = await call_service.get_campaign(1)
590 |         assert updated_campaign.total_calls == 16
591 |         assert updated_campaign.successful_calls == 7
    |                                                     ^ PLR2004
592 |
593 |     @pytest.mark.asyncio()
    |

backend-call-automation\tests\app\services\test_call_service.py:593:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
591 |         assert updated_campaign.successful_calls == 7
592 |
593 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
594 |     async def test_complete_call_flow(self, mock_twilio_client, mock_supabase_client):
595 |         """
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:594:15: ANN201 Missing return type annotation for public function `test_complete_call_flow`
    |
593 |     @pytest.mark.asyncio()
594 |     async def test_complete_call_flow(self, mock_twilio_client, mock_supabase_client):
    |               ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
595 |         """
596 |         Prueba el flujo completo de una llamada desde su creación hasta su finalización.
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:594:45: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
593 |     @pytest.mark.asyncio()
594 |     async def test_complete_call_flow(self, mock_twilio_client, mock_supabase_client):
    |                                             ^^^^^^^^^^^^^^^^^^ ANN001
595 |         """
596 |         Prueba el flujo completo de una llamada desde su creación hasta su finalización.
    |

backend-call-automation\tests\app\services\test_call_service.py:594:65: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
593 |     @pytest.mark.asyncio()
594 |     async def test_complete_call_flow(self, mock_twilio_client, mock_supabase_client):
    |                                                                 ^^^^^^^^^^^^^^^^^^^^ ANN001
595 |         """
596 |         Prueba el flujo completo de una llamada desde su creación hasta su finalización.
    |

backend-call-automation\tests\app\services\test_call_service.py:628:27: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
626 |             "status_callback_url": "http://example.com/callback",
627 |             "status": CallStatus.PENDING.value,
628 |             "created_at": datetime.now().isoformat(),
    |                           ^^^^^^^^^^^^^^ DTZ005
629 |             "updated_at": datetime.now().isoformat(),
630 |             "twilio_sid": None,
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\tests\app\services\test_call_service.py:629:27: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
627 |             "status": CallStatus.PENDING.value,
628 |             "created_at": datetime.now().isoformat(),
629 |             "updated_at": datetime.now().isoformat(),
    |                           ^^^^^^^^^^^^^^ DTZ005
630 |             "twilio_sid": None,
631 |             "duration": None,
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\tests\app\services\test_call_service.py:698:41: PLR2004 Magic value used in comparison, consider replacing `120` with a constant variable
    |
697 |         assert updated_call.status == CallStatus.COMPLETED
698 |         assert updated_call.duration == 120
    |                                         ^^^ PLR2004
699 |         assert updated_call.recording_url == "http://example.com/recording.mp3"
    |

backend-call-automation\tests\app\services\test_call_service.py:701:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
699 |         assert updated_call.recording_url == "http://example.com/recording.mp3"
700 |
701 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
702 |     async def test_retry_mechanism(self, mock_twilio_client, mock_supabase_client, test_campaign):
703 |         """
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:702:15: ANN201 Missing return type annotation for public function `test_retry_mechanism`
    |
701 |     @pytest.mark.asyncio()
702 |     async def test_retry_mechanism(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |               ^^^^^^^^^^^^^^^^^^^^ ANN201
703 |         """
704 |         Verifica el sistema de reintentos automáticos
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:702:15: F811 Redefinition of unused `test_retry_mechanism` from line 514
    |
701 |     @pytest.mark.asyncio()
702 |     async def test_retry_mechanism(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |               ^^^^^^^^^^^^^^^^^^^^ F811
703 |         """
704 |         Verifica el sistema de reintentos automáticos
    |
    = help: Remove definition: `test_retry_mechanism`

backend-call-automation\tests\app\services\test_call_service.py:702:42: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
701 |     @pytest.mark.asyncio()
702 |     async def test_retry_mechanism(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                          ^^^^^^^^^^^^^^^^^^ ANN001
703 |         """
704 |         Verifica el sistema de reintentos automáticos
    |

backend-call-automation\tests\app\services\test_call_service.py:702:62: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
701 |     @pytest.mark.asyncio()
702 |     async def test_retry_mechanism(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                              ^^^^^^^^^^^^^^^^^^^^ ANN001
703 |         """
704 |         Verifica el sistema de reintentos automáticos
    |

backend-call-automation\tests\app\services\test_call_service.py:702:84: ANN001 Missing type annotation for function argument `test_campaign`
    |
701 |     @pytest.mark.asyncio()
702 |     async def test_retry_mechanism(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                                                    ^^^^^^^^^^^^^ ANN001
703 |         """
704 |         Verifica el sistema de reintentos automáticos
    |

backend-call-automation\tests\app\services\test_call_service.py:740:47: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
738 |         await call_service.update_call_status(retried_call.id, status=CallStatus.FAILED)
739 |         retried_call = await call_service.retry_call(call.id)
740 |         assert retried_call.retry_attempts == 2
    |                                               ^ PLR2004
741 |
742 |         # Third retry (should succeed)
    |

backend-call-automation\tests\app\services\test_call_service.py:749:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
747 |         assert updated_call.status == CallStatus.COMPLETED
748 |
749 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
750 |     async def test_error_scenarios(self, mock_twilio_client, mock_supabase_client, test_campaign):
751 |         """
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:750:15: ANN201 Missing return type annotation for public function `test_error_scenarios`
    |
749 |     @pytest.mark.asyncio()
750 |     async def test_error_scenarios(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |               ^^^^^^^^^^^^^^^^^^^^ ANN201
751 |         """
752 |         Valida el manejo de errores del servicio
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:750:42: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
749 |     @pytest.mark.asyncio()
750 |     async def test_error_scenarios(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                          ^^^^^^^^^^^^^^^^^^ ANN001
751 |         """
752 |         Valida el manejo de errores del servicio
    |

backend-call-automation\tests\app\services\test_call_service.py:750:62: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
749 |     @pytest.mark.asyncio()
750 |     async def test_error_scenarios(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                              ^^^^^^^^^^^^^^^^^^^^ ANN001
751 |         """
752 |         Valida el manejo de errores del servicio
    |

backend-call-automation\tests\app\services\test_call_service.py:750:84: ANN001 Missing type annotation for function argument `test_campaign`
    |
749 |     @pytest.mark.asyncio()
750 |     async def test_error_scenarios(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                                                    ^^^^^^^^^^^^^ ANN001
751 |         """
752 |         Valida el manejo de errores del servicio
    |

backend-call-automation\tests\app\services\test_call_service.py:775:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
773 |         # 1. Reintento en llamada completada
774 |         await call_service.update_call_status(call.id, status=CallStatus.COMPLETED)
775 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
776 |             await call_service.retry_call(call.id)
    |

backend-call-automation\tests\app\services\test_call_service.py:780:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
778 |         # 2. Actualización con campaña inactiva
779 |         test_campaign.status = "inactive"
780 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
781 |             await call_service.update_call_status(call.id, status=CallStatus.COMPLETED)
    |

backend-call-automation\tests\app\services\test_call_service.py:784:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
783 |         # 3. Estados inválidos de Twilio
784 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
785 |             await call_service.update_call_status(call.id, status="invalid_status")
    |

backend-call-automation\tests\app\services\test_call_service.py:787:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
785 |             await call_service.update_call_status(call.id, status="invalid_status")
786 |
787 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
788 |     async def test_handle_webhook_error(self, mock_twilio_client, mock_supabase_client):
789 |         """Test handling Twilio webhook errors"""
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:788:15: ANN201 Missing return type annotation for public function `test_handle_webhook_error`
    |
787 |     @pytest.mark.asyncio()
788 |     async def test_handle_webhook_error(self, mock_twilio_client, mock_supabase_client):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
789 |         """Test handling Twilio webhook errors"""
790 |         call_service = CallService(
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:788:47: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
787 |     @pytest.mark.asyncio()
788 |     async def test_handle_webhook_error(self, mock_twilio_client, mock_supabase_client):
    |                                               ^^^^^^^^^^^^^^^^^^ ANN001
789 |         """Test handling Twilio webhook errors"""
790 |         call_service = CallService(
    |

backend-call-automation\tests\app\services\test_call_service.py:788:67: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
787 |     @pytest.mark.asyncio()
788 |     async def test_handle_webhook_error(self, mock_twilio_client, mock_supabase_client):
    |                                                                   ^^^^^^^^^^^^^^^^^^^^ ANN001
789 |         """Test handling Twilio webhook errors"""
790 |         call_service = CallService(
    |

backend-call-automation\tests\app\services\test_call_service.py:803:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
801 |         assert "Error al obtener estado de llamada en Twilio" in str(exc_info.value.detail)
802 |
803 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
804 |     async def test_handle_webhook_not_found(self, mock_twilio_client, mock_supabase_client):
805 |         """Test handling webhook for non-existent call"""
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:804:15: ANN201 Missing return type annotation for public function `test_handle_webhook_not_found`
    |
803 |     @pytest.mark.asyncio()
804 |     async def test_handle_webhook_not_found(self, mock_twilio_client, mock_supabase_client):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
805 |         """Test handling webhook for non-existent call"""
806 |         call_service = CallService(
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:804:51: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
803 |     @pytest.mark.asyncio()
804 |     async def test_handle_webhook_not_found(self, mock_twilio_client, mock_supabase_client):
    |                                                   ^^^^^^^^^^^^^^^^^^ ANN001
805 |         """Test handling webhook for non-existent call"""
806 |         call_service = CallService(
    |

backend-call-automation\tests\app\services\test_call_service.py:804:71: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
803 |     @pytest.mark.asyncio()
804 |     async def test_handle_webhook_not_found(self, mock_twilio_client, mock_supabase_client):
    |                                                                       ^^^^^^^^^^^^^^^^^^^^ ANN001
805 |         """Test handling webhook for non-existent call"""
806 |         call_service = CallService(
    |

backend-call-automation\tests\app\services\test_call_service.py:819:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
817 |         assert "Llamada no encontrada" in str(exc_info.value.detail)
818 |
819 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
820 |     async def test_update_call_status(
821 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:820:15: ANN201 Missing return type annotation for public function `test_update_call_status`
    |
819 |     @pytest.mark.asyncio()
820 |     async def test_update_call_status(
    |               ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
821 |         self, mock_twilio_client, mock_supabase_client, test_campaign
822 |     ):
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:820:15: F811 Redefinition of unused `test_update_call_status` from line 368
    |
819 |     @pytest.mark.asyncio()
820 |     async def test_update_call_status(
    |               ^^^^^^^^^^^^^^^^^^^^^^^ F811
821 |         self, mock_twilio_client, mock_supabase_client, test_campaign
822 |     ):
    |
    = help: Remove definition: `test_update_call_status`

backend-call-automation\tests\app\services\test_call_service.py:821:15: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
819 |     @pytest.mark.asyncio()
820 |     async def test_update_call_status(
821 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |               ^^^^^^^^^^^^^^^^^^ ANN001
822 |     ):
823 |         """Prueba la actualización de estados de llamada"""
    |

backend-call-automation\tests\app\services\test_call_service.py:821:35: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
819 |     @pytest.mark.asyncio()
820 |     async def test_update_call_status(
821 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |                                   ^^^^^^^^^^^^^^^^^^^^ ANN001
822 |     ):
823 |         """Prueba la actualización de estados de llamada"""
    |

backend-call-automation\tests\app\services\test_call_service.py:821:57: ANN001 Missing type annotation for function argument `test_campaign`
    |
819 |     @pytest.mark.asyncio()
820 |     async def test_update_call_status(
821 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |                                                         ^^^^^^^^^^^^^ ANN001
822 |     ):
823 |         """Prueba la actualización de estados de llamada"""
    |

backend-call-automation\tests\app\services\test_call_service.py:821:57: ARG002 Unused method argument: `test_campaign`
    |
819 |     @pytest.mark.asyncio()
820 |     async def test_update_call_status(
821 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |                                                         ^^^^^^^^^^^^^ ARG002
822 |     ):
823 |         """Prueba la actualización de estados de llamada"""
    |

backend-call-automation\tests\app\services\test_call_service.py:837:41: PLR2004 Magic value used in comparison, consider replacing `120` with a constant variable
    |
835 |         updated_call = await call_service.update_call_status("TEST_SID_12345", call_update)
836 |         assert updated_call.status == CallStatus.COMPLETED
837 |         assert updated_call.duration == 120
    |                                         ^^^ PLR2004
838 |
839 |         # Caso 2: Estado inválido
    |

backend-call-automation\tests\app\services\test_call_service.py:840:9: PT012 `pytest.raises()` block should contain a single simple statement
    |
839 |           # Caso 2: Estado inválido
840 | /         with pytest.raises(HTTPException) as exc_info:
841 | |             invalid_update = CallUpdate(status="INVALID_STATUS")
842 | |             await call_service.update_call_status("TEST_SID_12345", invalid_update)
    | |___________________________________________________________________________________^ PT012
843 |           assert exc_info.value.status_code == status.HTTP_400_BAD_REQUEST
    |

backend-call-automation\tests\app\services\test_call_service.py:850:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
848 |         assert exc_info.value.status_code == status.HTTP_404_NOT_FOUND
849 |
850 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
851 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
852 |         """Prueba la obtención de métricas de llamadas"""
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:851:15: ANN201 Missing return type annotation for public function `test_get_call_metrics`
    |
850 |     @pytest.mark.asyncio()
851 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |               ^^^^^^^^^^^^^^^^^^^^^ ANN201
852 |         """Prueba la obtención de métricas de llamadas"""
853 |         call_service = CallService(
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:851:15: F811 Redefinition of unused `test_get_call_metrics` from line 464
    |
850 |     @pytest.mark.asyncio()
851 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |               ^^^^^^^^^^^^^^^^^^^^^ F811
852 |         """Prueba la obtención de métricas de llamadas"""
853 |         call_service = CallService(
    |
    = help: Remove definition: `test_get_call_metrics`

backend-call-automation\tests\app\services\test_call_service.py:851:43: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
850 |     @pytest.mark.asyncio()
851 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                           ^^^^^^^^^^^^^^^^^^ ANN001
852 |         """Prueba la obtención de métricas de llamadas"""
853 |         call_service = CallService(
    |

backend-call-automation\tests\app\services\test_call_service.py:851:63: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
850 |     @pytest.mark.asyncio()
851 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                               ^^^^^^^^^^^^^^^^^^^^ ANN001
852 |         """Prueba la obtención de métricas de llamadas"""
853 |         call_service = CallService(
    |

backend-call-automation\tests\app\services\test_call_service.py:851:85: ANN001 Missing type annotation for function argument `test_campaign`
    |
850 |     @pytest.mark.asyncio()
851 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                                                     ^^^^^^^^^^^^^ ANN001
852 |         """Prueba la obtención de métricas de llamadas"""
853 |         call_service = CallService(
    |

backend-call-automation\tests\app\services\test_call_service.py:851:85: ARG002 Unused method argument: `test_campaign`
    |
850 |     @pytest.mark.asyncio()
851 |     async def test_get_call_metrics(self, mock_twilio_client, mock_supabase_client, test_campaign):
    |                                                                                     ^^^^^^^^^^^^^ ARG002
852 |         """Prueba la obtención de métricas de llamadas"""
853 |         call_service = CallService(
    |

backend-call-automation\tests\app\services\test_call_service.py:872:39: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
871 |         # Validar métricas
872 |         assert metrics.total_calls == 4
    |                                       ^ PLR2004
873 |         assert metrics.successful_calls == 2
874 |         assert metrics.failed_calls == 1
    |

backend-call-automation\tests\app\services\test_call_service.py:873:44: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
871 |         # Validar métricas
872 |         assert metrics.total_calls == 4
873 |         assert metrics.successful_calls == 2
    |                                            ^ PLR2004
874 |         assert metrics.failed_calls == 1
875 |         assert metrics.no_answer_calls == 1
    |

backend-call-automation\tests\app\services\test_call_service.py:876:44: PLR2004 Magic value used in comparison, consider replacing `150` with a constant variable
    |
874 |         assert metrics.failed_calls == 1
875 |         assert metrics.no_answer_calls == 1
876 |         assert metrics.average_duration == 150  # (120 + 180) / 2
    |                                            ^^^ PLR2004
877 |
878 |     @pytest.mark.asyncio()
    |

backend-call-automation\tests\app\services\test_call_service.py:878:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
876 |         assert metrics.average_duration == 150  # (120 + 180) / 2
877 |
878 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
879 |     async def test_campaign_validation(
880 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_call_service.py:879:15: ANN201 Missing return type annotation for public function `test_campaign_validation`
    |
878 |     @pytest.mark.asyncio()
879 |     async def test_campaign_validation(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
880 |         self, mock_twilio_client, mock_supabase_client, test_campaign
881 |     ):
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_call_service.py:880:15: ANN001 Missing type annotation for function argument `mock_twilio_client`
    |
878 |     @pytest.mark.asyncio()
879 |     async def test_campaign_validation(
880 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |               ^^^^^^^^^^^^^^^^^^ ANN001
881 |     ):
882 |         """Prueba la validación de campaña al crear llamadas"""
    |

backend-call-automation\tests\app\services\test_call_service.py:880:35: ANN001 Missing type annotation for function argument `mock_supabase_client`
    |
878 |     @pytest.mark.asyncio()
879 |     async def test_campaign_validation(
880 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |                                   ^^^^^^^^^^^^^^^^^^^^ ANN001
881 |     ):
882 |         """Prueba la validación de campaña al crear llamadas"""
    |

backend-call-automation\tests\app\services\test_call_service.py:880:57: ANN001 Missing type annotation for function argument `test_campaign`
    |
878 |     @pytest.mark.asyncio()
879 |     async def test_campaign_validation(
880 |         self, mock_twilio_client, mock_supabase_client, test_campaign
    |                                                         ^^^^^^^^^^^^^ ANN001
881 |     ):
882 |         """Prueba la validación de campaña al crear llamadas"""
    |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:14:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
14 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
15 | def mock_campaign_service():
16 |     return AsyncMock(spec=CampaignService)
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_scheduler.py:15:5: ANN201 Missing return type annotation for public function `mock_campaign_service`
   |
14 | @pytest.fixture()
15 | def mock_campaign_service():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
16 |     return AsyncMock(spec=CampaignService)
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_campaign_scheduler.py:19:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
19 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
20 | def mock_call_service():
21 |     return AsyncMock(spec=CallService)
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_scheduler.py:20:5: ANN201 Missing return type annotation for public function `mock_call_service`
   |
19 | @pytest.fixture()
20 | def mock_call_service():
   |     ^^^^^^^^^^^^^^^^^ ANN201
21 |     return AsyncMock(spec=CallService)
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_campaign_scheduler.py:24:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
24 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
25 | def mock_contact_service():
26 |     return AsyncMock(spec=ContactService)
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_scheduler.py:25:5: ANN201 Missing return type annotation for public function `mock_contact_service`
   |
24 | @pytest.fixture()
25 | def mock_contact_service():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
26 |     return AsyncMock(spec=ContactService)
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_campaign_scheduler.py:29:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
29 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
30 | def campaign_scheduler(mock_campaign_service, mock_call_service, mock_contact_service):
31 |     return CampaignScheduler(
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_scheduler.py:30:5: ANN201 Missing return type annotation for public function `campaign_scheduler`
   |
29 | @pytest.fixture()
30 | def campaign_scheduler(mock_campaign_service, mock_call_service, mock_contact_service):
   |     ^^^^^^^^^^^^^^^^^^ ANN201
31 |     return CampaignScheduler(
32 |         campaign_service=mock_campaign_service,
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_campaign_scheduler.py:30:24: ANN001 Missing type annotation for function argument `mock_campaign_service`
   |
29 | @pytest.fixture()
30 | def campaign_scheduler(mock_campaign_service, mock_call_service, mock_contact_service):
   |                        ^^^^^^^^^^^^^^^^^^^^^ ANN001
31 |     return CampaignScheduler(
32 |         campaign_service=mock_campaign_service,
   |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:30:47: ANN001 Missing type annotation for function argument `mock_call_service`
   |
29 | @pytest.fixture()
30 | def campaign_scheduler(mock_campaign_service, mock_call_service, mock_contact_service):
   |                                               ^^^^^^^^^^^^^^^^^ ANN001
31 |     return CampaignScheduler(
32 |         campaign_service=mock_campaign_service,
   |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:30:66: ANN001 Missing type annotation for function argument `mock_contact_service`
   |
29 | @pytest.fixture()
30 | def campaign_scheduler(mock_campaign_service, mock_call_service, mock_contact_service):
   |                                                                  ^^^^^^^^^^^^^^^^^^^^ ANN001
31 |     return CampaignScheduler(
32 |         campaign_service=mock_campaign_service,
   |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:39:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
39 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
40 | async def test_start_stop(campaign_scheduler):
41 |     await campaign_scheduler.start()
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_scheduler.py:40:11: ANN201 Missing return type annotation for public function `test_start_stop`
   |
39 | @pytest.mark.asyncio()
40 | async def test_start_stop(campaign_scheduler):
   |           ^^^^^^^^^^^^^^^ ANN201
41 |     await campaign_scheduler.start()
42 |     assert campaign_scheduler.is_running
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_scheduler.py:40:27: ANN001 Missing type annotation for function argument `campaign_scheduler`
   |
39 | @pytest.mark.asyncio()
40 | async def test_start_stop(campaign_scheduler):
   |                           ^^^^^^^^^^^^^^^^^^ ANN001
41 |     await campaign_scheduler.start()
42 |     assert campaign_scheduler.is_running
   |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:47:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
47 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
48 | async def test_process_active_campaigns(
49 |     campaign_scheduler, mock_campaign_service, mock_contact_service
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_scheduler.py:48:11: ANN201 Missing return type annotation for public function `test_process_active_campaigns`
   |
47 | @pytest.mark.asyncio()
48 | async def test_process_active_campaigns(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
49 |     campaign_scheduler, mock_campaign_service, mock_contact_service
50 | ):
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_scheduler.py:49:5: ANN001 Missing type annotation for function argument `campaign_scheduler`
   |
47 | @pytest.mark.asyncio()
48 | async def test_process_active_campaigns(
49 |     campaign_scheduler, mock_campaign_service, mock_contact_service
   |     ^^^^^^^^^^^^^^^^^^ ANN001
50 | ):
51 |     now = datetime.now()
   |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:49:25: ANN001 Missing type annotation for function argument `mock_campaign_service`
   |
47 | @pytest.mark.asyncio()
48 | async def test_process_active_campaigns(
49 |     campaign_scheduler, mock_campaign_service, mock_contact_service
   |                         ^^^^^^^^^^^^^^^^^^^^^ ANN001
50 | ):
51 |     now = datetime.now()
   |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:49:48: ANN001 Missing type annotation for function argument `mock_contact_service`
   |
47 | @pytest.mark.asyncio()
48 | async def test_process_active_campaigns(
49 |     campaign_scheduler, mock_campaign_service, mock_contact_service
   |                                                ^^^^^^^^^^^^^^^^^^^^ ANN001
50 | ):
51 |     now = datetime.now()
   |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:51:11: DTZ005 `datetime.datetime.now()` called without a `tz` argument
   |
49 |     campaign_scheduler, mock_campaign_service, mock_contact_service
50 | ):
51 |     now = datetime.now()
   |           ^^^^^^^^^^^^^^ DTZ005
52 |     campaign = Campaign(
53 |         id=1,
   |
   = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\tests\app\services\test_campaign_scheduler.py:76:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
76 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
77 | async def test_retry_failed_calls(campaign_scheduler, mock_call_service, mock_campaign_service):
78 |     now = datetime.now()
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_scheduler.py:77:11: ANN201 Missing return type annotation for public function `test_retry_failed_calls`
   |
76 | @pytest.mark.asyncio()
77 | async def test_retry_failed_calls(campaign_scheduler, mock_call_service, mock_campaign_service):
   |           ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
78 |     now = datetime.now()
79 |     call = Call(
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_scheduler.py:77:35: ANN001 Missing type annotation for function argument `campaign_scheduler`
   |
76 | @pytest.mark.asyncio()
77 | async def test_retry_failed_calls(campaign_scheduler, mock_call_service, mock_campaign_service):
   |                                   ^^^^^^^^^^^^^^^^^^ ANN001
78 |     now = datetime.now()
79 |     call = Call(
   |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:77:55: ANN001 Missing type annotation for function argument `mock_call_service`
   |
76 | @pytest.mark.asyncio()
77 | async def test_retry_failed_calls(campaign_scheduler, mock_call_service, mock_campaign_service):
   |                                                       ^^^^^^^^^^^^^^^^^ ANN001
78 |     now = datetime.now()
79 |     call = Call(
   |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:77:74: ANN001 Missing type annotation for function argument `mock_campaign_service`
   |
76 | @pytest.mark.asyncio()
77 | async def test_retry_failed_calls(campaign_scheduler, mock_call_service, mock_campaign_service):
   |                                                                          ^^^^^^^^^^^^^^^^^^^^^ ANN001
78 |     now = datetime.now()
79 |     call = Call(
   |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:78:11: DTZ005 `datetime.datetime.now()` called without a `tz` argument
   |
76 | @pytest.mark.asyncio()
77 | async def test_retry_failed_calls(campaign_scheduler, mock_call_service, mock_campaign_service):
78 |     now = datetime.now()
   |           ^^^^^^^^^^^^^^ DTZ005
79 |     call = Call(
80 |         id=1,
   |
   = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\tests\app\services\test_campaign_scheduler.py:117:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
117 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
118 | async def test_update_campaign_stats(campaign_scheduler, mock_call_service, mock_campaign_service):
119 |     campaign_id = 1
    |
    = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_scheduler.py:118:11: ANN201 Missing return type annotation for public function `test_update_campaign_stats`
    |
117 | @pytest.mark.asyncio()
118 | async def test_update_campaign_stats(campaign_scheduler, mock_call_service, mock_campaign_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
119 |     campaign_id = 1
120 |     metrics = {"total_calls": 10, "completed_calls": 8, "failed_calls": 2, "pending_calls": 0}
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_scheduler.py:118:38: ANN001 Missing type annotation for function argument `campaign_scheduler`
    |
117 | @pytest.mark.asyncio()
118 | async def test_update_campaign_stats(campaign_scheduler, mock_call_service, mock_campaign_service):
    |                                      ^^^^^^^^^^^^^^^^^^ ANN001
119 |     campaign_id = 1
120 |     metrics = {"total_calls": 10, "completed_calls": 8, "failed_calls": 2, "pending_calls": 0}
    |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:118:58: ANN001 Missing type annotation for function argument `mock_call_service`
    |
117 | @pytest.mark.asyncio()
118 | async def test_update_campaign_stats(campaign_scheduler, mock_call_service, mock_campaign_service):
    |                                                          ^^^^^^^^^^^^^^^^^ ANN001
119 |     campaign_id = 1
120 |     metrics = {"total_calls": 10, "completed_calls": 8, "failed_calls": 2, "pending_calls": 0}
    |

backend-call-automation\tests\app\services\test_campaign_scheduler.py:118:77: ANN001 Missing type annotation for function argument `mock_campaign_service`
    |
117 | @pytest.mark.asyncio()
118 | async def test_update_campaign_stats(campaign_scheduler, mock_call_service, mock_campaign_service):
    |                                                                             ^^^^^^^^^^^^^^^^^^^^^ ANN001
119 |     campaign_id = 1
120 |     metrics = {"total_calls": 10, "completed_calls": 8, "failed_calls": 2, "pending_calls": 0}
    |

backend-call-automation\tests\app\services\test_campaign_service.py:13:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
13 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
14 | async def test_create_campaign(campaign_service: CampaignService, mock_campaign_data):
15 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_service.py:14:11: ANN201 Missing return type annotation for public function `test_create_campaign`
   |
13 | @pytest.mark.asyncio()
14 | async def test_create_campaign(campaign_service: CampaignService, mock_campaign_data):
   |           ^^^^^^^^^^^^^^^^^^^^ ANN201
15 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
16 |     assert campaign.name == mock_campaign_data["name"]
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_service.py:14:67: ANN001 Missing type annotation for function argument `mock_campaign_data`
   |
13 | @pytest.mark.asyncio()
14 | async def test_create_campaign(campaign_service: CampaignService, mock_campaign_data):
   |                                                                   ^^^^^^^^^^^^^^^^^^ ANN001
15 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
16 |     assert campaign.name == mock_campaign_data["name"]
   |

backend-call-automation\tests\app\services\test_campaign_service.py:30:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
30 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
31 | async def test_get_campaign(campaign_service: CampaignService, mock_campaign_data):
32 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_service.py:31:11: ANN201 Missing return type annotation for public function `test_get_campaign`
   |
30 | @pytest.mark.asyncio()
31 | async def test_get_campaign(campaign_service: CampaignService, mock_campaign_data):
   |           ^^^^^^^^^^^^^^^^^ ANN201
32 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
33 |     retrieved_campaign = await campaign_service.get_campaign(campaign.id)
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_service.py:31:64: ANN001 Missing type annotation for function argument `mock_campaign_data`
   |
30 | @pytest.mark.asyncio()
31 | async def test_get_campaign(campaign_service: CampaignService, mock_campaign_data):
   |                                                                ^^^^^^^^^^^^^^^^^^ ANN001
32 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
33 |     retrieved_campaign = await campaign_service.get_campaign(campaign.id)
   |

backend-call-automation\tests\app\services\test_campaign_service.py:38:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
38 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
39 | async def test_get_nonexistent_campaign(campaign_service: CampaignService):
40 |     with pytest.raises(HTTPException) as exc:
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_service.py:39:11: ANN201 Missing return type annotation for public function `test_get_nonexistent_campaign`
   |
38 | @pytest.mark.asyncio()
39 | async def test_get_nonexistent_campaign(campaign_service: CampaignService):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
40 |     with pytest.raises(HTTPException) as exc:
41 |         await campaign_service.get_campaign(999)
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_service.py:42:37: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
   |
40 |     with pytest.raises(HTTPException) as exc:
41 |         await campaign_service.get_campaign(999)
42 |     assert exc.value.status_code == 404
   |                                     ^^^ PLR2004
   |

backend-call-automation\tests\app\services\test_campaign_service.py:45:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
45 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
46 | async def test_list_campaigns_with_pagination(
47 |     campaign_service: CampaignService, mock_campaign_data
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_service.py:46:11: ANN201 Missing return type annotation for public function `test_list_campaigns_with_pagination`
   |
45 | @pytest.mark.asyncio()
46 | async def test_list_campaigns_with_pagination(
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
47 |     campaign_service: CampaignService, mock_campaign_data
48 | ):
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_service.py:47:40: ANN001 Missing type annotation for function argument `mock_campaign_data`
   |
45 | @pytest.mark.asyncio()
46 | async def test_list_campaigns_with_pagination(
47 |     campaign_service: CampaignService, mock_campaign_data
   |                                        ^^^^^^^^^^^^^^^^^^ ANN001
48 | ):
49 |     for i in range(15):
   |

backend-call-automation\tests\app\services\test_campaign_service.py:49:9: B007 Loop control variable `i` not used within loop body
   |
47 |     campaign_service: CampaignService, mock_campaign_data
48 | ):
49 |     for i in range(15):
   |         ^ B007
50 |         await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
51 |     campaigns = await campaign_service.list_campaigns(page=1, page_size=10)
   |
   = help: Rename unused `i` to `_i`

backend-call-automation\tests\app\services\test_campaign_service.py:52:30: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
50 |         await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
51 |     campaigns = await campaign_service.list_campaigns(page=1, page_size=10)
52 |     assert len(campaigns) == 10
   |                              ^^ PLR2004
   |

backend-call-automation\tests\app\services\test_campaign_service.py:55:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
55 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
56 | async def test_list_campaigns_with_filters(campaign_service: CampaignService, mock_campaign_data):
57 |     mock_campaign_data["status"] = "active"
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_service.py:56:11: ANN201 Missing return type annotation for public function `test_list_campaigns_with_filters`
   |
55 | @pytest.mark.asyncio()
56 | async def test_list_campaigns_with_filters(campaign_service: CampaignService, mock_campaign_data):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
57 |     mock_campaign_data["status"] = "active"
58 |     await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_service.py:56:79: ANN001 Missing type annotation for function argument `mock_campaign_data`
   |
55 | @pytest.mark.asyncio()
56 | async def test_list_campaigns_with_filters(campaign_service: CampaignService, mock_campaign_data):
   |                                                                               ^^^^^^^^^^^^^^^^^^ ANN001
57 |     mock_campaign_data["status"] = "active"
58 |     await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
   |

backend-call-automation\tests\app\services\test_campaign_service.py:65:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
65 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
66 | async def test_update_campaign(campaign_service: CampaignService, mock_campaign_data):
67 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_service.py:66:11: ANN201 Missing return type annotation for public function `test_update_campaign`
   |
65 | @pytest.mark.asyncio()
66 | async def test_update_campaign(campaign_service: CampaignService, mock_campaign_data):
   |           ^^^^^^^^^^^^^^^^^^^^ ANN201
67 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
68 |     update_data = CampaignUpdate(name="Updated Campaign", status="paused")
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_service.py:66:67: ANN001 Missing type annotation for function argument `mock_campaign_data`
   |
65 | @pytest.mark.asyncio()
66 | async def test_update_campaign(campaign_service: CampaignService, mock_campaign_data):
   |                                                                   ^^^^^^^^^^^^^^^^^^ ANN001
67 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
68 |     update_data = CampaignUpdate(name="Updated Campaign", status="paused")
   |

backend-call-automation\tests\app\services\test_campaign_service.py:74:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
74 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
75 | async def test_delete_campaign(campaign_service: CampaignService, mock_campaign_data):
76 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_service.py:75:11: ANN201 Missing return type annotation for public function `test_delete_campaign`
   |
74 | @pytest.mark.asyncio()
75 | async def test_delete_campaign(campaign_service: CampaignService, mock_campaign_data):
   |           ^^^^^^^^^^^^^^^^^^^^ ANN201
76 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
77 |     result = await campaign_service.delete_campaign(campaign.id)
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_service.py:75:67: ANN001 Missing type annotation for function argument `mock_campaign_data`
   |
74 | @pytest.mark.asyncio()
75 | async def test_delete_campaign(campaign_service: CampaignService, mock_campaign_data):
   |                                                                   ^^^^^^^^^^^^^^^^^^ ANN001
76 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
77 |     result = await campaign_service.delete_campaign(campaign.id)
   |

backend-call-automation\tests\app\services\test_campaign_service.py:81:37: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
   |
79 |     with pytest.raises(HTTPException) as exc:
80 |         await campaign_service.get_campaign(campaign.id)
81 |     assert exc.value.status_code == 404
   |                                     ^^^ PLR2004
   |

backend-call-automation\tests\app\services\test_campaign_service.py:84:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
84 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
85 | async def test_update_campaign_stats(campaign_service: CampaignService, mock_campaign_data):
86 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_service.py:85:11: ANN201 Missing return type annotation for public function `test_update_campaign_stats`
   |
84 | @pytest.mark.asyncio()
85 | async def test_update_campaign_stats(campaign_service: CampaignService, mock_campaign_data):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
86 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
87 |     stats = CampaignStats(total_calls=100, successful_calls=80, failed_calls=20, pending_calls=0)
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_service.py:85:73: ANN001 Missing type annotation for function argument `mock_campaign_data`
   |
84 | @pytest.mark.asyncio()
85 | async def test_update_campaign_stats(campaign_service: CampaignService, mock_campaign_data):
   |                                                                         ^^^^^^^^^^^^^^^^^^ ANN001
86 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
87 |     stats = CampaignStats(total_calls=100, successful_calls=80, failed_calls=20, pending_calls=0)
   |

backend-call-automation\tests\app\services\test_campaign_service.py:89:44: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
   |
87 |     stats = CampaignStats(total_calls=100, successful_calls=80, failed_calls=20, pending_calls=0)
88 |     updated_campaign = await campaign_service.update_campaign_stats(campaign.id, stats)
89 |     assert updated_campaign.total_calls == 100
   |                                            ^^^ PLR2004
90 |     assert updated_campaign.successful_calls == 80
91 |     assert updated_campaign.failed_calls == 20
   |

backend-call-automation\tests\app\services\test_campaign_service.py:90:49: PLR2004 Magic value used in comparison, consider replacing `80` with a constant variable
   |
88 |     updated_campaign = await campaign_service.update_campaign_stats(campaign.id, stats)
89 |     assert updated_campaign.total_calls == 100
90 |     assert updated_campaign.successful_calls == 80
   |                                                 ^^ PLR2004
91 |     assert updated_campaign.failed_calls == 20
92 |     assert updated_campaign.pending_calls == 0
   |

backend-call-automation\tests\app\services\test_campaign_service.py:91:45: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
   |
89 |     assert updated_campaign.total_calls == 100
90 |     assert updated_campaign.successful_calls == 80
91 |     assert updated_campaign.failed_calls == 20
   |                                             ^^ PLR2004
92 |     assert updated_campaign.pending_calls == 0
   |

backend-call-automation\tests\app\services\test_campaign_service.py:95:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
95 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
96 | async def test_invalid_campaign_stats(campaign_service: CampaignService, mock_campaign_data):
97 |     logger.info("Iniciando test de validación de estadísticas inválidas")
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_campaign_service.py:96:11: ANN201 Missing return type annotation for public function `test_invalid_campaign_stats`
   |
95 | @pytest.mark.asyncio()
96 | async def test_invalid_campaign_stats(campaign_service: CampaignService, mock_campaign_data):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
97 |     logger.info("Iniciando test de validación de estadísticas inválidas")
98 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_campaign_service.py:96:74: ANN001 Missing type annotation for function argument `mock_campaign_data`
   |
95 | @pytest.mark.asyncio()
96 | async def test_invalid_campaign_stats(campaign_service: CampaignService, mock_campaign_data):
   |                                                                          ^^^^^^^^^^^^^^^^^^ ANN001
97 |     logger.info("Iniciando test de validación de estadísticas inválidas")
98 |     campaign = await campaign_service.create_campaign(CampaignCreate(**mock_campaign_data))
   |

backend-call-automation\tests\app\services\test_campaign_service.py:101:5: PT012 `pytest.raises()` block should contain a single simple statement
    |
100 |       # Caso 1: Suma de llamadas exitosas y fallidas mayor que el total
101 | /     with pytest.raises(HTTPException) as exc:
102 | |         stats = CampaignStats(
103 | |             total_calls=50,
104 | |             successful_calls=40,
105 | |             failed_calls=20,  # 40 + 20 > 50
106 | |             pending_calls=0,
107 | |         )
108 | |         await campaign_service.update_campaign_stats(campaign.id, stats)
    | |________________________________________________________________________^ PT012
109 |       assert exc.value.status_code == 422
110 |       assert "Estadísticas inválidas" in str(exc.value.detail)
    |

backend-call-automation\tests\app\services\test_campaign_service.py:109:37: PLR2004 Magic value used in comparison, consider replacing `422` with a constant variable
    |
107 |         )
108 |         await campaign_service.update_campaign_stats(campaign.id, stats)
109 |     assert exc.value.status_code == 422
    |                                     ^^^ PLR2004
110 |     assert "Estadísticas inválidas" in str(exc.value.detail)
    |

backend-call-automation\tests\app\services\test_elevenlabs_service.py:9:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
 9 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
10 | async def elevenlabs_service():
11 |     service = ElevenLabsService()
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_elevenlabs_service.py:10:11: ANN201 Missing return type annotation for public function `elevenlabs_service`
   |
 9 | @pytest.fixture()
10 | async def elevenlabs_service():
   |           ^^^^^^^^^^^^^^^^^^ ANN201
11 |     service = ElevenLabsService()
12 |     service.api_key = "test_api_key"
   |
   = help: Add return type annotation

backend-call-automation\tests\app\services\test_elevenlabs_service.py:16:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
16 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
17 | class TestElevenLabsService:
18 |     async def test_initiate_outbound_call_success(self, elevenlabs_service):
   |
   = help: Remove parentheses

backend-call-automation\tests\app\services\test_elevenlabs_service.py:18:15: ANN201 Missing return type annotation for public function `test_initiate_outbound_call_success`
   |
16 | @pytest.mark.asyncio()
17 | class TestElevenLabsService:
18 |     async def test_initiate_outbound_call_success(self, elevenlabs_service):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
19 |         """Verifica que la llamada saliente se inicia correctamente"""
20 |         expected_payload = {
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_elevenlabs_service.py:18:57: ANN001 Missing type annotation for function argument `elevenlabs_service`
   |
16 | @pytest.mark.asyncio()
17 | class TestElevenLabsService:
18 |     async def test_initiate_outbound_call_success(self, elevenlabs_service):
   |                                                         ^^^^^^^^^^^^^^^^^^ ANN001
19 |         """Verifica que la llamada saliente se inicia correctamente"""
20 |         expected_payload = {
   |

backend-call-automation\tests\app\services\test_elevenlabs_service.py:45:15: ANN201 Missing return type annotation for public function `test_initiate_outbound_call_error`
   |
43 |             assert mock.calls.last.request.json() == expected_payload
44 |
45 |     async def test_initiate_outbound_call_error(self, elevenlabs_service):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
46 |         """Verifica el manejo correcto de errores de la API"""
47 |         with respx.mock(assert_all_mocked=True) as mock:
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_elevenlabs_service.py:45:55: ANN001 Missing type annotation for function argument `elevenlabs_service`
   |
43 |             assert mock.calls.last.request.json() == expected_payload
44 |
45 |     async def test_initiate_outbound_call_error(self, elevenlabs_service):
   |                                                       ^^^^^^^^^^^^^^^^^^ ANN001
46 |         """Verifica el manejo correcto de errores de la API"""
47 |         with respx.mock(assert_all_mocked=True) as mock:
   |

backend-call-automation\tests\app\services\test_elevenlabs_service.py:59:15: ANN201 Missing return type annotation for public function `test_initiate_outbound_call_with_prompt`
   |
57 |             assert "Invalid request" in str(exc_info.value)
58 |
59 |     async def test_initiate_outbound_call_with_prompt(self, elevenlabs_service):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
60 |         """Verifica que el prompt opcional se incluye correctamente"""
61 |         prompt = "Bienvenido a nuestra llamada de prueba"
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_elevenlabs_service.py:59:61: ANN001 Missing type annotation for function argument `elevenlabs_service`
   |
57 |             assert "Invalid request" in str(exc_info.value)
58 |
59 |     async def test_initiate_outbound_call_with_prompt(self, elevenlabs_service):
   |                                                             ^^^^^^^^^^^^^^^^^^ ANN001
60 |         """Verifica que el prompt opcional se incluye correctamente"""
61 |         prompt = "Bienvenido a nuestra llamada de prueba"
   |

backend-call-automation\tests\app\services\test_elevenlabs_service.py:74:15: ANN201 Missing return type annotation for public function `test_generate_audio_success`
   |
72 |             assert mock.calls.last.request.json()["prompt"] == prompt
73 |
74 |     async def test_generate_audio_success(self, elevenlabs_service):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
75 |         """Verifica generación de audio exitosa"""
76 |         with patch("app.services.elevenlabs_service.generate") as mock_generate:
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_elevenlabs_service.py:74:49: ANN001 Missing type annotation for function argument `elevenlabs_service`
   |
72 |             assert mock.calls.last.request.json()["prompt"] == prompt
73 |
74 |     async def test_generate_audio_success(self, elevenlabs_service):
   |                                                 ^^^^^^^^^^^^^^^^^^ ANN001
75 |         """Verifica generación de audio exitosa"""
76 |         with patch("app.services.elevenlabs_service.generate") as mock_generate:
   |

backend-call-automation\tests\app\services\test_elevenlabs_service.py:76:14: F821 Undefined name `patch`
   |
74 |     async def test_generate_audio_success(self, elevenlabs_service):
75 |         """Verifica generación de audio exitosa"""
76 |         with patch("app.services.elevenlabs_service.generate") as mock_generate:
   |              ^^^^^ F821
77 |             mock_generate.return_value = b"audio_data"
78 |             with patch(
   |

backend-call-automation\tests\app\services\test_elevenlabs_service.py:78:18: F821 Undefined name `patch`
   |
76 |         with patch("app.services.elevenlabs_service.generate") as mock_generate:
77 |             mock_generate.return_value = b"audio_data"
78 |             with patch(
   |                  ^^^^^ F821
79 |                 "app.services.elevenlabs_service.secrets_manager.get_elevenlabs_credentials",
80 |                 new_callable=AsyncMock,
   |

backend-call-automation\tests\app\services\test_elevenlabs_service.py:80:30: F821 Undefined name `AsyncMock`
   |
78 |             with patch(
79 |                 "app.services.elevenlabs_service.secrets_manager.get_elevenlabs_credentials",
80 |                 new_callable=AsyncMock,
   |                              ^^^^^^^^^ F821
81 |                 return_value={"api_key": "mock_api_key"},
82 |             ):
   |

backend-call-automation\tests\app\services\test_elevenlabs_service.py:86:15: ANN201 Missing return type annotation for public function `test_generate_audio_failure`
   |
84 |                 assert audio == b"audio_data"
85 |
86 |     async def test_generate_audio_failure(self, elevenlabs_service):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
87 |         """Verifica manejo de errores en generación de audio"""
88 |         with patch("app.services.elevenlabs_service.generate") as mock_generate:
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\app\services\test_elevenlabs_service.py:86:49: ANN001 Missing type annotation for function argument `elevenlabs_service`
   |
84 |                 assert audio == b"audio_data"
85 |
86 |     async def test_generate_audio_failure(self, elevenlabs_service):
   |                                                 ^^^^^^^^^^^^^^^^^^ ANN001
87 |         """Verifica manejo de errores en generación de audio"""
88 |         with patch("app.services.elevenlabs_service.generate") as mock_generate:
   |

backend-call-automation\tests\app\services\test_elevenlabs_service.py:88:14: F821 Undefined name `patch`
   |
86 |     async def test_generate_audio_failure(self, elevenlabs_service):
87 |         """Verifica manejo de errores en generación de audio"""
88 |         with patch("app.services.elevenlabs_service.generate") as mock_generate:
   |              ^^^^^ F821
89 |             mock_generate.side_effect = Exception("API Error")
90 |             with patch(
   |

backend-call-automation\tests\app\services\test_elevenlabs_service.py:90:13: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   |
88 |           with patch("app.services.elevenlabs_service.generate") as mock_generate:
89 |               mock_generate.side_effect = Exception("API Error")
90 | /             with patch(
91 | |                 "app.services.elevenlabs_service.secrets_manager.get_elevenlabs_credentials",
92 | |                 new_callable=AsyncMock,
93 | |                 return_value={"api_key": "mock_api_key"},
94 | |             ):
95 | |                 with pytest.raises(ElevenLabsAPIError):
   | |_______________________________________________________^ SIM117
96 |                       await elevenlabs_service.generate_audio("Test", "Bella")
   |
   = help: Combine `with` statements

backend-call-automation\tests\app\services\test_elevenlabs_service.py:90:18: F821 Undefined name `patch`
   |
88 |         with patch("app.services.elevenlabs_service.generate") as mock_generate:
89 |             mock_generate.side_effect = Exception("API Error")
90 |             with patch(
   |                  ^^^^^ F821
91 |                 "app.services.elevenlabs_service.secrets_manager.get_elevenlabs_credentials",
92 |                 new_callable=AsyncMock,
   |

backend-call-automation\tests\app\services\test_elevenlabs_service.py:92:30: F821 Undefined name `AsyncMock`
   |
90 |             with patch(
91 |                 "app.services.elevenlabs_service.secrets_manager.get_elevenlabs_credentials",
92 |                 new_callable=AsyncMock,
   |                              ^^^^^^^^^ F821
93 |                 return_value={"api_key": "mock_api_key"},
94 |             ):
   |

backend-call-automation\tests\conftest.py:9:101: E501 Line too long (104 > 100)
   |
 8 | # Configurar PYTHONPATH para asegurar que las importaciones funcionen correctamente
 9 | # Esto es crucial para resolver problemas como "ModuleNotFoundError: No module named 'app.dependencies'"
   |                                                                                                     ^^^^ E501
10 |
11 | # 1. Agregar el directorio raíz del proyecto al PYTHONPATH
   |

backend-call-automation\tests\conftest.py:32:101: E501 Line too long (101 > 100)
   |
31 | # Establecer variables de entorno críticas para el entorno de prueba
32 | # Estas variables deben definirse ANTES de importar cualquier módulo de la aplicación que las utilice
   |                                                                                                     ^ E501
33 | os.environ["TESTING"] = "1"
34 | os.environ["APP_ENV"] = "testing"
   |

backend-call-automation\tests\conftest.py:56:101: E501 Line too long (107 > 100)
   |
54 | os.environ["DEBUG"] = "True"
55 | os.environ["ENVIRONMENT"] = "testing"
56 | # Añadir variables de Vault si son necesarias para las pruebas, aunque secrets_manager debería ser mockeado
   |                                                                                                     ^^^^^^^ E501
57 | os.environ["VAULT_ADDR"] = "http://mock-vault:8200"
58 | os.environ["VAULT_TOKEN"] = "mock_vault_token"
   |

backend-call-automation\tests\conftest.py:61:1: E402 Module level import not at top of file
   |
60 | # Importar configuraciones y servicios DESPUÉS de establecer las variables de entorno
61 | from app.config.settings import Settings
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

backend-call-automation\tests\conftest.py:65:5: ANN201 Missing return type annotation for public function `mock_settings`
   |
64 | @pytest.fixture(scope="session", autouse=True)
65 | def mock_settings():
   |     ^^^^^^^^^^^^^ ANN201
66 |     """
67 |     Fixture que proporciona configuraciones mock para todas las pruebas.
   |
   = help: Add return type annotation

backend-call-automation\tests\conftest.py:72:66: N806 Variable `MockSettings` in function should be lowercase
   |
70 |     # Usar patch para mockear la clase Settings completa o la función get_settings
71 |     # Esto evita que Pydantic intente cargar y validar desde el entorno real durante las pruebas
72 |     with patch("app.config.settings.Settings", spec=Settings) as MockSettings:
   |                                                                  ^^^^^^^^^^^^ N806
73 |         mock_instance = MockSettings.return_value
74 |         # Configurar valores mock para los atributos de settings necesarios en las pruebas
   |

backend-call-automation\tests\conftest.py:97:101: E501 Line too long (116 > 100)
   |
95 |         mock_instance.DEBUG = os.environ["DEBUG"] == "True"
96 |         mock_instance.ENVIRONMENT = os.environ["ENVIRONMENT"]
97 |         yield mock_instance  # Devolver la instancia mockeada para que esté disponible si se necesita explícitamente
   |                                                                                                     ^^^^^^^^^^^^^^^^ E501
   |

backend-call-automation\tests\integration\test_elevenlabs_integration.py:21:11: ANN201 Missing return type annotation for public function `mocked_elevenlabs_service`
   |
19 | # This avoids hitting the actual API during automated testing but tests the service logic
20 | @pytest.fixture(scope="class")
21 | async def mocked_elevenlabs_service():
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
22 |     """Sets up a mocked ElevenLabsService instance for the test class."""
23 |     # Mock external dependencies: secrets_manager and the elevenlabs library functions
   |
   = help: Add return type annotation

backend-call-automation\tests\integration\test_elevenlabs_integration.py:32:66: N806 Variable `MockConversation` in function should be lowercase
   |
30 |         patch("app.services.elevenlabs_service.set_api_key"),
31 |         patch("app.services.elevenlabs_service.generate") as mock_generate,
32 |         patch("app.services.elevenlabs_service.Conversation") as MockConversation,
   |                                                                  ^^^^^^^^^^^^^^^^ N806
33 |     ):
34 |         # Configure mock generate function
   |

backend-call-automation\tests\integration\test_elevenlabs_integration.py:53:9: ERA001 Found commented-out code
   |
52 |         # Teardown (optional, e.g., check if close was called if expected)
53 |         # await service.close_conversation()
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
   |
   = help: Remove commented-out code

backend-call-automation\tests\integration\test_elevenlabs_integration.py:56:1: PT023 [*] Use `@pytest.mark.integration` over `@pytest.mark.integration()`
   |
56 | @pytest.mark.integration()
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ PT023
57 | class TestElevenLabsIntegration:
58 |     """Test class for ElevenLabs service integration including metrics verification."""
   |
   = help: Remove parentheses

backend-call-automation\tests\integration\test_elevenlabs_integration.py:60:5: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
58 |     """Test class for ElevenLabs service integration including metrics verification."""
59 |
60 |     @pytest.fixture()
   |     ^^^^^^^^^^^^^^^^^ PT001
61 |     def metrics_text(self):
62 |         """Fixture to simulate metrics endpoint response."""
   |
   = help: Remove parentheses

backend-call-automation\tests\integration\test_elevenlabs_integration.py:61:9: ANN201 Missing return type annotation for public function `metrics_text`
   |
60 |     @pytest.fixture()
61 |     def metrics_text(self):
   |         ^^^^^^^^^^^^ ANN201
62 |         """Fixture to simulate metrics endpoint response."""
63 |         return """
   |
   = help: Add return type annotation: `str`

backend-call-automation\tests\integration\test_elevenlabs_integration.py:76:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
74 | """
75 |
76 |     @pytest.mark.asyncio()
   |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
77 |     async def test_audio_generation_flow(
78 |         self, mocked_elevenlabs_service: ElevenLabsService, metrics_text: str
   |
   = help: Remove parentheses

backend-call-automation\tests\integration\test_elevenlabs_integration.py:77:15: ANN201 Missing return type annotation for public function `test_audio_generation_flow`
   |
76 |     @pytest.mark.asyncio()
77 |     async def test_audio_generation_flow(
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
78 |         self, mocked_elevenlabs_service: ElevenLabsService, metrics_text: str
79 |     ):
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\integration\test_elevenlabs_integration.py:110:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
108 |             pytest.fail(f"generate_audio failed with exception: {e}")
109 |
110 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
111 |     async def test_metrics_on_error(
112 |         self, mocked_elevenlabs_service: ElevenLabsService, metrics_text: str
    |
    = help: Remove parentheses

backend-call-automation\tests\integration\test_elevenlabs_integration.py:111:15: ANN201 Missing return type annotation for public function `test_metrics_on_error`
    |
110 |     @pytest.mark.asyncio()
111 |     async def test_metrics_on_error(
    |               ^^^^^^^^^^^^^^^^^^^^^ ANN201
112 |         self, mocked_elevenlabs_service: ElevenLabsService, metrics_text: str
113 |     ):
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\integration\test_elevenlabs_integration.py:119:13: S110 `try`-`except`-`pass` detected, consider logging the exception
    |
117 |                   await mocked_elevenlabs_service.generate_audio("test")
118 |                   pytest.fail("Expected exception not raised")
119 | /             except Exception:
120 | |                 pass
    | |____________________^ S110
121 |
122 |               # Verify error metrics
    |

backend-call-automation\tests\integration\test_elevenlabs_integration.py:133:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
131 |             )
132 |
133 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
134 |     async def test_concurrent_requests(self, mocked_elevenlabs_service: ElevenLabsService):
135 |         """Test handling multiple concurrent requests using the mocked service."""
    |
    = help: Remove parentheses

backend-call-automation\tests\integration\test_elevenlabs_integration.py:134:15: ANN201 Missing return type annotation for public function `test_concurrent_requests`
    |
133 |     @pytest.mark.asyncio()
134 |     async def test_concurrent_requests(self, mocked_elevenlabs_service: ElevenLabsService):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
135 |         """Test handling multiple concurrent requests using the mocked service."""
136 |         num_requests = 5
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\integration\test_elevenlabs_integration.py:158:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
156 |                 pytest.fail(f"Concurrent requests failed with exception: {e}")
157 |
158 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
159 |     async def test_retry_mechanism_integration(self, mocked_elevenlabs_service: ElevenLabsService):
160 |         """Test the retry mechanism using mocks to simulate transient errors."""
    |
    = help: Remove parentheses

backend-call-automation\tests\integration\test_elevenlabs_integration.py:159:15: ANN201 Missing return type annotation for public function `test_retry_mechanism_integration`
    |
158 |     @pytest.mark.asyncio()
159 |     async def test_retry_mechanism_integration(self, mocked_elevenlabs_service: ElevenLabsService):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
160 |         """Test the retry mechanism using mocks to simulate transient errors."""
161 |         text = "Test retry message"
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\integration\test_elevenlabs_integration.py:185:52: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
183 |                 assert audio_data == b"successful_audio_after_retry"
184 |                 # Assert that 'generate' was called 3 times (1 initial + 2 retries)
185 |                 assert mock_generate.call_count == 3
    |                                                    ^ PLR2004
186 |                 print("\nRetry mechanism test successful.")
    |

backend-call-automation\tests\integration\test_elevenlabs_integration.py:188:101: E501 Line too long (102 > 100)
    |
186 |                 print("\nRetry mechanism test successful.")
187 |
188 |     # Optional: Add tests for generate_response and handle_stream if their logic differs significantly
    |                                                                                                     ^^ E501
189 |     # Example for generate_response
190 |     @pytest.mark.asyncio()
    |

backend-call-automation\tests\integration\test_elevenlabs_integration.py:190:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
188 |     # Optional: Add tests for generate_response and handle_stream if their logic differs significantly
189 |     # Example for generate_response
190 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
191 |     async def test_generate_response_integration(
192 |         self, mocked_elevenlabs_service: ElevenLabsService
    |
    = help: Remove parentheses

backend-call-automation\tests\integration\test_elevenlabs_integration.py:191:15: ANN201 Missing return type annotation for public function `test_generate_response_integration`
    |
189 |     # Example for generate_response
190 |     @pytest.mark.asyncio()
191 |     async def test_generate_response_integration(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
192 |         self, mocked_elevenlabs_service: ElevenLabsService
193 |     ):
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_basic.py:10:5: ANN201 Missing return type annotation for public function `test_basic`
   |
10 | def test_basic():
   |     ^^^^^^^^^^ ANN201
11 |     """Basic test to ensure pytest is working"""
12 |     assert True
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_basic.py:15:5: ANN201 Missing return type annotation for public function `test_addition`
   |
15 | def test_addition():
   |     ^^^^^^^^^^^^^ ANN201
16 |     """Test basic addition"""
17 |     assert 1 + 1 == 2
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_basic.py:17:21: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
15 | def test_addition():
16 |     """Test basic addition"""
17 |     assert 1 + 1 == 2
   |                     ^ PLR2004
   |

backend-call-automation\tests\test_basic.py:20:5: ANN201 Missing return type annotation for public function `test_environment_setup`
   |
20 | def test_environment_setup():
   |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
21 |     """Verifica que el entorno de pruebas está configurado correctamente."""
22 |     assert True, "El entorno de pruebas está configurado correctamente"
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_basic.py:25:5: ANN201 Missing return type annotation for public function `test_logs_directory_exists`
   |
25 | def test_logs_directory_exists():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
26 |     """Verifica que el directorio de logs existe."""
27 |     # Crear el directorio si no existe
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_basic.py:34:5: ANN201 Missing return type annotation for public function `test_app_log_file_exists`
   |
34 | def test_app_log_file_exists():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
35 |     """Verifica que el archivo de log de la aplicación existe."""
36 |     # Crear el archivo si no existe
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_basic.py:45:5: ANN201 Missing return type annotation for public function `test_python_version`
   |
45 | def test_python_version():
   |     ^^^^^^^^^^^^^^^^^^^ ANN201
46 |     """Verifica la versión de Python."""
47 |     import sys
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_basic.py:49:38: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
47 |     import sys
48 |
49 |     assert sys.version_info.major == 3, "La versión de Python debe ser 3.x"
   |                                      ^ PLR2004
50 |     assert sys.version_info.minor >= 8, "La versión de Python debe ser al menos 3.8"
   |

backend-call-automation\tests\test_basic.py:50:38: PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   |
49 |     assert sys.version_info.major == 3, "La versión de Python debe ser 3.x"
50 |     assert sys.version_info.minor >= 8, "La versión de Python debe ser al menos 3.8"
   |                                      ^ PLR2004
   |

backend-call-automation\tests\test_basic.py:53:5: ANN201 Missing return type annotation for public function `test_required_packages`
   |
53 | def test_required_packages():
   |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
54 |     """Verifica que los paquetes requeridos están instalados."""
55 |     import importlib
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_basic.py:57:101: E501 Line too long (108 > 100)
   |
55 |     import importlib
56 |
57 |     # Lista de paquetes requeridos sin guiones (los paquetes con guiones no se pueden importar directamente)
   |                                                                                                     ^^^^^^^^ E501
58 |     required_packages = ["fastapi", "pydantic", "sqlalchemy", "httpx", "pytest"]
   |

backend-call-automation\tests\test_rollback_utils.py:21:5: ANN201 Missing return type annotation for public function `manage_snapshot_file`
   |
20 | @pytest.fixture(autouse=True)
21 | def manage_snapshot_file(tmp_path):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
22 |     """Asegura que el directorio y archivo snapshot se manejen en tmp_path"""
23 |     test_snapshot_dir = tmp_path / "snapshots"
   |
   = help: Add return type annotation

backend-call-automation\tests\test_rollback_utils.py:21:26: ANN001 Missing type annotation for function argument `tmp_path`
   |
20 | @pytest.fixture(autouse=True)
21 | def manage_snapshot_file(tmp_path):
   |                          ^^^^^^^^ ANN001
22 |     """Asegura que el directorio y archivo snapshot se manejen en tmp_path"""
23 |     test_snapshot_dir = tmp_path / "snapshots"
   |

backend-call-automation\tests\test_rollback_utils.py:32:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
32 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
33 | def mock_redis_sync():
34 |     """Mock para cliente Redis síncrono"""
   |
   = help: Remove parentheses

backend-call-automation\tests\test_rollback_utils.py:33:5: ANN201 Missing return type annotation for public function `mock_redis_sync`
   |
32 | @pytest.fixture()
33 | def mock_redis_sync():
   |     ^^^^^^^^^^^^^^^ ANN201
34 |     """Mock para cliente Redis síncrono"""
35 |     mock = MagicMock(spec=["scan_iter", "delete"])
   |
   = help: Add return type annotation

backend-call-automation\tests\test_rollback_utils.py:50:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
50 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
51 | def mock_redis_async():
52 |     """Mock para cliente Redis asíncrono"""
   |
   = help: Remove parentheses

backend-call-automation\tests\test_rollback_utils.py:51:5: ANN201 Missing return type annotation for public function `mock_redis_async`
   |
50 | @pytest.fixture()
51 | def mock_redis_async():
   |     ^^^^^^^^^^^^^^^^ ANN201
52 |     """Mock para cliente Redis asíncrono"""
53 |     mock = AsyncMock(spec_set=["scan_iter", "delete"])
   |
   = help: Add return type annotation

backend-call-automation\tests\test_rollback_utils.py:55:15: ANN202 Missing return type annotation for private function `mock_scan_iter_impl`
   |
53 |     mock = AsyncMock(spec_set=["scan_iter", "delete"])
54 |
55 |     async def mock_scan_iter_impl(*args, **kwargs):
   |               ^^^^^^^^^^^^^^^^^^^ ANN202
56 |         if False:
57 |             yield
   |
   = help: Add return type annotation

backend-call-automation\tests\test_rollback_utils.py:55:35: ANN002 Missing type annotation for `*args`
   |
53 |     mock = AsyncMock(spec_set=["scan_iter", "delete"])
54 |
55 |     async def mock_scan_iter_impl(*args, **kwargs):
   |                                   ^^^^^ ANN002
56 |         if False:
57 |             yield
   |

backend-call-automation\tests\test_rollback_utils.py:55:36: ARG001 Unused function argument: `args`
   |
53 |     mock = AsyncMock(spec_set=["scan_iter", "delete"])
54 |
55 |     async def mock_scan_iter_impl(*args, **kwargs):
   |                                    ^^^^ ARG001
56 |         if False:
57 |             yield
   |

backend-call-automation\tests\test_rollback_utils.py:55:42: ANN003 Missing type annotation for `**kwargs`
   |
53 |     mock = AsyncMock(spec_set=["scan_iter", "delete"])
54 |
55 |     async def mock_scan_iter_impl(*args, **kwargs):
   |                                          ^^^^^^^^ ANN003
56 |         if False:
57 |             yield
   |

backend-call-automation\tests\test_rollback_utils.py:55:44: ARG001 Unused function argument: `kwargs`
   |
53 |     mock = AsyncMock(spec_set=["scan_iter", "delete"])
54 |
55 |     async def mock_scan_iter_impl(*args, **kwargs):
   |                                            ^^^^^^ ARG001
56 |         if False:
57 |             yield
   |

backend-call-automation\tests\test_rollback_utils.py:65:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
65 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
66 | def mock_connection_pool():
67 |     """Mock para ConnectionPool"""
   |
   = help: Remove parentheses

backend-call-automation\tests\test_rollback_utils.py:66:5: ANN201 Missing return type annotation for public function `mock_connection_pool`
   |
65 | @pytest.fixture()
66 | def mock_connection_pool():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
67 |     """Mock para ConnectionPool"""
68 |     mock_pool_instance = AsyncMock(
   |
   = help: Add return type annotation

backend-call-automation\tests\test_rollback_utils.py:81:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
81 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
82 | def mock_prometheus_registry():
83 |     """Mock para prometheus_client.REGISTRY"""
   |
   = help: Remove parentheses

backend-call-automation\tests\test_rollback_utils.py:82:5: ANN201 Missing return type annotation for public function `mock_prometheus_registry`
   |
81 | @pytest.fixture()
82 | def mock_prometheus_registry():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
83 |     """Mock para prometheus_client.REGISTRY"""
84 |     mock_registry = MagicMock(spec_set=["unregister", "_names_to_collectors"])
   |
   = help: Add return type annotation

backend-call-automation\tests\test_rollback_utils.py:90:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
90 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
91 | def mock_settings_object():
92 |     """Mock para el objeto settings"""
   |
   = help: Remove parentheses

backend-call-automation\tests\test_rollback_utils.py:91:5: ANN201 Missing return type annotation for public function `mock_settings_object`
   |
90 | @pytest.fixture()
91 | def mock_settings_object():
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
92 |     """Mock para el objeto settings"""
93 |     settings_obj = type("MockSettings", (), {})()
   |
   = help: Add return type annotation

backend-call-automation\tests\test_rollback_utils.py:102:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
102 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
103 | class TestRollbackUtils:
104 |     async def test_take_config_snapshot_success(self, mock_settings_object, manage_snapshot_file):
    |
    = help: Remove parentheses

backend-call-automation\tests\test_rollback_utils.py:104:15: ANN201 Missing return type annotation for public function `test_take_config_snapshot_success`
    |
102 | @pytest.mark.asyncio()
103 | class TestRollbackUtils:
104 |     async def test_take_config_snapshot_success(self, mock_settings_object, manage_snapshot_file):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
105 |         os.environ["ELEVENLABS_API_KEY"] = "test_api_key"
106 |         os.environ["OTHER_VAR"] = "ignore_me"
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:104:55: ANN001 Missing type annotation for function argument `mock_settings_object`
    |
102 | @pytest.mark.asyncio()
103 | class TestRollbackUtils:
104 |     async def test_take_config_snapshot_success(self, mock_settings_object, manage_snapshot_file):
    |                                                       ^^^^^^^^^^^^^^^^^^^^ ANN001
105 |         os.environ["ELEVENLABS_API_KEY"] = "test_api_key"
106 |         os.environ["OTHER_VAR"] = "ignore_me"
    |

backend-call-automation\tests\test_rollback_utils.py:104:55: ARG002 Unused method argument: `mock_settings_object`
    |
102 | @pytest.mark.asyncio()
103 | class TestRollbackUtils:
104 |     async def test_take_config_snapshot_success(self, mock_settings_object, manage_snapshot_file):
    |                                                       ^^^^^^^^^^^^^^^^^^^^ ARG002
105 |         os.environ["ELEVENLABS_API_KEY"] = "test_api_key"
106 |         os.environ["OTHER_VAR"] = "ignore_me"
    |

backend-call-automation\tests\test_rollback_utils.py:104:77: ANN001 Missing type annotation for function argument `manage_snapshot_file`
    |
102 | @pytest.mark.asyncio()
103 | class TestRollbackUtils:
104 |     async def test_take_config_snapshot_success(self, mock_settings_object, manage_snapshot_file):
    |                                                                             ^^^^^^^^^^^^^^^^^^^^ ANN001
105 |         os.environ["ELEVENLABS_API_KEY"] = "test_api_key"
106 |         os.environ["OTHER_VAR"] = "ignore_me"
    |

backend-call-automation\tests\test_rollback_utils.py:119:66: PLR2004 Magic value used in comparison, consider replacing `99` with a constant variable
    |
118 |         assert "settings" in snapshot
119 |         assert snapshot["settings"]["ELEVENLABS_MAX_RETRIES"] == 99
    |                                                                  ^^ PLR2004
120 |         assert snapshot["settings"]["ELEVENLABS_CONNECTION_TIMEOUT"] == 99
    |

backend-call-automation\tests\test_rollback_utils.py:120:73: PLR2004 Magic value used in comparison, consider replacing `99` with a constant variable
    |
118 |         assert "settings" in snapshot
119 |         assert snapshot["settings"]["ELEVENLABS_MAX_RETRIES"] == 99
120 |         assert snapshot["settings"]["ELEVENLABS_CONNECTION_TIMEOUT"] == 99
    |                                                                         ^^ PLR2004
121 |
122 |         del os.environ["ELEVENLABS_API_KEY"]
    |

backend-call-automation\tests\test_rollback_utils.py:125:15: ANN201 Missing return type annotation for public function `test_clear_redis_cache_sync_found`
    |
123 |         del os.environ["OTHER_VAR"]
124 |
125 |     async def test_clear_redis_cache_sync_found(self, mock_redis_sync):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
126 |         mock_redis_sync.scan_iter.return_value = iter(["elevenlabs:1", "elevenlabs:2"])
127 |         mock_redis_sync.delete.return_value = 1
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:125:55: ANN001 Missing type annotation for function argument `mock_redis_sync`
    |
123 |         del os.environ["OTHER_VAR"]
124 |
125 |     async def test_clear_redis_cache_sync_found(self, mock_redis_sync):
    |                                                       ^^^^^^^^^^^^^^^ ANN001
126 |         mock_redis_sync.scan_iter.return_value = iter(["elevenlabs:1", "elevenlabs:2"])
127 |         mock_redis_sync.delete.return_value = 1
    |

backend-call-automation\tests\test_rollback_utils.py:131:27: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
129 |         deleted = await clear_redis_cache("elevenlabs:*")
130 |
131 |         assert deleted == 2
    |                           ^ PLR2004
132 |         mock_redis_sync.scan_iter.assert_called_once_with(match="elevenlabs:*", count=100)
133 |         assert mock_redis_sync.delete.call_count == 2
    |

backend-call-automation\tests\test_rollback_utils.py:133:53: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
131 |         assert deleted == 2
132 |         mock_redis_sync.scan_iter.assert_called_once_with(match="elevenlabs:*", count=100)
133 |         assert mock_redis_sync.delete.call_count == 2
    |                                                     ^ PLR2004
134 |         mock_redis_sync.delete.assert_has_calls([call("elevenlabs:1"), call("elevenlabs:2")])
    |

backend-call-automation\tests\test_rollback_utils.py:136:15: ANN201 Missing return type annotation for public function `test_clear_redis_cache_sync_not_found`
    |
134 |         mock_redis_sync.delete.assert_has_calls([call("elevenlabs:1"), call("elevenlabs:2")])
135 |
136 |     async def test_clear_redis_cache_sync_not_found(self, mock_redis_sync):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
137 |         mock_redis_sync.scan_iter.return_value = iter([])
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:136:59: ANN001 Missing type annotation for function argument `mock_redis_sync`
    |
134 |         mock_redis_sync.delete.assert_has_calls([call("elevenlabs:1"), call("elevenlabs:2")])
135 |
136 |     async def test_clear_redis_cache_sync_not_found(self, mock_redis_sync):
    |                                                           ^^^^^^^^^^^^^^^ ANN001
137 |         mock_redis_sync.scan_iter.return_value = iter([])
    |

backend-call-automation\tests\test_rollback_utils.py:145:15: ANN201 Missing return type annotation for public function `test_clear_redis_cache_async_found`
    |
143 |         mock_redis_sync.delete.assert_not_called()
144 |
145 |     async def test_clear_redis_cache_async_found(self, mock_redis_async):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
146 |         async def mock_scan_iter_impl(*args, **kwargs):
147 |             yield "elevenlabs:a1"
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:145:56: ANN001 Missing type annotation for function argument `mock_redis_async`
    |
143 |         mock_redis_sync.delete.assert_not_called()
144 |
145 |     async def test_clear_redis_cache_async_found(self, mock_redis_async):
    |                                                        ^^^^^^^^^^^^^^^^ ANN001
146 |         async def mock_scan_iter_impl(*args, **kwargs):
147 |             yield "elevenlabs:a1"
    |

backend-call-automation\tests\test_rollback_utils.py:146:19: ANN202 Missing return type annotation for private function `mock_scan_iter_impl`
    |
145 |     async def test_clear_redis_cache_async_found(self, mock_redis_async):
146 |         async def mock_scan_iter_impl(*args, **kwargs):
    |                   ^^^^^^^^^^^^^^^^^^^ ANN202
147 |             yield "elevenlabs:a1"
148 |             yield "elevenlabs:a2"
    |
    = help: Add return type annotation

backend-call-automation\tests\test_rollback_utils.py:146:39: ANN002 Missing type annotation for `*args`
    |
145 |     async def test_clear_redis_cache_async_found(self, mock_redis_async):
146 |         async def mock_scan_iter_impl(*args, **kwargs):
    |                                       ^^^^^ ANN002
147 |             yield "elevenlabs:a1"
148 |             yield "elevenlabs:a2"
    |

backend-call-automation\tests\test_rollback_utils.py:146:40: ARG001 Unused function argument: `args`
    |
145 |     async def test_clear_redis_cache_async_found(self, mock_redis_async):
146 |         async def mock_scan_iter_impl(*args, **kwargs):
    |                                        ^^^^ ARG001
147 |             yield "elevenlabs:a1"
148 |             yield "elevenlabs:a2"
    |

backend-call-automation\tests\test_rollback_utils.py:146:46: ANN003 Missing type annotation for `**kwargs`
    |
145 |     async def test_clear_redis_cache_async_found(self, mock_redis_async):
146 |         async def mock_scan_iter_impl(*args, **kwargs):
    |                                              ^^^^^^^^ ANN003
147 |             yield "elevenlabs:a1"
148 |             yield "elevenlabs:a2"
    |

backend-call-automation\tests\test_rollback_utils.py:146:48: ARG001 Unused function argument: `kwargs`
    |
145 |     async def test_clear_redis_cache_async_found(self, mock_redis_async):
146 |         async def mock_scan_iter_impl(*args, **kwargs):
    |                                                ^^^^^^ ARG001
147 |             yield "elevenlabs:a1"
148 |             yield "elevenlabs:a2"
    |

backend-call-automation\tests\test_rollback_utils.py:155:27: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
153 |         deleted = await clear_redis_cache("elevenlabs:*")
154 |
155 |         assert deleted == 2
    |                           ^ PLR2004
156 |         mock_redis_async.scan_iter.assert_called_once_with(match="elevenlabs:*", count=100)
157 |         assert mock_redis_async.delete.call_count == 2
    |

backend-call-automation\tests\test_rollback_utils.py:157:54: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
155 |         assert deleted == 2
156 |         mock_redis_async.scan_iter.assert_called_once_with(match="elevenlabs:*", count=100)
157 |         assert mock_redis_async.delete.call_count == 2
    |                                                      ^ PLR2004
158 |         mock_redis_async.delete.assert_has_calls(
159 |             [call("elevenlabs:a1"), call("elevenlabs:a2")], any_order=True
    |

backend-call-automation\tests\test_rollback_utils.py:162:15: ANN201 Missing return type annotation for public function `test_clear_redis_cache_async_not_found`
    |
160 |         )
161 |
162 |     async def test_clear_redis_cache_async_not_found(self, mock_redis_async):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
163 |         deleted = await clear_redis_cache("elevenlabs:*")
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:162:60: ANN001 Missing type annotation for function argument `mock_redis_async`
    |
160 |         )
161 |
162 |     async def test_clear_redis_cache_async_not_found(self, mock_redis_async):
    |                                                            ^^^^^^^^^^^^^^^^ ANN001
163 |         deleted = await clear_redis_cache("elevenlabs:*")
    |

backend-call-automation\tests\test_rollback_utils.py:169:15: ANN201 Missing return type annotation for public function `test_reset_prometheus_metrics_unregisters`
    |
167 |         mock_redis_async.delete.assert_not_called()
168 |
169 |     async def test_reset_prometheus_metrics_unregisters(self, mock_prometheus_registry):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
170 |         # Usamos MagicMock directamente sin especificar spec=Collector
171 |         collector1 = MagicMock(_name="elevenlabs_requests_total")
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:169:63: ANN001 Missing type annotation for function argument `mock_prometheus_registry`
    |
167 |         mock_redis_async.delete.assert_not_called()
168 |
169 |     async def test_reset_prometheus_metrics_unregisters(self, mock_prometheus_registry):
    |                                                               ^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
170 |         # Usamos MagicMock directamente sin especificar spec=Collector
171 |         collector1 = MagicMock(_name="elevenlabs_requests_total")
    |

backend-call-automation\tests\test_rollback_utils.py:181:66: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
179 |         await reset_prometheus_metrics()
180 |
181 |         assert mock_prometheus_registry.unregister.call_count == 2
    |                                                                  ^ PLR2004
182 |         mock_prometheus_registry.unregister.assert_has_calls(
183 |             [call(collector1), call(collector2)], any_order=True
    |

backend-call-automation\tests\test_rollback_utils.py:186:15: ANN201 Missing return type annotation for public function `test_reset_prometheus_metrics_specific_and_missing`
    |
184 |         )
185 |
186 |     async def test_reset_prometheus_metrics_specific_and_missing(self, mock_prometheus_registry):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
187 |         # Usamos MagicMock directamente sin especificar spec=Collector
188 |         collector1 = MagicMock(_name="metric_exists")
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:186:72: ANN001 Missing type annotation for function argument `mock_prometheus_registry`
    |
184 |         )
185 |
186 |     async def test_reset_prometheus_metrics_specific_and_missing(self, mock_prometheus_registry):
    |                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^ ANN001
187 |         # Usamos MagicMock directamente sin especificar spec=Collector
188 |         collector1 = MagicMock(_name="metric_exists")
    |

backend-call-automation\tests\test_rollback_utils.py:195:15: ANN201 Missing return type annotation for public function `test_close_all_connections_uses_close_all`
    |
193 |         mock_prometheus_registry.unregister.assert_called_once_with(collector1)
194 |
195 |     async def test_close_all_connections_uses_close_all(self, mock_connection_pool):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
196 |         mock_connection_pool.close_all = AsyncMock(return_value=5)
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:195:63: ANN001 Missing type annotation for function argument `mock_connection_pool`
    |
193 |         mock_prometheus_registry.unregister.assert_called_once_with(collector1)
194 |
195 |     async def test_close_all_connections_uses_close_all(self, mock_connection_pool):
    |                                                               ^^^^^^^^^^^^^^^^^^^^ ANN001
196 |         mock_connection_pool.close_all = AsyncMock(return_value=5)
    |

backend-call-automation\tests\test_rollback_utils.py:204:15: ANN201 Missing return type annotation for public function `test_close_all_connections_uses_fallback`
    |
202 |         mock_connection_pool.terminate_connection.assert_not_called()
203 |
204 |     async def test_close_all_connections_uses_fallback(self, mock_connection_pool):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
205 |         mock_conn1 = MagicMock()
206 |         mock_conn2 = MagicMock()
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:204:62: ANN001 Missing type annotation for function argument `mock_connection_pool`
    |
202 |         mock_connection_pool.terminate_connection.assert_not_called()
203 |
204 |     async def test_close_all_connections_uses_fallback(self, mock_connection_pool):
    |                                                              ^^^^^^^^^^^^^^^^^^^^ ANN001
205 |         mock_conn1 = MagicMock()
206 |         mock_conn2 = MagicMock()
    |

backend-call-automation\tests\test_rollback_utils.py:213:72: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
211 |         assert not hasattr(mock_connection_pool, "close_all")
212 |         mock_connection_pool.get_active_connections.assert_called_once()
213 |         assert mock_connection_pool.terminate_connection.call_count == 2
    |                                                                        ^ PLR2004
214 |         mock_connection_pool.terminate_connection.assert_has_calls(
215 |             [call(mock_conn1), call(mock_conn2)], any_order=True
    |

backend-call-automation\tests\test_rollback_utils.py:218:15: ANN201 Missing return type annotation for public function `test_restore_config_from_snapshot`
    |
216 |         )
217 |
218 |     async def test_restore_config_from_snapshot(self, mock_settings_object, manage_snapshot_file):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
219 |         test_snapshot = {
220 |             "env_vars": {"ELEVENLABS_API_KEY": "key_from_snapshot"},
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:218:55: ANN001 Missing type annotation for function argument `mock_settings_object`
    |
216 |         )
217 |
218 |     async def test_restore_config_from_snapshot(self, mock_settings_object, manage_snapshot_file):
    |                                                       ^^^^^^^^^^^^^^^^^^^^ ANN001
219 |         test_snapshot = {
220 |             "env_vars": {"ELEVENLABS_API_KEY": "key_from_snapshot"},
    |

backend-call-automation\tests\test_rollback_utils.py:218:77: ANN001 Missing type annotation for function argument `manage_snapshot_file`
    |
216 |         )
217 |
218 |     async def test_restore_config_from_snapshot(self, mock_settings_object, manage_snapshot_file):
    |                                                                             ^^^^^^^^^^^^^^^^^^^^ ANN001
219 |         test_snapshot = {
220 |             "env_vars": {"ELEVENLABS_API_KEY": "key_from_snapshot"},
    |

backend-call-automation\tests\test_rollback_utils.py:235:63: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
234 |         assert os.environ["ELEVENLABS_API_KEY"] == "key_from_snapshot"
235 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 5
    |                                                               ^ PLR2004
236 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 50
237 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 5
    |

backend-call-automation\tests\test_rollback_utils.py:236:70: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
234 |         assert os.environ["ELEVENLABS_API_KEY"] == "key_from_snapshot"
235 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 5
236 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 50
    |                                                                      ^^ PLR2004
237 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 5
238 |         mock_settings_object.reload.assert_called_once()
    |

backend-call-automation\tests\test_rollback_utils.py:237:61: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
235 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 5
236 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 50
237 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 5
    |                                                             ^ PLR2004
238 |         mock_settings_object.reload.assert_called_once()
    |

backend-call-automation\tests\test_rollback_utils.py:242:15: ANN201 Missing return type annotation for public function `test_restore_config_to_defaults_no_snapshot`
    |
240 |         del os.environ["ELEVENLABS_API_KEY"]
241 |
242 |     async def test_restore_config_to_defaults_no_snapshot(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
243 |         self, mock_settings_object, manage_snapshot_file
244 |     ):
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:243:15: ANN001 Missing type annotation for function argument `mock_settings_object`
    |
242 |     async def test_restore_config_to_defaults_no_snapshot(
243 |         self, mock_settings_object, manage_snapshot_file
    |               ^^^^^^^^^^^^^^^^^^^^ ANN001
244 |     ):
245 |         if manage_snapshot_file.exists():
    |

backend-call-automation\tests\test_rollback_utils.py:243:37: ANN001 Missing type annotation for function argument `manage_snapshot_file`
    |
242 |     async def test_restore_config_to_defaults_no_snapshot(
243 |         self, mock_settings_object, manage_snapshot_file
    |                                     ^^^^^^^^^^^^^^^^^^^^ ANN001
244 |     ):
245 |         if manage_snapshot_file.exists():
    |

backend-call-automation\tests\test_rollback_utils.py:255:63: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
253 |         await restore_previous_config()
254 |
255 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 3
    |                                                               ^ PLR2004
256 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 30
257 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 10
    |

backend-call-automation\tests\test_rollback_utils.py:256:70: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
255 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 3
256 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 30
    |                                                                      ^^ PLR2004
257 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 10
258 |         mock_settings_object.reload.assert_called_once()
    |

backend-call-automation\tests\test_rollback_utils.py:257:61: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
255 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 3
256 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 30
257 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 10
    |                                                             ^^ PLR2004
258 |         mock_settings_object.reload.assert_called_once()
    |

backend-call-automation\tests\test_rollback_utils.py:263:15: ANN201 Missing return type annotation for public function `test_restore_config_to_defaults_snapshot_error`
    |
261 |             del os.environ["ELEVENLABS_API_KEY"]
262 |
263 |     async def test_restore_config_to_defaults_snapshot_error(
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
264 |         self, mock_settings_object, manage_snapshot_file
265 |     ):
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:264:15: ANN001 Missing type annotation for function argument `mock_settings_object`
    |
263 |     async def test_restore_config_to_defaults_snapshot_error(
264 |         self, mock_settings_object, manage_snapshot_file
    |               ^^^^^^^^^^^^^^^^^^^^ ANN001
265 |     ):
266 |         with open(manage_snapshot_file, "w") as f:
    |

backend-call-automation\tests\test_rollback_utils.py:264:37: ANN001 Missing type annotation for function argument `manage_snapshot_file`
    |
263 |     async def test_restore_config_to_defaults_snapshot_error(
264 |         self, mock_settings_object, manage_snapshot_file
    |                                     ^^^^^^^^^^^^^^^^^^^^ ANN001
265 |     ):
266 |         with open(manage_snapshot_file, "w") as f:
    |

backend-call-automation\tests\test_rollback_utils.py:271:63: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
269 |         await restore_previous_config()
270 |
271 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 3
    |                                                               ^ PLR2004
272 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 30
273 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 10
    |

backend-call-automation\tests\test_rollback_utils.py:272:70: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
271 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 3
272 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 30
    |                                                                      ^^ PLR2004
273 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 10
274 |         mock_settings_object.reload.assert_called_once()
    |

backend-call-automation\tests\test_rollback_utils.py:273:61: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
271 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 3
272 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 30
273 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 10
    |                                                             ^^ PLR2004
274 |         mock_settings_object.reload.assert_called_once()
    |

backend-call-automation\tests\test_rollback_utils.py:276:15: ANN201 Missing return type annotation for public function `test_apply_default_config`
    |
274 |         mock_settings_object.reload.assert_called_once()
275 |
276 |     async def test_apply_default_config(self, mock_settings_object):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
277 |         mock_settings_object.ELEVENLABS_MAX_RETRIES = 55
278 |         os.environ["ELEVENLABS_API_KEY"] = "some_key"
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_rollback_utils.py:276:47: ANN001 Missing type annotation for function argument `mock_settings_object`
    |
274 |         mock_settings_object.reload.assert_called_once()
275 |
276 |     async def test_apply_default_config(self, mock_settings_object):
    |                                               ^^^^^^^^^^^^^^^^^^^^ ANN001
277 |         mock_settings_object.ELEVENLABS_MAX_RETRIES = 55
278 |         os.environ["ELEVENLABS_API_KEY"] = "some_key"
    |

backend-call-automation\tests\test_rollback_utils.py:282:63: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
280 |         await _apply_default_config()
281 |
282 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 3
    |                                                               ^ PLR2004
283 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 30
284 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 10
    |

backend-call-automation\tests\test_rollback_utils.py:283:70: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
282 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 3
283 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 30
    |                                                                      ^^ PLR2004
284 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 10
    |

backend-call-automation\tests\test_rollback_utils.py:284:61: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
282 |         assert mock_settings_object.ELEVENLABS_MAX_RETRIES == 3
283 |         assert mock_settings_object.ELEVENLABS_CONNECTION_TIMEOUT == 30
284 |         assert mock_settings_object.ELEVENLABS_POOL_SIZE == 10
    |                                                             ^^ PLR2004
285 |
286 |         if "ELEVENLABS_API_KEY" in os.environ:
    |

backend-call-automation\tests\test_services\test_call_service.py:12:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
12 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
13 | def mock_supabase():
14 |     return MagicMock()
   |
   = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:13:5: ANN201 Missing return type annotation for public function `mock_supabase`
   |
12 | @pytest.fixture()
13 | def mock_supabase():
   |     ^^^^^^^^^^^^^ ANN201
14 |     return MagicMock()
   |
   = help: Add return type annotation

backend-call-automation\tests\test_services\test_call_service.py:17:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
17 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
18 | def call_service(mock_supabase):
19 |     service = CallService(supabase_client=mock_supabase)
   |
   = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:18:5: ANN201 Missing return type annotation for public function `call_service`
   |
17 | @pytest.fixture()
18 | def call_service(mock_supabase):
   |     ^^^^^^^^^^^^ ANN201
19 |     service = CallService(supabase_client=mock_supabase)
20 |     service.elevenlabs_service = AsyncMock()
   |
   = help: Add return type annotation

backend-call-automation\tests\test_services\test_call_service.py:18:18: ANN001 Missing type annotation for function argument `mock_supabase`
   |
17 | @pytest.fixture()
18 | def call_service(mock_supabase):
   |                  ^^^^^^^^^^^^^ ANN001
19 |     service = CallService(supabase_client=mock_supabase)
20 |     service.elevenlabs_service = AsyncMock()
   |

backend-call-automation\tests\test_services\test_call_service.py:27:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
27 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
28 | async def test_initiate_outbound_call_success(call_service):
29 |     call_id = "test-call-id"
   |
   = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:28:11: ANN201 Missing return type annotation for public function `test_initiate_outbound_call_success`
   |
27 | @pytest.mark.asyncio()
28 | async def test_initiate_outbound_call_success(call_service):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
29 |     call_id = "test-call-id"
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:28:47: ANN001 Missing type annotation for function argument `call_service`
   |
27 | @pytest.mark.asyncio()
28 | async def test_initiate_outbound_call_success(call_service):
   |                                               ^^^^^^^^^^^^ ANN001
29 |     call_id = "test-call-id"
   |

backend-call-automation\tests\test_services\test_call_service.py:41:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
41 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
42 | async def test_initiate_outbound_call_failure(call_service):
43 |     call_id = "test-call-id"
   |
   = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:42:11: ANN201 Missing return type annotation for public function `test_initiate_outbound_call_failure`
   |
41 | @pytest.mark.asyncio()
42 | async def test_initiate_outbound_call_failure(call_service):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
43 |     call_id = "test-call-id"
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:42:47: ANN001 Missing type annotation for function argument `call_service`
   |
41 | @pytest.mark.asyncio()
42 | async def test_initiate_outbound_call_failure(call_service):
   |                                               ^^^^^^^^^^^^ ANN001
43 |     call_id = "test-call-id"
   |

backend-call-automation\tests\test_services\test_call_service.py:55:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
55 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
56 | async def test_handle_call_response_success(call_service):
57 |     call_id = "test-call-id"
   |
   = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:56:11: ANN201 Missing return type annotation for public function `test_handle_call_response_success`
   |
55 | @pytest.mark.asyncio()
56 | async def test_handle_call_response_success(call_service):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
57 |     call_id = "test-call-id"
58 |     user_message = "Hola"
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:56:45: ANN001 Missing type annotation for function argument `call_service`
   |
55 | @pytest.mark.asyncio()
56 | async def test_handle_call_response_success(call_service):
   |                                             ^^^^^^^^^^^^ ANN001
57 |     call_id = "test-call-id"
58 |     user_message = "Hola"
   |

backend-call-automation\tests\test_services\test_call_service.py:79:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
79 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
80 | async def test_handle_call_response_with_error(call_service):
81 |     call_id = "test-call-id"
   |
   = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:80:11: ANN201 Missing return type annotation for public function `test_handle_call_response_with_error`
   |
79 | @pytest.mark.asyncio()
80 | async def test_handle_call_response_with_error(call_service):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
81 |     call_id = "test-call-id"
82 |     user_message = "Hola"
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:80:48: ANN001 Missing type annotation for function argument `call_service`
   |
79 | @pytest.mark.asyncio()
80 | async def test_handle_call_response_with_error(call_service):
   |                                                ^^^^^^^^^^^^ ANN001
81 |     call_id = "test-call-id"
82 |     user_message = "Hola"
   |

backend-call-automation\tests\test_services\test_call_service.py:90:5: PT012 `pytest.raises()` block should contain a single simple statement
   |
88 |       # Ejecutar y verificar el fallback
89 |       chunks = []
90 | /     with pytest.raises(StreamingError):
91 | |         async for chunk in await call_service.handle_call_response(call_id, user_message):
92 | |             chunks.append(chunk)
   | |________________________________^ PT012
93 |
94 |       assert chunks == [b"fallback"]
   |

backend-call-automation\tests\test_services\test_call_service.py:97:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
97 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
98 | async def test_handle_call_end_success(call_service):
99 |     call_id = "test-call-id"
   |
   = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:98:11: ANN201 Missing return type annotation for public function `test_handle_call_end_success`
   |
97 | @pytest.mark.asyncio()
98 | async def test_handle_call_end_success(call_service):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
99 |     call_id = "test-call-id"
   |
   = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:98:40: ANN001 Missing type annotation for function argument `call_service`
   |
97 | @pytest.mark.asyncio()
98 | async def test_handle_call_end_success(call_service):
   |                                        ^^^^^^^^^^^^ ANN001
99 |     call_id = "test-call-id"
   |

backend-call-automation\tests\test_services\test_call_service.py:111:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
111 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
112 | async def test_get_voice_for_call(call_service):
113 |     call_id = "test-call-id"
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:112:11: ANN201 Missing return type annotation for public function `test_get_voice_for_call`
    |
111 | @pytest.mark.asyncio()
112 | async def test_get_voice_for_call(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
113 |     call_id = "test-call-id"
114 |     voice_id = "test-voice-id"
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:112:35: ANN001 Missing type annotation for function argument `call_service`
    |
111 | @pytest.mark.asyncio()
112 | async def test_get_voice_for_call(call_service):
    |                                   ^^^^^^^^^^^^ ANN001
113 |     call_id = "test-call-id"
114 |     voice_id = "test-voice-id"
    |

backend-call-automation\tests\test_services\test_call_service.py:117:101: E501 Line too long (114 > 100)
    |
116 |     # Configurar mock de Supabase
117 |     call_service.supabase.table.return_value.select.return_value.eq.return_value.execute.return_value = MagicMock(
    |                                                                                                     ^^^^^^^^^^^^^^ E501
118 |         data=[{"voice_id": voice_id}]
119 |     )
    |

backend-call-automation\tests\test_services\test_call_service.py:126:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
126 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
127 | async def test_get_voice_for_call_fallback_to_default(call_service, monkeypatch):
128 |     call_id = "test-call-id"
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:127:11: ANN201 Missing return type annotation for public function `test_get_voice_for_call_fallback_to_default`
    |
126 | @pytest.mark.asyncio()
127 | async def test_get_voice_for_call_fallback_to_default(call_service, monkeypatch):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
128 |     call_id = "test-call-id"
129 |     default_voice_id = "default-voice"
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:127:55: ANN001 Missing type annotation for function argument `call_service`
    |
126 | @pytest.mark.asyncio()
127 | async def test_get_voice_for_call_fallback_to_default(call_service, monkeypatch):
    |                                                       ^^^^^^^^^^^^ ANN001
128 |     call_id = "test-call-id"
129 |     default_voice_id = "default-voice"
    |

backend-call-automation\tests\test_services\test_call_service.py:127:69: ANN001 Missing type annotation for function argument `monkeypatch`
    |
126 | @pytest.mark.asyncio()
127 | async def test_get_voice_for_call_fallback_to_default(call_service, monkeypatch):
    |                                                                     ^^^^^^^^^^^ ANN001
128 |     call_id = "test-call-id"
129 |     default_voice_id = "default-voice"
    |

backend-call-automation\tests\test_services\test_call_service.py:132:101: E501 Line too long (114 > 100)
    |
131 |     # Configurar mock de Supabase para no devolver datos
132 |     call_service.supabase.table.return_value.select.return_value.eq.return_value.execute.return_value = MagicMock(
    |                                                                                                     ^^^^^^^^^^^^^^ E501
133 |         data=[]
134 |     )
    |

backend-call-automation\tests\test_services\test_call_service.py:146:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
146 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
147 | async def test_start_call(call_service):
148 |     call_id = "test-call-id"
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:147:11: ANN201 Missing return type annotation for public function `test_start_call`
    |
146 | @pytest.mark.asyncio()
147 | async def test_start_call(call_service):
    |           ^^^^^^^^^^^^^^^ ANN201
148 |     call_id = "test-call-id"
149 |     voice_id = "test-voice-id"
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:147:27: ANN001 Missing type annotation for function argument `call_service`
    |
146 | @pytest.mark.asyncio()
147 | async def test_start_call(call_service):
    |                           ^^^^^^^^^^^^ ANN001
148 |     call_id = "test-call-id"
149 |     voice_id = "test-voice-id"
    |

backend-call-automation\tests\test_services\test_call_service.py:162:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
162 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
163 | async def test_handle_audio_stream_success(call_service):
164 |     call_id = "test-call-id"
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:163:11: ANN201 Missing return type annotation for public function `test_handle_audio_stream_success`
    |
162 | @pytest.mark.asyncio()
163 | async def test_handle_audio_stream_success(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
164 |     call_id = "test-call-id"
165 |     audio_chunk = b"input_chunk"
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:163:44: ANN001 Missing type annotation for function argument `call_service`
    |
162 | @pytest.mark.asyncio()
163 | async def test_handle_audio_stream_success(call_service):
    |                                            ^^^^^^^^^^^^ ANN001
164 |     call_id = "test-call-id"
165 |     audio_chunk = b"input_chunk"
    |

backend-call-automation\tests\test_services\test_call_service.py:192:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
192 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
193 | async def test_update_call_history(call_service):
194 |     call_id = "test-call-id"
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:193:11: ANN201 Missing return type annotation for public function `test_update_call_history`
    |
192 | @pytest.mark.asyncio()
193 | async def test_update_call_history(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
194 |     call_id = "test-call-id"
195 |     user_message = "User says something"
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:193:36: ANN001 Missing type annotation for function argument `call_service`
    |
192 | @pytest.mark.asyncio()
193 | async def test_update_call_history(call_service):
    |                                    ^^^^^^^^^^^^ ANN001
194 |     call_id = "test-call-id"
195 |     user_message = "User says something"
    |

backend-call-automation\tests\test_services\test_call_service.py:219:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
219 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
220 | async def test_create_call(call_service):
221 |     call_data = CallCreate(
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:220:11: ANN201 Missing return type annotation for public function `test_create_call`
    |
219 | @pytest.mark.asyncio()
220 | async def test_create_call(call_service):
    |           ^^^^^^^^^^^^^^^^ ANN201
221 |     call_data = CallCreate(
222 |         campaign_id="camp1",
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:220:28: ANN001 Missing type annotation for function argument `call_service`
    |
219 | @pytest.mark.asyncio()
220 | async def test_create_call(call_service):
    |                            ^^^^^^^^^^^^ ANN001
221 |     call_data = CallCreate(
222 |         campaign_id="camp1",
    |

backend-call-automation\tests\test_services\test_call_service.py:227:9: ERA001 Found commented-out code
    |
225 |         from_number="+0987654321",
226 |         script_template="Hello {name}",
227 |         # twilio_sid="ACxxxx" # Opcional aquí
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
228 |     )
229 |     generated_audio = b"audio_data"
    |
    = help: Remove commented-out code

backend-call-automation\tests\test_services\test_call_service.py:241:31: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
239 |                 "id": str(call_id),
240 |                 "status": CallStatus.PENDING.value,
241 |                 "created_at": datetime.now().isoformat(),
    |                               ^^^^^^^^^^^^^^ DTZ005
242 |                 "updated_at": datetime.now().isoformat(),
243 |                 "twilio_sid": None,  # Asumiendo que no se pasó
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\tests\test_services\test_call_service.py:242:31: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
240 |                 "status": CallStatus.PENDING.value,
241 |                 "created_at": datetime.now().isoformat(),
242 |                 "updated_at": datetime.now().isoformat(),
    |                               ^^^^^^^^^^^^^^ DTZ005
243 |                 "twilio_sid": None,  # Asumiendo que no se pasó
244 |                 **call_data.dict(exclude={"twilio_sid", "script_template"}),
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\tests\test_services\test_call_service.py:266:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
266 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
267 | async def test_get_call_success(call_service):
268 |     call_id = uuid.uuid4()
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:267:11: ANN201 Missing return type annotation for public function `test_get_call_success`
    |
266 | @pytest.mark.asyncio()
267 | async def test_get_call_success(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^ ANN201
268 |     call_id = uuid.uuid4()
269 |     mock_call_data = {
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:267:33: ANN001 Missing type annotation for function argument `call_service`
    |
266 | @pytest.mark.asyncio()
267 | async def test_get_call_success(call_service):
    |                                 ^^^^^^^^^^^^ ANN001
268 |     call_id = uuid.uuid4()
269 |     mock_call_data = {
    |

backend-call-automation\tests\test_services\test_call_service.py:279:101: E501 Line too long (123 > 100)
    |
277 |     mock_execute = AsyncMock()
278 |     mock_execute.return_value = MagicMock(data=mock_call_data)
279 |     call_service.supabase.table.return_value.select.return_value.eq.return_value.single.return_value.execute = mock_execute
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^ E501
280 |
281 |     # Ejecutar
    |

backend-call-automation\tests\test_services\test_call_service.py:292:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
292 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
293 | async def test_get_call_not_found(call_service):
294 |     call_id = uuid.uuid4()
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:293:11: ANN201 Missing return type annotation for public function `test_get_call_not_found`
    |
292 | @pytest.mark.asyncio()
293 | async def test_get_call_not_found(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
294 |     call_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:293:35: ANN001 Missing type annotation for function argument `call_service`
    |
292 | @pytest.mark.asyncio()
293 | async def test_get_call_not_found(call_service):
    |                                   ^^^^^^^^^^^^ ANN001
294 |     call_id = uuid.uuid4()
    |

backend-call-automation\tests\test_services\test_call_service.py:299:101: E501 Line too long (123 > 100)
    |
297 |     mock_execute = AsyncMock()
298 |     mock_execute.return_value = MagicMock(data=None)
299 |     call_service.supabase.table.return_value.select.return_value.eq.return_value.single.return_value.execute = mock_execute
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^ E501
300 |
301 |     # Ejecutar y verificar excepción
    |

backend-call-automation\tests\test_services\test_call_service.py:304:42: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
    |
302 |     with pytest.raises(HTTPException) as exc_info:
303 |         await call_service.get_call(call_id)
304 |     assert exc_info.value.status_code == 404
    |                                          ^^^ PLR2004
    |

backend-call-automation\tests\test_services\test_call_service.py:307:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
307 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
308 | async def test_update_call_success(call_service):
309 |     call_id = uuid.uuid4()
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:308:11: ANN201 Missing return type annotation for public function `test_update_call_success`
    |
307 | @pytest.mark.asyncio()
308 | async def test_update_call_success(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
309 |     call_id = uuid.uuid4()
310 |     update_data = CallUpdate(status=CallStatus.COMPLETED)
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:308:36: ANN001 Missing type annotation for function argument `call_service`
    |
307 | @pytest.mark.asyncio()
308 | async def test_update_call_success(call_service):
    |                                    ^^^^^^^^^^^^ ANN001
309 |     call_id = uuid.uuid4()
310 |     update_data = CallUpdate(status=CallStatus.COMPLETED)
    |

backend-call-automation\tests\test_services\test_call_service.py:315:23: DTZ005 `datetime.datetime.now()` called without a `tz` argument
    |
313 |         "id": str(call_id),
314 |         "status": CallStatus.COMPLETED.value,
315 |         "updated_at": datetime.now().isoformat(),
    |                       ^^^^^^^^^^^^^^ DTZ005
316 |     }
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

backend-call-automation\tests\test_services\test_call_service.py:320:101: E501 Line too long (129 > 100)
    |
318 |     # Mockear la verificación de existencia
319 |     mock_check_execute = AsyncMock(return_value=MagicMock(data=mock_existing_call))
320 |     call_service.supabase.table.return_value.select.return_value.eq.return_value.single.return_value.execute = mock_check_execute
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
321 |
322 |     # Mockear la actualización
    |

backend-call-automation\tests\test_services\test_call_service.py:324:101: E501 Line too long (130 > 100)
    |
322 |     # Mockear la actualización
323 |     mock_update_execute = AsyncMock(return_value=MagicMock(data=mock_updated_call))
324 |     call_service.supabase.table.return_value.update.return_value.eq.return_value.single.return_value.execute = mock_update_execute
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
325 |
326 |     # Ejecutar
    |

backend-call-automation\tests\test_services\test_call_service.py:344:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
344 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
345 | async def test_update_call_not_found(call_service):
346 |     call_id = uuid.uuid4()
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:345:11: ANN201 Missing return type annotation for public function `test_update_call_not_found`
    |
344 | @pytest.mark.asyncio()
345 | async def test_update_call_not_found(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
346 |     call_id = uuid.uuid4()
347 |     update_data = CallUpdate(status=CallStatus.COMPLETED)
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:345:38: ANN001 Missing type annotation for function argument `call_service`
    |
344 | @pytest.mark.asyncio()
345 | async def test_update_call_not_found(call_service):
    |                                      ^^^^^^^^^^^^ ANN001
346 |     call_id = uuid.uuid4()
347 |     update_data = CallUpdate(status=CallStatus.COMPLETED)
    |

backend-call-automation\tests\test_services\test_call_service.py:351:101: E501 Line too long (129 > 100)
    |
349 |     # Mockear la verificación de existencia para no encontrar la llamada
350 |     mock_check_execute = AsyncMock(return_value=MagicMock(data=None))
351 |     call_service.supabase.table.return_value.select.return_value.eq.return_value.single.return_value.execute = mock_check_execute
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
352 |
353 |     # Ejecutar y verificar excepción
    |

backend-call-automation\tests\test_services\test_call_service.py:356:42: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
    |
354 |     with pytest.raises(HTTPException) as exc_info:
355 |         await call_service.update_call(call_id, update_data)
356 |     assert exc_info.value.status_code == 404
    |                                          ^^^ PLR2004
357 |     call_service.supabase.table.return_value.update.assert_not_called()
    |

backend-call-automation\tests\test_services\test_call_service.py:360:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
360 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
361 | async def test_delete_call_success(call_service):
362 |     call_id = uuid.uuid4()
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:361:11: ANN201 Missing return type annotation for public function `test_delete_call_success`
    |
360 | @pytest.mark.asyncio()
361 | async def test_delete_call_success(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
362 |     call_id = uuid.uuid4()
363 |     mock_existing_call = {"id": str(call_id)}
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:361:36: ANN001 Missing type annotation for function argument `call_service`
    |
360 | @pytest.mark.asyncio()
361 | async def test_delete_call_success(call_service):
    |                                    ^^^^^^^^^^^^ ANN001
362 |     call_id = uuid.uuid4()
363 |     mock_existing_call = {"id": str(call_id)}
    |

backend-call-automation\tests\test_services\test_call_service.py:367:101: E501 Line too long (129 > 100)
    |
365 |     # Mockear la verificación de existencia
366 |     mock_check_execute = AsyncMock(return_value=MagicMock(data=mock_existing_call))
367 |     call_service.supabase.table.return_value.select.return_value.eq.return_value.single.return_value.execute = mock_check_execute
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
368 |
369 |     # Mockear la eliminación
    |

backend-call-automation\tests\test_services\test_call_service.py:391:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
391 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
392 | async def test_delete_call_not_found(call_service):
393 |     call_id = uuid.uuid4()
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:392:11: ANN201 Missing return type annotation for public function `test_delete_call_not_found`
    |
391 | @pytest.mark.asyncio()
392 | async def test_delete_call_not_found(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
393 |     call_id = uuid.uuid4()
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:392:38: ANN001 Missing type annotation for function argument `call_service`
    |
391 | @pytest.mark.asyncio()
392 | async def test_delete_call_not_found(call_service):
    |                                      ^^^^^^^^^^^^ ANN001
393 |     call_id = uuid.uuid4()
    |

backend-call-automation\tests\test_services\test_call_service.py:397:101: E501 Line too long (129 > 100)
    |
395 |     # Mockear la verificación de existencia para no encontrar la llamada
396 |     mock_check_execute = AsyncMock(return_value=MagicMock(data=None))
397 |     call_service.supabase.table.return_value.select.return_value.eq.return_value.single.return_value.execute = mock_check_execute
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
398 |
399 |     # Ejecutar y verificar excepción
    |

backend-call-automation\tests\test_services\test_call_service.py:402:42: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
    |
400 |     with pytest.raises(HTTPException) as exc_info:
401 |         await call_service.delete_call(call_id)
402 |     assert exc_info.value.status_code == 404
    |                                          ^^^ PLR2004
403 |     call_service.supabase.table.return_value.delete.assert_not_called()
    |

backend-call-automation\tests\test_services\test_call_service.py:406:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
406 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
407 | async def test_get_call_by_twilio_sid_success(call_service):
408 |     twilio_sid = "ACxxxx1234"
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:407:11: ANN201 Missing return type annotation for public function `test_get_call_by_twilio_sid_success`
    |
406 | @pytest.mark.asyncio()
407 | async def test_get_call_by_twilio_sid_success(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
408 |     twilio_sid = "ACxxxx1234"
409 |     mock_call_data = {"id": str(uuid.uuid4()), "twilio_sid": twilio_sid, "status": "completed"}
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:407:47: ANN001 Missing type annotation for function argument `call_service`
    |
406 | @pytest.mark.asyncio()
407 | async def test_get_call_by_twilio_sid_success(call_service):
    |                                               ^^^^^^^^^^^^ ANN001
408 |     twilio_sid = "ACxxxx1234"
409 |     mock_call_data = {"id": str(uuid.uuid4()), "twilio_sid": twilio_sid, "status": "completed"}
    |

backend-call-automation\tests\test_services\test_call_service.py:413:101: E501 Line too long (123 > 100)
    |
411 |     # Mockear Supabase
412 |     mock_execute = AsyncMock(return_value=MagicMock(data=mock_call_data))
413 |     call_service.supabase.table.return_value.select.return_value.eq.return_value.single.return_value.execute = mock_execute
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^ E501
414 |
415 |     # Ejecutar
    |

backend-call-automation\tests\test_services\test_call_service.py:426:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
426 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
427 | async def test_get_call_by_twilio_sid_not_found(call_service):
428 |     twilio_sid = "ACxxxx1234"
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:427:11: ANN201 Missing return type annotation for public function `test_get_call_by_twilio_sid_not_found`
    |
426 | @pytest.mark.asyncio()
427 | async def test_get_call_by_twilio_sid_not_found(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
428 |     twilio_sid = "ACxxxx1234"
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:427:49: ANN001 Missing type annotation for function argument `call_service`
    |
426 | @pytest.mark.asyncio()
427 | async def test_get_call_by_twilio_sid_not_found(call_service):
    |                                                 ^^^^^^^^^^^^ ANN001
428 |     twilio_sid = "ACxxxx1234"
    |

backend-call-automation\tests\test_services\test_call_service.py:432:101: E501 Line too long (123 > 100)
    |
430 |     # Mockear Supabase para no devolver datos
431 |     mock_execute = AsyncMock(return_value=MagicMock(data=None))
432 |     call_service.supabase.table.return_value.select.return_value.eq.return_value.single.return_value.execute = mock_execute
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^ E501
433 |
434 |     # Ejecutar
    |

backend-call-automation\tests\test_services\test_call_service.py:444:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
444 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
445 | async def test_handle_call_response_audio_version_success(call_service):
446 |     call_id = str(uuid.uuid4())
    |
    = help: Remove parentheses

backend-call-automation\tests\test_services\test_call_service.py:445:11: ANN201 Missing return type annotation for public function `test_handle_call_response_audio_version_success`
    |
444 | @pytest.mark.asyncio()
445 | async def test_handle_call_response_audio_version_success(call_service):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
446 |     call_id = str(uuid.uuid4())
447 |     user_message = "User message"
    |
    = help: Add return type annotation: `None`

backend-call-automation\tests\test_services\test_call_service.py:445:59: ANN001 Missing type annotation for function argument `call_service`
    |
444 | @pytest.mark.asyncio()
445 | async def test_handle_call_response_audio_version_success(call_service):
    |                                                           ^^^^^^^^^^^^ ANN001
446 |     call_id = str(uuid.uuid4())
447 |     user_message = "User message"
    |

backend-call-automation\tests\utils\metrics_helpers.py:19:24: UP007 [*] Use `X | Y` for type annotations
   |
17 |         Diccionario con las métricas parseadas
18 |     """
19 |     metrics: dict[str, Union[float, str, list[str]]] = {}
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP007
20 |     lines = metrics_text.strip().split("\n")
   |
   = help: Convert to `X | Y`

backend-call-automation\tests\utils\metrics_helpers.py:24:9: PLW2901 `for` loop variable `line` overwritten by assignment target
   |
22 |     current_metric = None
23 |     for line in lines:
24 |         line = line.strip()
   |         ^^^^ PLW2901
25 |         if not line or line.startswith("#"):
26 |             continue
   |

backend-call-automation\tests\utils\metrics_helpers.py:31:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
29 |         if not line.startswith(" "):
30 |             parts = line.split(" ", 1)
31 |             if len(parts) == 2:
   |                              ^ PLR2004
32 |                 metric_name, value = parts
33 |                 try:
   |

backend-call-automation\tests\utils\metrics_helpers.py:87:8: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   |
86 |     # Convertir a float si es posible para comparación numérica
87 |     if isinstance(metrics[metric_name], (int, float)) and isinstance(expected_value, (int, float)):
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
88 |         return abs(float(metrics[metric_name]) - float(expected_value)) < 0.0001
   |
   = help: Convert to `X | Y`

backend-call-automation\tests\utils\metrics_helpers.py:87:59: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   |
86 |     # Convertir a float si es posible para comparación numérica
87 |     if isinstance(metrics[metric_name], (int, float)) and isinstance(expected_value, (int, float)):
   |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
88 |         return abs(float(metrics[metric_name]) - float(expected_value)) < 0.0001
   |
   = help: Convert to `X | Y`

backend-call-automation\tests\utils\metrics_helpers.py:88:75: PLR2004 Magic value used in comparison, consider replacing `0.0001` with a constant variable
   |
86 |     # Convertir a float si es posible para comparación numérica
87 |     if isinstance(metrics[metric_name], (int, float)) and isinstance(expected_value, (int, float)):
88 |         return abs(float(metrics[metric_name]) - float(expected_value)) < 0.0001
   |                                                                           ^^^^^^ PLR2004
89 |
90 |     # Asegurarse de que la comparación devuelva un booleano
   |

backend-call-automation\tests\utils\metrics_helpers.py:133:9: PLW2901 `for` loop variable `line` overwritten by assignment target
    |
132 |     for line in lines:
133 |         line = line.strip()
    |         ^^^^ PLW2901
134 |         if line.startswith(f"{metric_name}{{"):
135 |             line_labels = extract_metric_labels(line)
    |

docs\TEMPLATES\python_docstring_template.py:29:9: ANN204 Missing return type annotation for special method `__init__`
   |
27 |     """
28 |
29 |     def __init__(self, param1: str, param2: int | None = None):
   |         ^^^^^^^^ ANN204
30 |         """Initialize the class.
   |
   = help: Add return type annotation: `None`

integration_tests.py:12:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
11 | class TestAIRedisIntegration:
12 |     @pytest.mark.asyncio()
   |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
13 |     async def test_conversation_flow(self):
14 |         # Configurar mocks
   |
   = help: Remove parentheses

integration_tests.py:13:15: ANN201 Missing return type annotation for public function `test_conversation_flow`
   |
11 | class TestAIRedisIntegration:
12 |     @pytest.mark.asyncio()
13 |     async def test_conversation_flow(self):
   |               ^^^^^^^^^^^^^^^^^^^^^^ ANN201
14 |         # Configurar mocks
15 |         redis_mock = AsyncMock()
   |
   = help: Add return type annotation: `None`

integration_tests.py:36:13: S101 Use of `assert` detected
   |
35 |             # Verificar respuesta
36 |             assert response["conversation_id"] == conv_id
   |             ^^^^^^ S101
37 |             assert "response" in response
38 |             assert "input_sentiment" in response
   |

integration_tests.py:37:13: S101 Use of `assert` detected
   |
35 |             # Verificar respuesta
36 |             assert response["conversation_id"] == conv_id
37 |             assert "response" in response
   |             ^^^^^^ S101
38 |             assert "input_sentiment" in response
   |

integration_tests.py:38:13: S101 Use of `assert` detected
   |
36 |             assert response["conversation_id"] == conv_id
37 |             assert "response" in response
38 |             assert "input_sentiment" in response
   |             ^^^^^^ S101
39 |
40 |     @pytest.mark.asyncio()
   |

integration_tests.py:40:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
38 |             assert "input_sentiment" in response
39 |
40 |     @pytest.mark.asyncio()
   |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
41 |     async def test_cached_conversation(self):
42 |         # Configurar mock con caché existente
   |
   = help: Remove parentheses

integration_tests.py:41:15: ANN201 Missing return type annotation for public function `test_cached_conversation`
   |
40 |     @pytest.mark.asyncio()
41 |     async def test_cached_conversation(self):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
42 |         # Configurar mock con caché existente
43 |         redis_mock = AsyncMock()
   |
   = help: Add return type annotation: `None`

integration_tests.py:54:9: S101 Use of `assert` detected
   |
52 |         # Verificar que usó el caché
53 |         redis_mock.get.assert_called()
54 |         assert "context" in response
   |         ^^^^^^ S101
   |

integration_tests.py:57:1: E402 Module level import not at top of file
   |
57 | import asyncio
   | ^^^^^^^^^^^^^^ E402
58 | import time
   |

integration_tests.py:58:1: E402 Module level import not at top of file
   |
57 | import asyncio
58 | import time
   | ^^^^^^^^^^^ E402
59 |
60 | from app.utils.logger import get_logger  # Assuming logger is configured
   |

integration_tests.py:60:1: E402 Module level import not at top of file
   |
58 | import time
59 |
60 | from app.utils.logger import get_logger  # Assuming logger is configured
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
61 |
62 | logger = get_logger(__name__)
   |

integration_tests.py:66:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
65 | class TestAIRedisLoadTesting:
66 |     @pytest.mark.asyncio()
   |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
67 |     async def test_concurrent_load(self):
68 |         """Prueba de carga con múltiples conversaciones simultáneas."""
   |
   = help: Remove parentheses

integration_tests.py:67:15: ANN201 Missing return type annotation for public function `test_concurrent_load`
   |
65 | class TestAIRedisLoadTesting:
66 |     @pytest.mark.asyncio()
67 |     async def test_concurrent_load(self):
   |               ^^^^^^^^^^^^^^^^^^^^ ANN201
68 |         """Prueba de carga con múltiples conversaciones simultáneas."""
69 |         redis_mock = AsyncMock()
   |
   = help: Add return type annotation: `None`

integration_tests.py:80:19: ANN202 Missing return type annotation for private function `conversation_simulation`
   |
78 |         messages_per_conv = 5
79 |
80 |         async def conversation_simulation(conv_id):
   |                   ^^^^^^^^^^^^^^^^^^^^^^^ ANN202
81 |             for i in range(messages_per_conv):
82 |                 response = await service.process_message(
   |
   = help: Add return type annotation: `None`

integration_tests.py:80:43: ANN001 Missing type annotation for function argument `conv_id`
   |
78 |         messages_per_conv = 5
79 |
80 |         async def conversation_simulation(conv_id):
   |                                           ^^^^^^^ ANN001
81 |             for i in range(messages_per_conv):
82 |                 response = await service.process_message(
   |

integration_tests.py:85:17: S101 Use of `assert` detected
   |
83 |                     f"Message {i}", conversation_id=f"load-test-{conv_id}"
84 |                 )
85 |                 assert response is not None
   |                 ^^^^^^ S101
86 |
87 |         tasks = [conversation_simulation(i) for i in range(num_conversations)]
   |

integration_tests.py:98:9: S101 Use of `assert` detected
   |
97 |         logger.info(f"Load test completed: {requests_per_second:.2f} req/s")
98 |         assert requests_per_second > 10  # Mínimo 10 req/s
   |         ^^^^^^ S101
   |

integration_tests.py:98:38: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
97 |         logger.info(f"Load test completed: {requests_per_second:.2f} req/s")
98 |         assert requests_per_second > 10  # Mínimo 10 req/s
   |                                      ^^ PLR2004
   |

isolated_ai_redis_tests.py:17:9: ANN204 Missing return type annotation for special method `__init__`
   |
15 | # Crear clase mock de AIConversationService
16 | class MockAIConversationService:
17 |     def __init__(self, model_name="gpt-4"):
   |         ^^^^^^^^ ANN204
18 |         self.model_name = model_name
19 |         # Use AsyncMock for the semaphore itself if its methods are async
   |
   = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:17:24: ANN001 Missing type annotation for function argument `model_name`
   |
15 | # Crear clase mock de AIConversationService
16 | class MockAIConversationService:
17 |     def __init__(self, model_name="gpt-4"):
   |                        ^^^^^^^^^^ ANN001
18 |         self.model_name = model_name
19 |         # Use AsyncMock for the semaphore itself if its methods are async
   |

isolated_ai_redis_tests.py:26:15: ANN201 Missing return type annotation for public function `process_message`
   |
24 |         self.retry_delay = 1
25 |
26 |     async def process_message(self, message, conversation_id=None, context=None):
   |               ^^^^^^^^^^^^^^^ ANN201
27 |         # Simulate acquiring the semaphore
28 |         await self._rate_limit_semaphore.acquire()
   |
   = help: Add return type annotation

isolated_ai_redis_tests.py:26:37: ANN001 Missing type annotation for function argument `message`
   |
24 |         self.retry_delay = 1
25 |
26 |     async def process_message(self, message, conversation_id=None, context=None):
   |                                     ^^^^^^^ ANN001
27 |         # Simulate acquiring the semaphore
28 |         await self._rate_limit_semaphore.acquire()
   |

isolated_ai_redis_tests.py:26:46: ANN001 Missing type annotation for function argument `conversation_id`
   |
24 |         self.retry_delay = 1
25 |
26 |     async def process_message(self, message, conversation_id=None, context=None):
   |                                              ^^^^^^^^^^^^^^^ ANN001
27 |         # Simulate acquiring the semaphore
28 |         await self._rate_limit_semaphore.acquire()
   |

isolated_ai_redis_tests.py:26:68: ANN001 Missing type annotation for function argument `context`
   |
24 |         self.retry_delay = 1
25 |
26 |     async def process_message(self, message, conversation_id=None, context=None):
   |                                                                    ^^^^^^^ ANN001
27 |         # Simulate acquiring the semaphore
28 |         await self._rate_limit_semaphore.acquire()
   |

isolated_ai_redis_tests.py:31:23: TRY003 Avoid specifying long messages outside the exception class
   |
29 |         try:
30 |             if not message or not isinstance(message, str):
31 |                 raise ValueError("Message must be a non-empty string")
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
32 |
33 |             if context and not isinstance(context, dict):
   |

isolated_ai_redis_tests.py:34:23: TRY003 Avoid specifying long messages outside the exception class
   |
33 |             if context and not isinstance(context, dict):
34 |                 raise TypeError("Context must be a dictionary")
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
35 |
36 |             # Simulate sentiment analysis call which might timeout
   |

isolated_ai_redis_tests.py:41:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
39 |             except asyncio.TimeoutError:
40 |                 # Simulate the behavior of the real service raising HTTPException on timeout
41 |                 raise HTTPException(status_code=503, detail="AI service timeout")
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ B904
42 |             except ValueError as e:  # Propagate validation errors from analyze_sentiment
43 |                 raise e
   |

isolated_ai_redis_tests.py:43:23: TRY201 Use `raise` without specifying exception name
   |
41 |                 raise HTTPException(status_code=503, detail="AI service timeout")
42 |             except ValueError as e:  # Propagate validation errors from analyze_sentiment
43 |                 raise e
   |                       ^ TRY201
44 |
45 |             # Simular interacción con Redis si existe un cliente configurado
   |
   = help: Remove exception name

isolated_ai_redis_tests.py:71:15: ANN201 Missing return type annotation for public function `analyze_sentiment`
   |
69 |             await self._rate_limit_semaphore.release()
70 |
71 |     async def analyze_sentiment(self, text):
   |               ^^^^^^^^^^^^^^^^^ ANN201
72 |         if not text:
73 |             raise ValueError("Text cannot be empty")
   |
   = help: Add return type annotation

isolated_ai_redis_tests.py:71:39: ANN001 Missing type annotation for function argument `text`
   |
69 |             await self._rate_limit_semaphore.release()
70 |
71 |     async def analyze_sentiment(self, text):
   |                                       ^^^^ ANN001
72 |         if not text:
73 |             raise ValueError("Text cannot be empty")
   |

isolated_ai_redis_tests.py:73:19: TRY003 Avoid specifying long messages outside the exception class
   |
71 |     async def analyze_sentiment(self, text):
72 |         if not text:
73 |             raise ValueError("Text cannot be empty")
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
74 |         return {"primary_emotion": "neutral", "score": 0.5}
   |

isolated_ai_redis_tests.py:78:5: ANN201 Missing return type annotation for public function `mock_generate_conversation_cache_key`
   |
77 | # Mock de redis_client
78 | def mock_generate_conversation_cache_key(conversation_id):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
79 |     if not conversation_id:
80 |         raise ValueError("Conversation ID cannot be empty")
   |
   = help: Add return type annotation: `str`

isolated_ai_redis_tests.py:78:42: ANN001 Missing type annotation for function argument `conversation_id`
   |
77 | # Mock de redis_client
78 | def mock_generate_conversation_cache_key(conversation_id):
   |                                          ^^^^^^^^^^^^^^^ ANN001
79 |     if not conversation_id:
80 |         raise ValueError("Conversation ID cannot be empty")
   |

isolated_ai_redis_tests.py:80:15: TRY003 Avoid specifying long messages outside the exception class
   |
78 | def mock_generate_conversation_cache_key(conversation_id):
79 |     if not conversation_id:
80 |         raise ValueError("Conversation ID cannot be empty")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
81 |     return f"conv:{conversation_id}"
   |

isolated_ai_redis_tests.py:90:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
88 | # Pruebas para AIConversationService
89 | class TestAIConversationServiceIsolated:
90 |     @pytest.mark.asyncio()
   |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
91 |     async def test_process_message_basic(self):
92 |         service = AIConversationService(model_name="gpt-4")
   |
   = help: Remove parentheses

isolated_ai_redis_tests.py:91:15: ANN201 Missing return type annotation for public function `test_process_message_basic`
   |
89 | class TestAIConversationServiceIsolated:
90 |     @pytest.mark.asyncio()
91 |     async def test_process_message_basic(self):
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
92 |         service = AIConversationService(model_name="gpt-4")
93 |         response = await service.process_message("Test message")
   |
   = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:94:9: S101 Use of `assert` detected
   |
92 |         service = AIConversationService(model_name="gpt-4")
93 |         response = await service.process_message("Test message")
94 |         assert isinstance(response, dict)
   |         ^^^^^^ S101
95 |         assert "response" in response
96 |         assert response["response"] == "Respuesta mock"
   |

isolated_ai_redis_tests.py:95:9: S101 Use of `assert` detected
   |
93 |         response = await service.process_message("Test message")
94 |         assert isinstance(response, dict)
95 |         assert "response" in response
   |         ^^^^^^ S101
96 |         assert response["response"] == "Respuesta mock"
   |

isolated_ai_redis_tests.py:96:9: S101 Use of `assert` detected
   |
94 |         assert isinstance(response, dict)
95 |         assert "response" in response
96 |         assert response["response"] == "Respuesta mock"
   |         ^^^^^^ S101
97 |
98 |     @pytest.mark.asyncio()
   |

isolated_ai_redis_tests.py:98:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
 96 |         assert response["response"] == "Respuesta mock"
 97 |
 98 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
 99 |     async def test_process_message_with_context(self):
100 |         service = AIConversationService()
    |
    = help: Remove parentheses

isolated_ai_redis_tests.py:99:15: ANN201 Missing return type annotation for public function `test_process_message_with_context`
    |
 98 |     @pytest.mark.asyncio()
 99 |     async def test_process_message_with_context(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
100 |         service = AIConversationService()
101 |         context = {"user_id": "123", "language": "es"}
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:105:9: S101 Use of `assert` detected
    |
103 |             "Test message", conversation_id="test-conv-123", context=context
104 |         )
105 |         assert response["context"] == context
    |         ^^^^^^ S101
106 |         assert response["conversation_id"] == "test-conv-123"
    |

isolated_ai_redis_tests.py:106:9: S101 Use of `assert` detected
    |
104 |         )
105 |         assert response["context"] == context
106 |         assert response["conversation_id"] == "test-conv-123"
    |         ^^^^^^ S101
107 |
108 |     @pytest.mark.asyncio()
    |

isolated_ai_redis_tests.py:108:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
106 |         assert response["conversation_id"] == "test-conv-123"
107 |
108 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
109 |     async def test_sentiment_analysis(self):
110 |         service = AIConversationService()
    |
    = help: Remove parentheses

isolated_ai_redis_tests.py:109:15: ANN201 Missing return type annotation for public function `test_sentiment_analysis`
    |
108 |     @pytest.mark.asyncio()
109 |     async def test_sentiment_analysis(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
110 |         service = AIConversationService()
111 |         sentiment = await service.analyze_sentiment("Test message")
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:112:9: S101 Use of `assert` detected
    |
110 |         service = AIConversationService()
111 |         sentiment = await service.analyze_sentiment("Test message")
112 |         assert "primary_emotion" in sentiment
    |         ^^^^^^ S101
113 |         assert "score" in sentiment
114 |         assert 0 <= sentiment["score"] <= 1
    |

isolated_ai_redis_tests.py:113:9: S101 Use of `assert` detected
    |
111 |         sentiment = await service.analyze_sentiment("Test message")
112 |         assert "primary_emotion" in sentiment
113 |         assert "score" in sentiment
    |         ^^^^^^ S101
114 |         assert 0 <= sentiment["score"] <= 1
    |

isolated_ai_redis_tests.py:114:9: S101 Use of `assert` detected
    |
112 |         assert "primary_emotion" in sentiment
113 |         assert "score" in sentiment
114 |         assert 0 <= sentiment["score"] <= 1
    |         ^^^^^^ S101
    |

isolated_ai_redis_tests.py:119:9: ANN201 Missing return type annotation for public function `test_generate_cache_key`
    |
117 | # Pruebas para RedisClient
118 | class TestRedisClientIsolated:
119 |     def test_generate_cache_key(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
120 |         key = generate_conversation_cache_key("test-123")
121 |         assert key == "conv:test-123"
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:121:9: S101 Use of `assert` detected
    |
119 |     def test_generate_cache_key(self):
120 |         key = generate_conversation_cache_key("test-123")
121 |         assert key == "conv:test-123"
    |         ^^^^^^ S101
122 |
123 |     def test_generate_cache_key_with_special_chars(self):
    |

isolated_ai_redis_tests.py:123:9: ANN201 Missing return type annotation for public function `test_generate_cache_key_with_special_chars`
    |
121 |         assert key == "conv:test-123"
122 |
123 |     def test_generate_cache_key_with_special_chars(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
124 |         key = generate_conversation_cache_key("test@123#$%")
125 |         assert key.startswith("conv:")
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:125:9: S101 Use of `assert` detected
    |
123 |     def test_generate_cache_key_with_special_chars(self):
124 |         key = generate_conversation_cache_key("test@123#$%")
125 |         assert key.startswith("conv:")
    |         ^^^^^^ S101
126 |         assert len(key) > 5
    |

isolated_ai_redis_tests.py:126:9: S101 Use of `assert` detected
    |
124 |         key = generate_conversation_cache_key("test@123#$%")
125 |         assert key.startswith("conv:")
126 |         assert len(key) > 5
    |         ^^^^^^ S101
127 |
128 |     def test_generate_cache_key_empty(self):
    |

isolated_ai_redis_tests.py:126:27: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
124 |         key = generate_conversation_cache_key("test@123#$%")
125 |         assert key.startswith("conv:")
126 |         assert len(key) > 5
    |                           ^ PLR2004
127 |
128 |     def test_generate_cache_key_empty(self):
    |

isolated_ai_redis_tests.py:128:9: ANN201 Missing return type annotation for public function `test_generate_cache_key_empty`
    |
126 |         assert len(key) > 5
127 |
128 |     def test_generate_cache_key_empty(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
129 |         with pytest.raises(ValueError):
130 |             generate_conversation_cache_key("")
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:129:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
128 |     def test_generate_cache_key_empty(self):
129 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
130 |             generate_conversation_cache_key("")
    |

isolated_ai_redis_tests.py:132:9: ANN201 Missing return type annotation for public function `test_cache_key_validation`
    |
130 |             generate_conversation_cache_key("")
131 |
132 |     def test_cache_key_validation(self):
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
133 |         # Prueba caracteres especiales
134 |         special_chars = ["@", "#", "$", "%", "&", "*"]
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:137:13: S101 Use of `assert` detected
    |
135 |         for char in special_chars:
136 |             key = generate_conversation_cache_key(f"test{char}123")
137 |             assert "conv:" in key
    |             ^^^^^^ S101
138 |             assert len(key) > 5
    |

isolated_ai_redis_tests.py:138:13: S101 Use of `assert` detected
    |
136 |             key = generate_conversation_cache_key(f"test{char}123")
137 |             assert "conv:" in key
138 |             assert len(key) > 5
    |             ^^^^^^ S101
139 |
140 |         # Prueba longitud máxima
    |

isolated_ai_redis_tests.py:138:31: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
136 |             key = generate_conversation_cache_key(f"test{char}123")
137 |             assert "conv:" in key
138 |             assert len(key) > 5
    |                               ^ PLR2004
139 |
140 |         # Prueba longitud máxima
    |

isolated_ai_redis_tests.py:143:9: S101 Use of `assert` detected
    |
141 |         long_id = "x" * 100
142 |         key = generate_conversation_cache_key(long_id)
143 |         assert len(key) <= 200  # Asumiendo un límite razonable
    |         ^^^^^^ S101
144 |
145 |         # Prueba caracteres Unicode
    |

isolated_ai_redis_tests.py:143:28: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
141 |         long_id = "x" * 100
142 |         key = generate_conversation_cache_key(long_id)
143 |         assert len(key) <= 200  # Asumiendo un límite razonable
    |                            ^^^ PLR2004
144 |
145 |         # Prueba caracteres Unicode
    |

isolated_ai_redis_tests.py:148:9: S101 Use of `assert` detected
    |
146 |         unicode_id = "test🔥123"
147 |         key = generate_conversation_cache_key(unicode_id)
148 |         assert "conv:" in key
    |         ^^^^^^ S101
    |

isolated_ai_redis_tests.py:152:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
151 | class TestAIConversationServiceAdvanced:
152 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
153 |     async def test_input_validation(self):
154 |         service = AIConversationService()
    |
    = help: Remove parentheses

isolated_ai_redis_tests.py:153:15: ANN201 Missing return type annotation for public function `test_input_validation`
    |
151 | class TestAIConversationServiceAdvanced:
152 |     @pytest.mark.asyncio()
153 |     async def test_input_validation(self):
    |               ^^^^^^^^^^^^^^^^^^^^^ ANN201
154 |         service = AIConversationService()
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:157:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
156 |         # Prueba mensaje vacío
157 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
158 |             await service.process_message("")
    |

isolated_ai_redis_tests.py:161:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
160 |         # Prueba tipo incorrecto de mensaje
161 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
162 |             await service.process_message(123)
    |

isolated_ai_redis_tests.py:168:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
166 |             await service.process_message("test", context="invalid")
167 |
168 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
169 |     async def test_metadata_presence(self):
170 |         service = AIConversationService()
    |
    = help: Remove parentheses

isolated_ai_redis_tests.py:169:15: ANN201 Missing return type annotation for public function `test_metadata_presence`
    |
168 |     @pytest.mark.asyncio()
169 |     async def test_metadata_presence(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^ ANN201
170 |         service = AIConversationService()
171 |         response = await service.process_message("Test message")
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:173:9: S101 Use of `assert` detected
    |
171 |         response = await service.process_message("Test message")
172 |
173 |         assert "metadata" in response
    |         ^^^^^^ S101
174 |         assert "model" in response["metadata"]
175 |         assert "tokens_used" in response["metadata"]
    |

isolated_ai_redis_tests.py:174:9: S101 Use of `assert` detected
    |
173 |         assert "metadata" in response
174 |         assert "model" in response["metadata"]
    |         ^^^^^^ S101
175 |         assert "tokens_used" in response["metadata"]
176 |         assert "processing_time" in response["metadata"]
    |

isolated_ai_redis_tests.py:175:9: S101 Use of `assert` detected
    |
173 |         assert "metadata" in response
174 |         assert "model" in response["metadata"]
175 |         assert "tokens_used" in response["metadata"]
    |         ^^^^^^ S101
176 |         assert "processing_time" in response["metadata"]
    |

isolated_ai_redis_tests.py:176:9: S101 Use of `assert` detected
    |
174 |         assert "model" in response["metadata"]
175 |         assert "tokens_used" in response["metadata"]
176 |         assert "processing_time" in response["metadata"]
    |         ^^^^^^ S101
177 |
178 |     @pytest.mark.asyncio()
    |

isolated_ai_redis_tests.py:178:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
176 |         assert "processing_time" in response["metadata"]
177 |
178 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
179 |     async def test_sentiment_analysis_edge_cases(self):
180 |         service = AIConversationService()
    |
    = help: Remove parentheses

isolated_ai_redis_tests.py:179:15: ANN201 Missing return type annotation for public function `test_sentiment_analysis_edge_cases`
    |
178 |     @pytest.mark.asyncio()
179 |     async def test_sentiment_analysis_edge_cases(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
180 |         service = AIConversationService()
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:183:28: PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
    |
182 |         # Prueba texto vacío
183 |         with pytest.raises(ValueError):
    |                            ^^^^^^^^^^ PT011
184 |             await service.analyze_sentiment("")
    |

isolated_ai_redis_tests.py:189:9: S101 Use of `assert` detected
    |
187 |         long_text = "test " * 1000
188 |         sentiment = await service.analyze_sentiment(long_text)
189 |         assert isinstance(sentiment["score"], float)
    |         ^^^^^^ S101
190 |         assert 0 <= sentiment["score"] <= 1
    |

isolated_ai_redis_tests.py:190:9: S101 Use of `assert` detected
    |
188 |         sentiment = await service.analyze_sentiment(long_text)
189 |         assert isinstance(sentiment["score"], float)
190 |         assert 0 <= sentiment["score"] <= 1
    |         ^^^^^^ S101
191 |
192 |     @pytest.mark.asyncio()
    |

isolated_ai_redis_tests.py:192:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
190 |         assert 0 <= sentiment["score"] <= 1
191 |
192 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
193 |     async def test_rate_limiting(self):
194 |         """Prueba el mecanismo de rate limiting."""
    |
    = help: Remove parentheses

isolated_ai_redis_tests.py:193:15: ANN201 Missing return type annotation for public function `test_rate_limiting`
    |
192 |     @pytest.mark.asyncio()
193 |     async def test_rate_limiting(self):
    |               ^^^^^^^^^^^^^^^^^^ ANN201
194 |         """Prueba el mecanismo de rate limiting."""
195 |         service = AIConversationService()
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:203:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
201 |         service._rate_limit_semaphore.release.assert_called_once()
202 |
203 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
204 |     async def test_timeout_handling(self):
205 |         """Prueba el manejo de timeouts en llamadas a la IA."""
    |
    = help: Remove parentheses

isolated_ai_redis_tests.py:204:15: ANN201 Missing return type annotation for public function `test_timeout_handling`
    |
203 |     @pytest.mark.asyncio()
204 |     async def test_timeout_handling(self):
    |               ^^^^^^^^^^^^^^^^^^^^^ ANN201
205 |         """Prueba el manejo de timeouts en llamadas a la IA."""
206 |         service = AIConversationService()
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:209:9: SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
    |
208 |           # Simular timeout en llamada a IA
209 | /         with patch.object(service, "analyze_sentiment", side_effect=asyncio.TimeoutError):
210 | |             with pytest.raises(
211 | |                 HTTPException
212 | |             ):  # Assuming process_message wraps this in HTTPException
    | |______________^ SIM117
213 |                   await service.process_message("test")
    |
    = help: Combine `with` statements

isolated_ai_redis_tests.py:215:5: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
213 |                 await service.process_message("test")
214 |
215 |     @pytest.mark.asyncio()
    |     ^^^^^^^^^^^^^^^^^^^^^^ PT023
216 |     async def test_memory_management(self):
217 |         """Prueba la gestión de memoria de conversación."""
    |
    = help: Remove parentheses

isolated_ai_redis_tests.py:216:15: ANN201 Missing return type annotation for public function `test_memory_management`
    |
215 |     @pytest.mark.asyncio()
216 |     async def test_memory_management(self):
    |               ^^^^^^^^^^^^^^^^^^^^^^ ANN201
217 |         """Prueba la gestión de memoria de conversación."""
218 |         service = AIConversationService()
    |
    = help: Add return type annotation: `None`

isolated_ai_redis_tests.py:226:13: S101 Use of `assert` detected
    |
224 |         for msg in messages:
225 |             response = await service.process_message(message=msg, conversation_id=conv_id)
226 |             assert response is not None
    |             ^^^^^^ S101
227 |
228 |         # Verificar que la memoria no excede límites
    |

isolated_ai_redis_tests.py:233:13: S101 Use of `assert` detected
    |
231 |             # Note: This check is very basic and depends on mock implementation
232 |             # A real test might need a more sophisticated way to check memory usage
233 |             assert sys.getsizeof(str(cached_data)) < 1024 * 1024  # Max 1MB
    |             ^^^^^^ S101
    |

scripts\backend_security_check.py:15:5: ANN201 Missing return type annotation for public function `run_bandit`
   |
15 | def run_bandit():
   |     ^^^^^^^^^^ ANN201
16 |     """Ejecuta Bandit para analizar el código Python."""
17 |     print("Ejecutando Bandit para analizar el código Python...")
   |
   = help: Add return type annotation: `bool | None`

scripts\backend_security_check.py:21:9: UP022 Prefer `capture_output` over sending `stdout` and `stderr` to `PIPE`
   |
19 |       # Instalar bandit si no está instalado
20 |       try:
21 | /         subprocess.run(
22 | |             ["bandit", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=False
23 | |         )
   | |_________^ UP022
24 |       except:
25 |           print("Instalando bandit...")
   |
   = help: Replace with `capture_output` keyword argument

scripts\backend_security_check.py:21:9: S603 `subprocess` call: check for execution of untrusted input
   |
19 |     # Instalar bandit si no está instalado
20 |     try:
21 |         subprocess.run(
   |         ^^^^^^^^^^^^^^ S603
22 |             ["bandit", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=False
23 |         )
   |

scripts\backend_security_check.py:22:13: S607 Starting a process with a partial executable path
   |
20 |     try:
21 |         subprocess.run(
22 |             ["bandit", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=False
   |             ^^^^^^^^^^^^^^^^^^^^^^^ S607
23 |         )
24 |     except:
   |

scripts\backend_security_check.py:24:5: E722 Do not use bare `except`
   |
22 |             ["bandit", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=False
23 |         )
24 |     except:
   |     ^^^^^^ E722
25 |         print("Instalando bandit...")
26 |         subprocess.run([sys.executable, "-m", "pip", "install", "bandit"], check=False)
   |

scripts\backend_security_check.py:26:9: S603 `subprocess` call: check for execution of untrusted input
   |
24 |     except:
25 |         print("Instalando bandit...")
26 |         subprocess.run([sys.executable, "-m", "pip", "install", "bandit"], check=False)
   |         ^^^^^^^^^^^^^^ S603
27 |
28 |     # Crear directorio para informes
   |

scripts\backend_security_check.py:32:14: UP022 Prefer `capture_output` over sending `stdout` and `stderr` to `PIPE`
   |
31 |       # Ejecutar bandit
32 |       result = subprocess.run(
   |  ______________^
33 | |         [
34 | |             "bandit",
35 | |             "-r",
36 | |             "backend-call-automation",
37 | |             "-f",
38 | |             "json",
39 | |             "-o",
40 | |             "security-reports/bandit-results.json",
41 | |         ],
42 | |         stdout=subprocess.PIPE,
43 | |         stderr=subprocess.PIPE,
44 | |         text=True,
45 | |         check=False,
46 | |     )
   | |_____^ UP022
47 |
48 |       if (
   |
   = help: Replace with `capture_output` keyword argument

scripts\backend_security_check.py:32:14: S603 `subprocess` call: check for execution of untrusted input
   |
31 |     # Ejecutar bandit
32 |     result = subprocess.run(
   |              ^^^^^^^^^^^^^^ S603
33 |         [
34 |             "bandit",
   |

scripts\backend_security_check.py:33:9: S607 Starting a process with a partial executable path
   |
31 |       # Ejecutar bandit
32 |       result = subprocess.run(
33 | /         [
34 | |             "bandit",
35 | |             "-r",
36 | |             "backend-call-automation",
37 | |             "-f",
38 | |             "json",
39 | |             "-o",
40 | |             "security-reports/bandit-results.json",
41 | |         ],
   | |_________^ S607
42 |           stdout=subprocess.PIPE,
43 |           stderr=subprocess.PIPE,
   |

scripts\backend_security_check.py:49:9: PLR1714 Consider merging multiple comparisons: `result.returncode not in {0, 1}`.
   |
48 |     if (
49 |         result.returncode != 0 and result.returncode != 1
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR1714
50 |     ):  # 1 significa que se encontraron problemas
51 |         print(f"Error al ejecutar bandit: {result.stderr}")
   |
   = help: Merge multiple comparisons

scripts\backend_security_check.py:80:9: TRY300 Consider moving this statement to an `else` block
   |
78 |             return True
79 |         print("⚠️ No se generó el archivo de resultados de Bandit")
80 |         return False
   |         ^^^^^^^^^^^^ TRY300
81 |     except Exception as e:
82 |         print(f"Error al procesar los resultados de Bandit: {e!s}")
   |

scripts\backend_security_check.py:86:5: ANN201 Missing return type annotation for public function `run_safety`
   |
86 | def run_safety():
   |     ^^^^^^^^^^ ANN201
87 |     """Ejecuta Safety para verificar vulnerabilidades en dependencias."""
88 |     print("Ejecutando Safety para verificar vulnerabilidades en dependencias...")
   |
   = help: Add return type annotation: `bool`

scripts\backend_security_check.py:92:9: UP022 Prefer `capture_output` over sending `stdout` and `stderr` to `PIPE`
   |
90 |       # Instalar safety si no está instalado
91 |       try:
92 | /         subprocess.run(
93 | |             ["safety", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=False
94 | |         )
   | |_________^ UP022
95 |       except:
96 |           print("Instalando safety...")
   |
   = help: Replace with `capture_output` keyword argument

scripts\backend_security_check.py:92:9: S603 `subprocess` call: check for execution of untrusted input
   |
90 |     # Instalar safety si no está instalado
91 |     try:
92 |         subprocess.run(
   |         ^^^^^^^^^^^^^^ S603
93 |             ["safety", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=False
94 |         )
   |

scripts\backend_security_check.py:93:13: S607 Starting a process with a partial executable path
   |
91 |     try:
92 |         subprocess.run(
93 |             ["safety", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=False
   |             ^^^^^^^^^^^^^^^^^^^^^^^ S607
94 |         )
95 |     except:
   |

scripts\backend_security_check.py:95:5: E722 Do not use bare `except`
   |
93 |             ["safety", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=False
94 |         )
95 |     except:
   |     ^^^^^^ E722
96 |         print("Instalando safety...")
97 |         subprocess.run([sys.executable, "-m", "pip", "install", "safety"], check=False)
   |

scripts\backend_security_check.py:97:9: S603 `subprocess` call: check for execution of untrusted input
   |
95 |     except:
96 |         print("Instalando safety...")
97 |         subprocess.run([sys.executable, "-m", "pip", "install", "safety"], check=False)
   |         ^^^^^^^^^^^^^^ S603
98 |
99 |     # Verificar si existe requirements.txt
   |

scripts\backend_security_check.py:106:14: UP022 Prefer `capture_output` over sending `stdout` and `stderr` to `PIPE`
    |
105 |       # Ejecutar safety
106 |       result = subprocess.run(
    |  ______________^
107 | |         ["safety", "check", "-r", str(requirements_file), "--json"],
108 | |         stdout=subprocess.PIPE,
109 | |         stderr=subprocess.PIPE,
110 | |         text=True,
111 | |         check=False,
112 | |     )
    | |_____^ UP022
113 |
114 |       # Guardar resultados
    |
    = help: Replace with `capture_output` keyword argument

scripts\backend_security_check.py:106:14: S603 `subprocess` call: check for execution of untrusted input
    |
105 |     # Ejecutar safety
106 |     result = subprocess.run(
    |              ^^^^^^^^^^^^^^ S603
107 |         ["safety", "check", "-r", str(requirements_file), "--json"],
108 |         stdout=subprocess.PIPE,
    |

scripts\backend_security_check.py:107:9: S607 Starting a process with a partial executable path
    |
105 |     # Ejecutar safety
106 |     result = subprocess.run(
107 |         ["safety", "check", "-r", str(requirements_file), "--json"],
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S607
108 |         stdout=subprocess.PIPE,
109 |         stderr=subprocess.PIPE,
    |

scripts\backend_security_check.py:125:9: E722 Do not use bare `except`
    |
123 |                 print(f"⚠️ Se encontraron {len(vulnerabilities)} vulnerabilidades en dependencias")
124 |                 return False
125 |         except:
    |         ^^^^^^ E722
126 |             print(f"⚠️ Error al analizar los resultados de Safety: {result.stderr}")
127 |             return False
    |

scripts\backend_security_check.py:143:36: PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
    |
141 |         El secreto enmascarado, mostrando solo los primeros 4 caracteres
142 |     """
143 |     if not secret or len(secret) < 8:
    |                                    ^ PLR2004
144 |         return "[SECRETO REDACTADO]"
    |

scripts\backend_security_check.py:149:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
147 |     if "=" in secret:
148 |         parts = secret.split("=", 1)
149 |         if len(parts) == 2:
    |                          ^ PLR2004
150 |             key, value = parts
151 |             # Limpiar comillas
    |

scripts\backend_security_check.py:156:13: SIM108 Use ternary operator `masked_value = value[:4] + "*" * (len(value) - 4) if len(value) > 8 else "****"` instead of `if`-`else`-block
    |
154 |                   value = value[1:-1]
155 |               # Enmascarar solo el valor
156 | /             if len(value) > 8:
157 | |                 masked_value = value[:4] + "*" * (len(value) - 4)
158 | |             else:
159 | |                 masked_value = "****"
    | |_____________________________________^ SIM108
160 |               return f"{key}= [VALOR SENSIBLE: {masked_value}]"
    |
    = help: Replace `if`-`else`-block with `masked_value = value[:4] + "*" * (len(value) - 4) if len(value) > 8 else "****"`

scripts\backend_security_check.py:156:29: PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
    |
154 |                 value = value[1:-1]
155 |             # Enmascarar solo el valor
156 |             if len(value) > 8:
    |                             ^ PLR2004
157 |                 masked_value = value[:4] + "*" * (len(value) - 4)
158 |             else:
    |

scripts\backend_security_check.py:167:5: ANN201 Missing return type annotation for public function `check_hardcoded_secrets`
    |
167 | def check_hardcoded_secrets():
    |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
168 |     """Busca secretos hardcodeados en el código."""
169 |     print("Buscando secretos hardcodeados en el código...")
    |
    = help: Add return type annotation: `bool`

scripts\backend_security_check.py:260:33: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
258 |             print(f"  - {secret}")
259 |
260 |         if len(found_secrets) > 5:
    |                                 ^ PLR2004
261 |             print(f"  ... y {len(found_secrets) - 5} más")
    |

scripts\backend_security_check.py:269:5: ANN201 Missing return type annotation for public function `check_security_headers`
    |
269 | def check_security_headers():
    |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
270 |     """Verifica los encabezados de seguridad en la configuración de nginx."""
271 |     print("Verificando encabezados de seguridad...")
    |
    = help: Add return type annotation: `bool`

scripts\backend_security_check.py:301:5: ANN201 Missing return type annotation for public function `main`
    |
301 | def main():
    |     ^^^^ ANN201
302 |     """Función principal."""
303 |     print("🔒 Verificando seguridad del backend...")
    |
    = help: Add return type annotation: `int`

scripts\check_docstrings.py:37:12: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   |
35 |     # Check classes and functions
36 |     for node in ast.walk(tree):
37 |         if isinstance(node, (ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef)):
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
38 |             # Skip private methods/functions (starting with _)
39 |             if node.name.startswith("_") and node.name != "__init__":
   |
   = help: Convert to `X | Y`

scripts\check_docstrings.py:47:32: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   |
45 |                     f"Missing docstring for {node.__class__.__name__} '{node.name}' in {filename}"
46 |                 )
47 |             elif docstring and isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
48 |                 # Check function docstring sections
49 |                 if (
   |
   = help: Convert to `X | Y`

scripts\check_docstrings.py:59:101: E501 Line too long (114 > 100)
   |
57 |                 if "Returns:" not in docstring and node.returns:
58 |                     errors.append(
59 |                         f"Function '{node.name}' in {filename} has return annotation but missing Returns: section"
   |                                                                                                     ^^^^^^^^^^^^^^ E501
60 |                     )
   |

scripts\check_licenses.py:59:5: PLR0912 Too many branches (15 > 12)
   |
59 | def check_python_licenses():
   |     ^^^^^^^^^^^^^^^^^^^^^ PLR0912
60 |     """Verifica las licencias de las dependencias de Python."""
61 |     print("Verificando licencias de dependencias de Python...")
   |

scripts\check_licenses.py:59:5: ANN201 Missing return type annotation for public function `check_python_licenses`
   |
59 | def check_python_licenses():
   |     ^^^^^^^^^^^^^^^^^^^^^ ANN201
60 |     """Verifica las licencias de las dependencias de Python."""
61 |     print("Verificando licencias de dependencias de Python...")
   |
   = help: Add return type annotation: `bool`

scripts\check_licenses.py:65:9: UP022 Prefer `capture_output` over sending `stdout` and `stderr` to `PIPE`
   |
63 |       # Instalar pip-licenses si no está instalado
64 |       try:
65 | /         subprocess.run(
66 | |             [sys.executable, "-m", "pip", "show", "pip-licenses"],
67 | |             stdout=subprocess.PIPE,
68 | |             stderr=subprocess.PIPE,
69 | |             check=False,
70 | |         )
   | |_________^ UP022
71 |       except:
72 |           print("Instalando pip-licenses...")
   |
   = help: Replace with `capture_output` keyword argument

scripts\check_licenses.py:65:9: S603 `subprocess` call: check for execution of untrusted input
   |
63 |     # Instalar pip-licenses si no está instalado
64 |     try:
65 |         subprocess.run(
   |         ^^^^^^^^^^^^^^ S603
66 |             [sys.executable, "-m", "pip", "show", "pip-licenses"],
67 |             stdout=subprocess.PIPE,
   |

scripts\check_licenses.py:71:5: E722 Do not use bare `except`
   |
69 |             check=False,
70 |         )
71 |     except:
   |     ^^^^^^ E722
72 |         print("Instalando pip-licenses...")
73 |         subprocess.run([sys.executable, "-m", "pip", "install", "pip-licenses"], check=False)
   |

scripts\check_licenses.py:73:9: S603 `subprocess` call: check for execution of untrusted input
   |
71 |     except:
72 |         print("Instalando pip-licenses...")
73 |         subprocess.run([sys.executable, "-m", "pip", "install", "pip-licenses"], check=False)
   |         ^^^^^^^^^^^^^^ S603
74 |
75 |     # Obtener licencias
   |

scripts\check_licenses.py:76:14: UP022 Prefer `capture_output` over sending `stdout` and `stderr` to `PIPE`
   |
75 |       # Obtener licencias
76 |       result = subprocess.run(
   |  ______________^
77 | |         [sys.executable, "-m", "pip_licenses", "--format=json", "--with-system"],
78 | |         stdout=subprocess.PIPE,
79 | |         stderr=subprocess.PIPE,
80 | |         text=True,
81 | |         check=False,
82 | |     )
   | |_____^ UP022
83 |
84 |       if result.returncode != 0:
   |
   = help: Replace with `capture_output` keyword argument

scripts\check_licenses.py:76:14: S603 `subprocess` call: check for execution of untrusted input
   |
75 |     # Obtener licencias
76 |     result = subprocess.run(
   |              ^^^^^^^^^^^^^^ S603
77 |         [sys.executable, "-m", "pip_licenses", "--format=json", "--with-system"],
78 |         stdout=subprocess.PIPE,
   |

scripts\check_licenses.py:134:5: PLR0912 Too many branches (17 > 12)
    |
134 | def check_js_licenses():
    |     ^^^^^^^^^^^^^^^^^ PLR0912
135 |     """Verifica las licencias de las dependencias de JavaScript."""
136 |     print("Verificando licencias de dependencias de JavaScript...")
    |

scripts\check_licenses.py:134:5: ANN201 Missing return type annotation for public function `check_js_licenses`
    |
134 | def check_js_licenses():
    |     ^^^^^^^^^^^^^^^^^ ANN201
135 |     """Verifica las licencias de las dependencias de JavaScript."""
136 |     print("Verificando licencias de dependencias de JavaScript...")
    |
    = help: Add return type annotation: `bool`

scripts\check_licenses.py:145:18: UP022 Prefer `capture_output` over sending `stdout` and `stderr` to `PIPE`
    |
143 |       # Instalar license-checker si no está instalado
144 |       try:
145 |           result = subprocess.run(
    |  __________________^
146 | |             ["npx", "license-checker", "--version"],
147 | |             stdout=subprocess.PIPE,
148 | |             stderr=subprocess.PIPE,
149 | |             text=True,
150 | |             check=False,
151 | |         )
    | |_________^ UP022
152 |           if result.returncode != 0:
153 |               print("Instalando license-checker...")
    |
    = help: Replace with `capture_output` keyword argument

scripts\check_licenses.py:145:18: S603 `subprocess` call: check for execution of untrusted input
    |
143 |     # Instalar license-checker si no está instalado
144 |     try:
145 |         result = subprocess.run(
    |                  ^^^^^^^^^^^^^^ S603
146 |             ["npx", "license-checker", "--version"],
147 |             stdout=subprocess.PIPE,
    |

scripts\check_licenses.py:146:13: S607 Starting a process with a partial executable path
    |
144 |     try:
145 |         result = subprocess.run(
146 |             ["npx", "license-checker", "--version"],
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S607
147 |             stdout=subprocess.PIPE,
148 |             stderr=subprocess.PIPE,
    |

scripts\check_licenses.py:154:13: S603 `subprocess` call: check for execution of untrusted input
    |
152 |         if result.returncode != 0:
153 |             print("Instalando license-checker...")
154 |             subprocess.run(["npm", "install", "-g", "license-checker"], check=False)
    |             ^^^^^^^^^^^^^^ S603
155 |     except:
156 |         print("Error al verificar license-checker. Asegúrate de tener Node.js instalado.")
    |

scripts\check_licenses.py:154:28: S607 Starting a process with a partial executable path
    |
152 |         if result.returncode != 0:
153 |             print("Instalando license-checker...")
154 |             subprocess.run(["npm", "install", "-g", "license-checker"], check=False)
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S607
155 |     except:
156 |         print("Error al verificar license-checker. Asegúrate de tener Node.js instalado.")
    |

scripts\check_licenses.py:155:5: E722 Do not use bare `except`
    |
153 |             print("Instalando license-checker...")
154 |             subprocess.run(["npm", "install", "-g", "license-checker"], check=False)
155 |     except:
    |     ^^^^^^ E722
156 |         print("Error al verificar license-checker. Asegúrate de tener Node.js instalado.")
157 |         return False
    |

scripts\check_licenses.py:160:14: UP022 Prefer `capture_output` over sending `stdout` and `stderr` to `PIPE`
    |
159 |       # Obtener licencias
160 |       result = subprocess.run(
    |  ______________^
161 | |         ["npx", "license-checker", "--json"],
162 | |         stdout=subprocess.PIPE,
163 | |         stderr=subprocess.PIPE,
164 | |         text=True,
165 | |         cwd=frontend_dir,
166 | |         check=False,
167 | |     )
    | |_____^ UP022
168 |
169 |       if result.returncode != 0:
    |
    = help: Replace with `capture_output` keyword argument

scripts\check_licenses.py:160:14: S603 `subprocess` call: check for execution of untrusted input
    |
159 |     # Obtener licencias
160 |     result = subprocess.run(
    |              ^^^^^^^^^^^^^^ S603
161 |         ["npx", "license-checker", "--json"],
162 |         stdout=subprocess.PIPE,
    |

scripts\check_licenses.py:161:9: S607 Starting a process with a partial executable path
    |
159 |     # Obtener licencias
160 |     result = subprocess.run(
161 |         ["npx", "license-checker", "--json"],
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S607
162 |         stdout=subprocess.PIPE,
163 |         stderr=subprocess.PIPE,
    |

scripts\check_licenses.py:219:5: ANN201 Missing return type annotation for public function `create_license_exceptions_file`
    |
219 | def create_license_exceptions_file():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
220 |     """Crea un archivo de excepciones de licencias."""
221 |     exceptions_file = Path("license-exceptions.json")
    |
    = help: Add return type annotation: `None`

scripts\check_licenses.py:244:5: ANN201 Missing return type annotation for public function `main`
    |
244 | def main():
    |     ^^^^ ANN201
245 |     """Función principal."""
246 |     print("🔍 Verificando licencias de dependencias...")
    |
    = help: Add return type annotation: `int`

scripts\check_rst.py:142:16: F401 `docutils` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
141 |     try:
142 |         import docutils
    |                ^^^^^^^^ F401
143 |     except ImportError:
144 |         print("Error: docutils no está instalado. Instálelo con 'pip install docutils'")
    |
    = help: Remove unused import: `docutils`

scripts\check_security_headers.py:43:5: PLR0912 Too many branches (13 > 12)
   |
43 | def check_url(url: str) -> dict[str, Any]:
   |     ^^^^^^^^^ PLR0912
44 |     """
45 |     Verifica los encabezados de seguridad de una URL.
   |

scripts\check_security_headers.py:76:36: PLR2004 Magic value used in comparison, consider replacing `400` with a constant variable
   |
74 |         result["status_code"] = response.status_code
75 |
76 |         if response.status_code >= 400:
   |                                    ^^^ PLR2004
77 |             result["status"] = "error"
78 |             result["error"] = f"Error HTTP {response.status_code}"
   |

scripts\check_security_headers.py:117:9: TRY300 Consider moving this statement to an `else` block
    |
115 |             result["status"] = "insecure"
116 |
117 |         return result
    |         ^^^^^^^^^^^^^ TRY300
118 |     except requests.exceptions.RequestException as e:
119 |         result["status"] = "error"
    |

scripts\check_security_headers.py:128:5: PLR0912 Too many branches (14 > 12)
    |
128 | def generate_markdown_report(results: list[dict[str, Any]]) -> str:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
129 |     """
130 |     Genera un informe en formato Markdown con los resultados de la verificación.
    |

scripts\check_security_headers.py:187:101: E501 Line too long (111 > 100)
    |
186 |     report += "## Recomendaciones\n\n"
187 |     report += "Para mejorar la seguridad de tu sitio web, asegúrate de incluir los siguientes encabezados:\n\n"
    |                                                                                                     ^^^^^^^^^^^ E501
188 |
189 |     for header, valid_values in RECOMMENDED_HEADERS.items():
    |

scripts\check_types.py:5:1: I001 [*] Import block is un-sorted or un-formatted
   |
 3 |   Script para verificar los tipos en el proyecto usando mypy.
 4 |   """
 5 | / import os
 6 | | import sys
 7 | | import subprocess
 8 | | from pathlib import Path
   | |________________________^ I001
 9 |
10 |   def main():
   |
   = help: Organize imports

scripts\check_types.py:5:8: F401 [*] `os` imported but unused
  |
3 | Script para verificar los tipos en el proyecto usando mypy.
4 | """
5 | import os
  |        ^^ F401
6 | import sys
7 | import subprocess
  |
  = help: Remove unused import: `os`

scripts\check_types.py:10:5: ANN201 Missing return type annotation for public function `main`
   |
 8 | from pathlib import Path
 9 |
10 | def main():
   |     ^^^^ ANN201
11 |     """Ejecuta mypy en el proyecto."""
12 |     # Obtener el directorio raíz del proyecto
   |
   = help: Add return type annotation

scripts\check_types.py:14:1: W293 [*] Blank line contains whitespace
   |
12 |     # Obtener el directorio raíz del proyecto
13 |     root_dir = Path(__file__).parent.parent.absolute()
14 |
   | ^^^^ W293
15 |     # Directorios a verificar
16 |     dirs_to_check = [
   |
   = help: Remove whitespace from blank line

scripts\check_types.py:20:1: W293 [*] Blank line contains whitespace
   |
18 |         "tests",
19 |     ]
20 |
   | ^^^^ W293
21 |     # Construir el comando de mypy
22 |     cmd = ["mypy"]
   |
   = help: Remove whitespace from blank line

scripts\check_types.py:27:1: W293 [*] Blank line contains whitespace
   |
25 |         if dir_path.exists():
26 |             cmd.append(str(dir_path))
27 |
   | ^^^^ W293
28 |     # Ejecutar mypy
29 |     print(f"Ejecutando: {' '.join(cmd)}")
   |
   = help: Remove whitespace from blank line

scripts\check_types.py:30:14: S603 `subprocess` call: check for execution of untrusted input
   |
28 |     # Ejecutar mypy
29 |     print(f"Ejecutando: {' '.join(cmd)}")
30 |     result = subprocess.run(cmd, capture_output=True, text=True)
   |              ^^^^^^^^^^^^^^ S603
31 |
32 |     # Mostrar la salida
   |

scripts\check_types.py:30:14: PLW1510 [*] `subprocess.run` without explicit `check` argument
   |
28 |     # Ejecutar mypy
29 |     print(f"Ejecutando: {' '.join(cmd)}")
30 |     result = subprocess.run(cmd, capture_output=True, text=True)
   |              ^^^^^^^^^^^^^^ PLW1510
31 |
32 |     # Mostrar la salida
   |
   = help: Add explicit `check=False`

scripts\check_types.py:31:1: W293 [*] Blank line contains whitespace
   |
29 |     print(f"Ejecutando: {' '.join(cmd)}")
30 |     result = subprocess.run(cmd, capture_output=True, text=True)
31 |
   | ^^^^ W293
32 |     # Mostrar la salida
33 |     if result.stdout:
   |
   = help: Remove whitespace from blank line

scripts\check_types.py:37:1: W293 [*] Blank line contains whitespace
   |
35 |     if result.stderr:
36 |         print(result.stderr, file=sys.stderr)
37 |
   | ^^^^ W293
38 |     # Devolver el código de salida
39 |     return result.returncode
   |
   = help: Remove whitespace from blank line

scripts\fix_docstrings.py:12:21: F401 [*] `pathlib.Path` imported but unused
   |
10 | import os
11 | import sys
12 | from pathlib import Path
   |                     ^^^^ F401
13 | from typing import Dict, List, Optional, Set, Tuple
   |
   = help: Remove unused import: `pathlib.Path`

scripts\fix_docstrings.py:13:1: UP035 `typing.Dict` is deprecated, use `dict` instead
   |
11 | import sys
12 | from pathlib import Path
13 | from typing import Dict, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP035
   |

scripts\fix_docstrings.py:13:1: UP035 `typing.List` is deprecated, use `list` instead
   |
11 | import sys
12 | from pathlib import Path
13 | from typing import Dict, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP035
   |

scripts\fix_docstrings.py:13:1: UP035 `typing.Set` is deprecated, use `set` instead
   |
11 | import sys
12 | from pathlib import Path
13 | from typing import Dict, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP035
   |

scripts\fix_docstrings.py:13:1: UP035 `typing.Tuple` is deprecated, use `tuple` instead
   |
11 | import sys
12 | from pathlib import Path
13 | from typing import Dict, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP035
   |

scripts\fix_docstrings.py:13:32: F401 [*] `typing.Optional` imported but unused
   |
11 | import sys
12 | from pathlib import Path
13 | from typing import Dict, List, Optional, Set, Tuple
   |                                ^^^^^^^^ F401
   |
   = help: Remove unused import

scripts\fix_docstrings.py:13:47: F401 [*] `typing.Tuple` imported but unused
   |
11 | import sys
12 | from pathlib import Path
13 | from typing import Dict, List, Optional, Set, Tuple
   |                                               ^^^^^ F401
   |
   = help: Remove unused import

scripts\fix_docstrings.py:16:40: UP006 [*] Use `list` instead of `List` for type annotation
   |
16 | def check_docstrings(filename: str) -> List[Dict[str, str]]:
   |                                        ^^^^ UP006
17 |     """
18 |     Verifica docstrings en un archivo Python.
   |
   = help: Replace with `list`

scripts\fix_docstrings.py:16:45: UP006 [*] Use `dict` instead of `Dict` for type annotation
   |
16 | def check_docstrings(filename: str) -> List[Dict[str, str]]:
   |                                             ^^^^ UP006
17 |     """
18 |     Verifica docstrings en un archivo Python.
   |
   = help: Replace with `dict`

scripts\fix_docstrings.py:48:12: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   |
46 |     # Verificar clases y funciones
47 |     for node in ast.walk(tree):
48 |         if isinstance(node, (ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef)):
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
49 |             # Omitir métodos/funciones privados (que comienzan con _)
50 |             if node.name.startswith("_") and node.name != "__init__":
   |
   = help: Convert to `X | Y`

scripts\fix_docstrings.py:59:101: E501 Line too long (114 > 100)
   |
57 |                         "type": node.__class__.__name__,
58 |                         "name": node.name,
59 |                         "message": f"Missing docstring for {node.__class__.__name__} '{node.name}' in {filename}",
   |                                                                                                     ^^^^^^^^^^^^^^ E501
60 |                         "lineno": node.lineno,
61 |                         "args": [arg.arg for arg in node.args.args] if hasattr(node, "args") else [],
   |

scripts\fix_docstrings.py:61:101: E501 Line too long (101 > 100)
   |
59 |                         "message": f"Missing docstring for {node.__class__.__name__} '{node.name}' in {filename}",
60 |                         "lineno": node.lineno,
61 |                         "args": [arg.arg for arg in node.args.args] if hasattr(node, "args") else [],
   |                                                                                                     ^ E501
62 |                         "returns": node.returns is not None if hasattr(node, "returns") else False,
63 |                     }
   |

scripts\fix_docstrings.py:65:32: UP038 Use `X | Y` in `isinstance` call instead of `(X, Y)`
   |
63 |                     }
64 |                 )
65 |             elif docstring and isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP038
66 |                 # Verificar secciones del docstring de la función
67 |                 missing_sections = []
   |
   = help: Convert to `X | Y`

scripts\fix_docstrings.py:68:1: W293 [*] Blank line contains whitespace
   |
66 |                 # Verificar secciones del docstring de la función
67 |                 missing_sections = []
68 |
   | ^^^^^^^^^^^^^^^^ W293
69 |                 # Verificar sección Args
70 |                 if (
   |
   = help: Remove whitespace from blank line

scripts\fix_docstrings.py:77:1: W293 [*] Blank line contains whitespace
   |
75 |                     # El primer arg podría ser self/cls, así que solo advertir si hay más de 1 arg
76 |                     missing_sections.append("Args")
77 |
   | ^^^^^^^^^^^^^^^^ W293
78 |                 # Verificar sección Returns
79 |                 if "Returns:" not in docstring and node.returns:
   |
   = help: Remove whitespace from blank line

scripts\fix_docstrings.py:81:1: W293 [*] Blank line contains whitespace
   |
79 |                 if "Returns:" not in docstring and node.returns:
80 |                     missing_sections.append("Returns")
81 |
   | ^^^^^^^^^^^^^^^^ W293
82 |                 if missing_sections:
83 |                     errors.append(
   |
   = help: Remove whitespace from blank line

scripts\fix_docstrings.py:87:101: E501 Line too long (130 > 100)
   |
85 | …                     "type": "incomplete_docstring",
86 | …                     "name": node.name,
87 | …                     "message": f"Function '{node.name}' in {filename} is missing sections: {', '.join(missing_sections)}",
   |                                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
88 | …                     "lineno": node.lineno,
89 | …                     "missing_sections": missing_sections,
   |

scripts\fix_docstrings.py:90:101: E501 Line too long (105 > 100)
   |
88 |                             "lineno": node.lineno,
89 |                             "missing_sections": missing_sections,
90 |                             "args": [arg.arg for arg in node.args.args] if hasattr(node, "args") else [],
   |                                                                                                     ^^^^^ E501
91 |                             "returns": node.returns is not None if hasattr(node, "returns") else False,
92 |                         }
   |

scripts\fix_docstrings.py:91:101: E501 Line too long (103 > 100)
   |
89 |                             "missing_sections": missing_sections,
90 |                             "args": [arg.arg for arg in node.args.args] if hasattr(node, "args") else [],
91 |                             "returns": node.returns is not None if hasattr(node, "returns") else False,
   |                                                                                                     ^^^ E501
92 |                         }
93 |                     )
   |

scripts\fix_docstrings.py:98:40: UP006 [*] Use `dict` instead of `Dict` for type annotation
    |
 98 | def generate_docstring_template(error: Dict[str, str]) -> str:
    |                                        ^^^^ UP006
 99 |     """
100 |     Genera una plantilla de docstring basada en el tipo de error.
    |
    = help: Replace with `dict`

scripts\fix_docstrings.py:110:1: W293 [*] Blank line contains whitespace
    |
108 |     if error["type"] == "module":
109 |         return '"""Descripción del módulo."""\n'
110 |
    | ^^^^ W293
111 |     elif error["type"] == "ClassDef":
112 |         return '"""Descripción de la clase."""\n'
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:111:5: RET505 [*] Unnecessary `elif` after `return` statement
    |
109 |         return '"""Descripción del módulo."""\n'
110 |
111 |     elif error["type"] == "ClassDef":
    |     ^^^^ RET505
112 |         return '"""Descripción de la clase."""\n'
    |
    = help: Remove unnecessary `elif`

scripts\fix_docstrings.py:113:1: W293 [*] Blank line contains whitespace
    |
111 |     elif error["type"] == "ClassDef":
112 |         return '"""Descripción de la clase."""\n'
113 |
    | ^^^^ W293
114 |     elif error["type"] in ["FunctionDef", "AsyncFunctionDef"]:
115 |         template = '"""Descripción de la función.\n\n'
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:116:1: W293 [*] Blank line contains whitespace
    |
114 |     elif error["type"] in ["FunctionDef", "AsyncFunctionDef"]:
115 |         template = '"""Descripción de la función.\n\n'
116 |
    | ^^^^^^^^ W293
117 |         # Agregar sección Args si hay argumentos
118 |         args = error.get("args", [])
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:126:1: W293 [*] Blank line contains whitespace
    |
124 |                 template += f"    {arg}: Descripción del parámetro\n"
125 |             template += "\n"
126 |
    | ^^^^^^^^ W293
127 |         # Agregar sección Returns si la función tiene anotación de retorno
128 |         if error.get("returns", False):
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:130:1: W293 [*] Blank line contains whitespace
    |
128 |         if error.get("returns", False):
129 |             template += "Returns:\n    Descripción del valor de retorno\n"
130 |
    | ^^^^^^^^ W293
131 |         template += '"""'
132 |         return template
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:133:1: W293 [*] Blank line contains whitespace
    |
131 |         template += '"""'
132 |         return template
133 |
    | ^^^^ W293
134 |     elif error["type"] == "incomplete_docstring":
135 |         template = "Secciones faltantes:\n"
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:136:1: W293 [*] Blank line contains whitespace
    |
134 |     elif error["type"] == "incomplete_docstring":
135 |         template = "Secciones faltantes:\n"
136 |
    | ^^^^^^^^ W293
137 |         if "Args" in error.get("missing_sections", []):
138 |             template += "\nArgs:\n"
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:143:1: W293 [*] Blank line contains whitespace
    |
141 |                     continue
142 |                 template += f"    {arg}: Descripción del parámetro\n"
143 |
    | ^^^^^^^^ W293
144 |         if "Returns" in error.get("missing_sections", []):
145 |             template += "\nReturns:\n    Descripción del valor de retorno\n"
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:146:1: W293 [*] Blank line contains whitespace
    |
144 |         if "Returns" in error.get("missing_sections", []):
145 |             template += "\nReturns:\n    Descripción del valor de retorno\n"
146 |
    | ^^^^^^^^ W293
147 |         return template
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:148:1: W293 [*] Blank line contains whitespace
    |
147 |         return template
148 |
    | ^^^^ W293
149 |     return "No se pudo generar una plantilla para este tipo de error."
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:152:53: UP006 [*] Use `set` instead of `Set` for type annotation
    |
152 | def find_python_files(directory: str, exclude_dirs: Set[str]) -> List[str]:
    |                                                     ^^^ UP006
153 |     """
154 |     Encuentra todos los archivos Python en un directorio y sus subdirectorios.
    |
    = help: Replace with `set`

scripts\fix_docstrings.py:152:66: UP006 [*] Use `list` instead of `List` for type annotation
    |
152 | def find_python_files(directory: str, exclude_dirs: Set[str]) -> List[str]:
    |                                                                  ^^^^ UP006
153 |     """
154 |     Encuentra todos los archivos Python en un directorio y sus subdirectorios.
    |
    = help: Replace with `list`

scripts\fix_docstrings.py:167:1: W293 [*] Blank line contains whitespace
    |
165 |         # Excluir directorios no deseados
166 |         dirs[:] = [d for d in dirs if d not in exclude_dirs]
167 |
    | ^^^^^^^^ W293
168 |         for file in files:
169 |             if file.endswith(".py"):
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:171:1: W293 [*] Blank line contains whitespace
    |
169 |             if file.endswith(".py"):
170 |                 python_files.append(os.path.join(root, file))
171 |
    | ^^^^ W293
172 |     return python_files
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:184:101: E501 Line too long (102 > 100)
    |
182 |     import argparse
183 |
184 |     parser = argparse.ArgumentParser(description="Verificar y corregir docstrings en archivos Python")
    |                                                                                                     ^^ E501
185 |     parser.add_argument("--directory", "-d", default="backend-call-automation", help="Directorio a verificar")
186 |     parser.add_argument("--output", "-o", help="Archivo de salida para el informe")
    |

scripts\fix_docstrings.py:185:101: E501 Line too long (110 > 100)
    |
184 |     parser = argparse.ArgumentParser(description="Verificar y corregir docstrings en archivos Python")
185 |     parser.add_argument("--directory", "-d", default="backend-call-automation", help="Directorio a verificar")
    |                                                                                                     ^^^^^^^^^^ E501
186 |     parser.add_argument("--output", "-o", help="Archivo de salida para el informe")
187 |     parser.add_argument("--fix", "-f", action="store_true", help="Generar plantillas para docstrings faltantes")
    |

scripts\fix_docstrings.py:187:101: E501 Line too long (112 > 100)
    |
185 |     parser.add_argument("--directory", "-d", default="backend-call-automation", help="Directorio a verificar")
186 |     parser.add_argument("--output", "-o", help="Archivo de salida para el informe")
187 |     parser.add_argument("--fix", "-f", action="store_true", help="Generar plantillas para docstrings faltantes")
    |                                                                                                     ^^^^^^^^^^^^ E501
188 |     args = parser.parse_args()
    |

scripts\fix_docstrings.py:211:1: W293 [*] Blank line contains whitespace
    |
209 |     # Encontrar archivos Python
210 |     python_files = find_python_files(args.directory, exclude_dirs)
211 |
    | ^^^^ W293
212 |     # Verificar docstrings
213 |     all_errors = []
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:217:1: W293 [*] Blank line contains whitespace
    |
215 |         errors = check_docstrings(file)
216 |         all_errors.extend(errors)
217 |
    | ^^^^ W293
218 |     # Ordenar errores por archivo y línea
219 |     all_errors.sort(key=lambda e: (e.get("name", ""), e.get("lineno", 0)))
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:220:1: W293 [*] Blank line contains whitespace
    |
218 |     # Ordenar errores por archivo y línea
219 |     all_errors.sort(key=lambda e: (e.get("name", ""), e.get("lineno", 0)))
220 |
    | ^^^^ W293
221 |     # Generar informe
222 |     report = []
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:225:1: W293 [*] Blank line contains whitespace
    |
223 |     report.append(f"Docstring Check Report - {len(all_errors)} issues found\n")
224 |     report.append("=" * 80 + "\n")
225 |
    | ^^^^ W293
226 |     current_file = None
227 |     for error in all_errors:
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:232:1: W293 [*] Blank line contains whitespace
    |
230 |             report.append(f"\nFile: {current_file}\n")
231 |             report.append("-" * 80 + "\n")
232 |
    | ^^^^^^^^ W293
233 |         report.append(f"Line {error.get('lineno', '?')}: {error['message']}\n")
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:234:1: W293 [*] Blank line contains whitespace
    |
233 |         report.append(f"Line {error.get('lineno', '?')}: {error['message']}\n")
234 |
    | ^^^^^^^^ W293
235 |         if args.fix:
236 |             template = generate_docstring_template(error)
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:241:1: W293 [*] Blank line contains whitespace
    |
239 |                 report.append(f"    {line}\n")
240 |             report.append("\n")
241 |
    | ^^^^ W293
242 |     # Escribir informe
243 |     report_text = "".join(report)
    |
    = help: Remove whitespace from blank line

scripts\fix_docstrings.py:250:1: W293 [*] Blank line contains whitespace
    |
248 |     else:
249 |         print(report_text)
250 |
    | ^^^^ W293
251 |     return 1 if all_errors else 0
    |
    = help: Remove whitespace from blank line

scripts\fix_tests.py:7:1: I001 [*] Import block is un-sorted or un-formatted
   |
 5 |   """
 6 |
 7 | / import os
 8 | | import sys
 9 | | import subprocess
10 | | import shutil
11 | | from pathlib import Path
   | |________________________^ I001
12 |
13 |   def ensure_directory_exists(directory):
   |
   = help: Organize imports

scripts\fix_tests.py:10:8: F401 [*] `shutil` imported but unused
   |
 8 | import sys
 9 | import subprocess
10 | import shutil
   |        ^^^^^^ F401
11 | from pathlib import Path
   |
   = help: Remove unused import: `shutil`

scripts\fix_tests.py:13:5: ANN201 Missing return type annotation for public function `ensure_directory_exists`
   |
11 | from pathlib import Path
12 |
13 | def ensure_directory_exists(directory):
   |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
14 |     """Asegura que un directorio existe."""
15 |     os.makedirs(directory, exist_ok=True)
   |
   = help: Add return type annotation: `None`

scripts\fix_tests.py:13:29: ANN001 Missing type annotation for function argument `directory`
   |
11 | from pathlib import Path
12 |
13 | def ensure_directory_exists(directory):
   |                             ^^^^^^^^^ ANN001
14 |     """Asegura que un directorio existe."""
15 |     os.makedirs(directory, exist_ok=True)
   |

scripts\fix_tests.py:18:5: ANN201 Missing return type annotation for public function `ensure_file_exists`
   |
16 |     print(f"✅ Directorio {directory} verificado")
17 |
18 | def ensure_file_exists(file_path, content=""):
   |     ^^^^^^^^^^^^^^^^^^ ANN201
19 |     """Asegura que un archivo existe."""
20 |     if not os.path.exists(file_path):
   |
   = help: Add return type annotation: `None`

scripts\fix_tests.py:18:24: ANN001 Missing type annotation for function argument `file_path`
   |
16 |     print(f"✅ Directorio {directory} verificado")
17 |
18 | def ensure_file_exists(file_path, content=""):
   |                        ^^^^^^^^^ ANN001
19 |     """Asegura que un archivo existe."""
20 |     if not os.path.exists(file_path):
   |

scripts\fix_tests.py:18:35: ANN001 Missing type annotation for function argument `content`
   |
16 |     print(f"✅ Directorio {directory} verificado")
17 |
18 | def ensure_file_exists(file_path, content=""):
   |                                   ^^^^^^^ ANN001
19 |     """Asegura que un archivo existe."""
20 |     if not os.path.exists(file_path):
   |

scripts\fix_tests.py:27:5: ANN201 Missing return type annotation for public function `install_dependencies`
   |
25 |         print(f"✅ Archivo {file_path} verificado")
26 |
27 | def install_dependencies(requirements_file, dev_requirements=None):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
28 |     """Instala las dependencias necesarias."""
29 |     if os.path.exists(requirements_file):
   |
   = help: Add return type annotation: `None`

scripts\fix_tests.py:27:26: ANN001 Missing type annotation for function argument `requirements_file`
   |
25 |         print(f"✅ Archivo {file_path} verificado")
26 |
27 | def install_dependencies(requirements_file, dev_requirements=None):
   |                          ^^^^^^^^^^^^^^^^^ ANN001
28 |     """Instala las dependencias necesarias."""
29 |     if os.path.exists(requirements_file):
   |

scripts\fix_tests.py:27:45: ANN001 Missing type annotation for function argument `dev_requirements`
   |
25 |         print(f"✅ Archivo {file_path} verificado")
26 |
27 | def install_dependencies(requirements_file, dev_requirements=None):
   |                                             ^^^^^^^^^^^^^^^^ ANN001
28 |     """Instala las dependencias necesarias."""
29 |     if os.path.exists(requirements_file):
   |

scripts\fix_tests.py:31:9: S603 `subprocess` call: check for execution of untrusted input
   |
29 |     if os.path.exists(requirements_file):
30 |         print(f"Instalando dependencias desde {requirements_file}...")
31 |         subprocess.run([sys.executable, "-m", "pip", "install", "-r", requirements_file], check=False)
   |         ^^^^^^^^^^^^^^ S603
32 |         print("✅ Dependencias instaladas")
33 |     else:
   |

scripts\fix_tests.py:31:101: E501 Line too long (102 > 100)
   |
29 |     if os.path.exists(requirements_file):
30 |         print(f"Instalando dependencias desde {requirements_file}...")
31 |         subprocess.run([sys.executable, "-m", "pip", "install", "-r", requirements_file], check=False)
   |                                                                                                     ^^ E501
32 |         print("✅ Dependencias instaladas")
33 |     else:
   |

scripts\fix_tests.py:38:9: S603 `subprocess` call: check for execution of untrusted input
   |
36 |     if dev_requirements and os.path.exists(dev_requirements):
37 |         print(f"Instalando dependencias de desarrollo desde {dev_requirements}...")
38 |         subprocess.run([sys.executable, "-m", "pip", "install", "-r", dev_requirements], check=False)
   |         ^^^^^^^^^^^^^^ S603
39 |         print("✅ Dependencias de desarrollo instaladas")
   |

scripts\fix_tests.py:38:101: E501 Line too long (101 > 100)
   |
36 |     if dev_requirements and os.path.exists(dev_requirements):
37 |         print(f"Instalando dependencias de desarrollo desde {dev_requirements}...")
38 |         subprocess.run([sys.executable, "-m", "pip", "install", "-r", dev_requirements], check=False)
   |                                                                                                     ^ E501
39 |         print("✅ Dependencias de desarrollo instaladas")
   |

scripts\fix_tests.py:41:5: ANN201 Missing return type annotation for public function `install_test_dependencies`
   |
39 |         print("✅ Dependencias de desarrollo instaladas")
40 |
41 | def install_test_dependencies():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
42 |     """Instala las dependencias necesarias para las pruebas."""
43 |     test_deps = ["pytest", "pytest-asyncio", "pytest-cov", "httpx"]
   |
   = help: Add return type annotation: `None`

scripts\fix_tests.py:45:5: S603 `subprocess` call: check for execution of untrusted input
   |
43 |     test_deps = ["pytest", "pytest-asyncio", "pytest-cov", "httpx"]
44 |     print("Instalando dependencias de prueba...")
45 |     subprocess.run([sys.executable, "-m", "pip", "install"] + test_deps, check=False)
   |     ^^^^^^^^^^^^^^ S603
46 |     print("✅ Dependencias de prueba instaladas")
   |

scripts\fix_tests.py:45:20: RUF005 Consider iterable unpacking instead of concatenation
   |
43 |     test_deps = ["pytest", "pytest-asyncio", "pytest-cov", "httpx"]
44 |     print("Instalando dependencias de prueba...")
45 |     subprocess.run([sys.executable, "-m", "pip", "install"] + test_deps, check=False)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ RUF005
46 |     print("✅ Dependencias de prueba instaladas")
   |
   = help: Replace with iterable unpacking

scripts\fix_tests.py:48:5: ANN201 Missing return type annotation for public function `create_test_env_file`
   |
46 |     print("✅ Dependencias de prueba instaladas")
47 |
48 | def create_test_env_file(env_file):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
49 |     """Crea un archivo .env para pruebas si no existe."""
50 |     if not os.path.exists(env_file):
   |
   = help: Add return type annotation: `None`

scripts\fix_tests.py:48:26: ANN001 Missing type annotation for function argument `env_file`
   |
46 |     print("✅ Dependencias de prueba instaladas")
47 |
48 | def create_test_env_file(env_file):
   |                          ^^^^^^^^ ANN001
49 |     """Crea un archivo .env para pruebas si no existe."""
50 |     if not os.path.exists(env_file):
   |

scripts\fix_tests.py:71:5: ANN201 Missing return type annotation for public function `fix_conftest_if_needed`
   |
69 |         print(f"✅ Archivo {env_file} verificado")
70 |
71 | def fix_conftest_if_needed(conftest_path):
   |     ^^^^^^^^^^^^^^^^^^^^^^ ANN201
72 |     """Corrige el archivo conftest.py si es necesario."""
73 |     if not os.path.exists(conftest_path):
   |
   = help: Add return type annotation: `None`

scripts\fix_tests.py:71:28: ANN001 Missing type annotation for function argument `conftest_path`
   |
69 |         print(f"✅ Archivo {env_file} verificado")
70 |
71 | def fix_conftest_if_needed(conftest_path):
   |                            ^^^^^^^^^^^^^ ANN001
72 |     """Corrige el archivo conftest.py si es necesario."""
73 |     if not os.path.exists(conftest_path):
   |

scripts\fix_tests.py:102:5: ANN201 Missing return type annotation for public function `main`
    |
100 |         print(f"✅ Archivo {conftest_path} verificado")
101 |
102 | def main():
    |     ^^^^ ANN201
103 |     """Función principal."""
104 |     print("🔧 Preparando entorno para pruebas...")
    |
    = help: Add return type annotation: `int`

scripts\fix_tests.py:109:5: F841 Local variable `frontend_dir` is assigned to but never used
    |
107 |     root_dir = Path(__file__).parent.parent.absolute()
108 |     backend_dir = root_dir / "backend-call-automation"
109 |     frontend_dir = root_dir / "frontend-call-automation"
    |     ^^^^^^^^^^^^ F841
110 |
111 |     # Verificar directorios necesarios
    |
    = help: Remove assignment to unused variable `frontend_dir`

scripts\fix_type_annotations.py:94:13: PLW2901 `for` loop variable `arg` overwritten by assignment target
   |
93 |         for arg in args:
94 |             arg = arg.strip()
   |             ^^^ PLW2901
95 |             if arg and ":" not in arg and arg != "self" and arg != "cls":
96 |                 typed_args.append(f"{arg}: Any")
   |

scripts\fix_type_annotations.py:95:16: PLR1714 Consider merging multiple comparisons: `arg not in {"self", "cls"}`.
   |
93 |         for arg in args:
94 |             arg = arg.strip()
95 |             if arg and ":" not in arg and arg != "self" and arg != "cls":
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR1714
96 |                 typed_args.append(f"{arg}: Any")
97 |             else:
   |
   = help: Merge multiple comparisons

scripts\fix_type_annotations.py:122:5: PLR0912 Too many branches (13 > 12)
    |
122 | def fix_file(file_path: str, dry_run: bool = False) -> tuple[int, list[str]]:
    |     ^^^^^^^^ PLR0912
123 |     """
124 |     Corrige problemas de tipos en un archivo.
    |

scripts\improved_security_utils.py:35:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
33 |     if "=" in secret:
34 |         parts = secret.split("=", 1)
35 |         if len(parts) == 2:
   |                          ^ PLR2004
36 |             key, value = parts
37 |             # Limpiar comillas
   |

scripts\improved_security_utils.py:47:47: PLR2004 Magic value used in comparison, consider replacing `16` with a constant variable
   |
46 |     # Determinar la longitud aproximada para dar una idea del tamaño sin revelar el contenido exacto
47 |     length_category = "corto" if len(value) < 16 else "medio" if len(value) < 32 else "largo"
   |                                               ^^ PLR2004
48 |
49 |     if key:
   |

scripts\improved_security_utils.py:47:79: PLR2004 Magic value used in comparison, consider replacing `32` with a constant variable
   |
46 |     # Determinar la longitud aproximada para dar una idea del tamaño sin revelar el contenido exacto
47 |     length_category = "corto" if len(value) < 16 else "medio" if len(value) < 32 else "largo"
   |                                                                               ^^ PLR2004
48 |
49 |     if key:
   |

scripts\improved_security_utils.py:50:41: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
49 |     if key:
50 |         if show_prefix and len(value) > 4:
   |                                         ^ PLR2004
51 |             # Crear un hash del prefijo en lugar de mostrar los caracteres reales
52 |             prefix_hash = hashlib.md5(value[:4].encode()).hexdigest()[:6]
   |

scripts\improved_security_utils.py:52:27: S324 Probable use of insecure hash functions in `hashlib`: `md5`
   |
50 |         if show_prefix and len(value) > 4:
51 |             # Crear un hash del prefijo en lugar de mostrar los caracteres reales
52 |             prefix_hash = hashlib.md5(value[:4].encode()).hexdigest()[:6]
   |                           ^^^^^^^^^^^ S324
53 |             return f"{key}= [VALOR SENSIBLE: longitud={length_category}, id={hash_id}, prefijo-hash={prefix_hash}]"
54 |         return f"{key}= [VALOR SENSIBLE: longitud={length_category}, id={hash_id}]"
   |

scripts\improved_security_utils.py:53:101: E501 Line too long (115 > 100)
   |
51 |             # Crear un hash del prefijo en lugar de mostrar los caracteres reales
52 |             prefix_hash = hashlib.md5(value[:4].encode()).hexdigest()[:6]
53 |             return f"{key}= [VALOR SENSIBLE: longitud={length_category}, id={hash_id}, prefijo-hash={prefix_hash}]"
   |                                                                                                     ^^^^^^^^^^^^^^^ E501
54 |         return f"{key}= [VALOR SENSIBLE: longitud={length_category}, id={hash_id}]"
   |

scripts\improved_security_utils.py:61:16: RUF013 PEP 484 prohibits implicit `Optional`
   |
60 | def find_secrets(
61 |     base_dirs: list[str] = None,
   |                ^^^^^^^^^ RUF013
62 |     exclude_dirs: list[str] = None,
63 |     exclude_files: list[str] = None,
   |
   = help: Convert to `T | None`

scripts\improved_security_utils.py:62:19: RUF013 PEP 484 prohibits implicit `Optional`
   |
60 | def find_secrets(
61 |     base_dirs: list[str] = None,
62 |     exclude_dirs: list[str] = None,
   |                   ^^^^^^^^^ RUF013
63 |     exclude_files: list[str] = None,
64 |     additional_patterns: list[str] = None,
   |
   = help: Convert to `T | None`

scripts\improved_security_utils.py:63:20: RUF013 PEP 484 prohibits implicit `Optional`
   |
61 |     base_dirs: list[str] = None,
62 |     exclude_dirs: list[str] = None,
63 |     exclude_files: list[str] = None,
   |                    ^^^^^^^^^ RUF013
64 |     additional_patterns: list[str] = None,
65 | ) -> tuple[bool, list[str]]:
   |
   = help: Convert to `T | None`

scripts\improved_security_utils.py:64:26: RUF013 PEP 484 prohibits implicit `Optional`
   |
62 |     exclude_dirs: list[str] = None,
63 |     exclude_files: list[str] = None,
64 |     additional_patterns: list[str] = None,
   |                          ^^^^^^^^^ RUF013
65 | ) -> tuple[bool, list[str]]:
66 |     """
   |
   = help: Convert to `T | None`

scripts\improved_security_utils.py:216:101: E501 Line too long (109 > 100)
    |
214 |                                 line_number = content[: match.start()].count("\n") + 1
215 |
216 |                                 # Almacenar la ubicación del secreto pero enmascarar el valor de forma segura
    |                                                                                                     ^^^^^^^^^ E501
217 |                                 found_secrets.append(
218 |                                     f"{file_path}:{line_number}: {secure_mask_secret(value)}"
    |

scripts\improved_security_utils.py:249:19: S105 Possible hardcoded password assigned to: "test_secret"
    |
248 |     # Demostración de enmascaramiento seguro
249 |     test_secret = "api_key='abcd1234efgh5678'"
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ S105
250 |     print(f"Original: {test_secret}")
251 |     print(f"Enmascarado (inseguro): {test_secret[:7]}{'*' * (len(test_secret) - 7)}")
    |

scripts\install_precommit_deps.py:37:18: S603 `subprocess` call: check for execution of untrusted input
   |
35 |     """
36 |     try:
37 |         result = subprocess.run(cmd, capture_output=True, text=True, cwd=cwd, check=False)
   |                  ^^^^^^^^^^^^^^ S603
38 |         return result.returncode, result.stdout + result.stderr
39 |     except Exception as e:
   |

scripts\install_precommit_deps.py:65:32: RUF005 Consider iterable unpacking instead of concatenation
   |
64 |     print(f"Instalando: {', '.join(python_deps)}")
65 |     code, output = run_command([sys.executable, "-m", "pip", "install", "--upgrade"] + python_deps)
   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ RUF005
66 |
67 |     if code != 0:
   |
   = help: Replace with iterable unpacking

scripts\install_precommit_deps.py:90:101: E501 Line too long (108 > 100)
   |
88 |         if code != 0:
89 |             print(
90 |                 f"{YELLOW}No se pudo instalar Gitleaks con Homebrew. Intente instalarlo manualmente:{RESET}"
   |                                                                                                     ^^^^^^^^ E501
91 |             )
92 |             print("  Descargue desde: https://github.com/gitleaks/gitleaks/releases")
   |

scripts\install_precommit_deps.py:102:101: E501 Line too long (115 > 100)
    |
100 |             if code != 0:
101 |                 print(
102 |                     f"{YELLOW}No se pudo instalar Gitleaks automáticamente. Intente instalarlo manualmente:{RESET}"
    |                                                                                                     ^^^^^^^^^^^^^^^ E501
103 |                 )
104 |                 print("  Descargue desde: https://github.com/gitleaks/gitleaks/releases")
    |

scripts\install_precommit_deps.py:179:101: E501 Line too long (109 > 100)
    |
177 |     if not install_gitleaks():
178 |         print(
179 |             f"{YELLOW}Advertencia: Gitleaks no se instaló correctamente. Algunos hooks pueden fallar.{RESET}"
    |                                                                                                     ^^^^^^^^^ E501
180 |         )
    |

scripts\install_precommit_deps.py:185:101: E501 Line too long (105 > 100)
    |
183 |     if not install_kics():
184 |         print(
185 |             f"{YELLOW}Advertencia: KICS no se instaló correctamente. Algunos hooks pueden fallar.{RESET}"
    |                                                                                                     ^^^^^ E501
186 |         )
    |

scripts\quality_audit.py:27:15: TRY003 Avoid specifying long messages outside the exception class
   |
25 |     # Validar que todos los elementos del comando sean strings
26 |     if not all(isinstance(arg, str) for arg in command):
27 |         raise ValueError("Todos los argumentos del comando deben ser cadenas de texto.")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
28 |
29 |     # Validar que los argumentos no contengan caracteres potencialmente peligrosos
   |

scripts\quality_audit.py:32:19: TRY003 Avoid specifying long messages outside the exception class
   |
30 |     for arg in command:
31 |         if any(char in arg for char in [';', '&', '|', '`']):
32 |             raise ValueError(f"El argumento '{arg}' contiene caracteres no permitidos.")
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TRY003
33 |
34 |     process = subprocess.run(command, capture_output=True, text=True, shell=False, check=False)
   |

scripts\quality_audit.py:34:15: S603 `subprocess` call: check for execution of untrusted input
   |
32 |             raise ValueError(f"El argumento '{arg}' contiene caracteres no permitidos.")
33 |
34 |     process = subprocess.run(command, capture_output=True, text=True, shell=False, check=False)
   |               ^^^^^^^^^^^^^^ S603
35 |     return process.returncode, process.stdout
   |

scripts\review_false_positives.py:113:5: PLR0915 Too many statements (67 > 50)
    |
113 | def generate_report(
    |     ^^^^^^^^^^^^^^^ PLR0915
114 |     false_positives: list[dict[str, Any]],
115 |     true_positives: list[dict[str, Any]],
    |

scripts\review_false_positives.py:192:101: E501 Line too long (104 > 100)
    |
190 |         output.append("2. Corrija los problemas de seguridad encontrados.")
191 |         output.append(
192 |             "3. Considere implementar pruebas automatizadas para evitar que estos problemas se repitan."
    |                                                                                                     ^^^^ E501
193 |         )
194 |         output.append("")
    |

scripts\review_false_positives.py:203:101: E501 Line too long (105 > 100)
    |
201 |         )
202 |         output.append(
203 |             "2. Considere agregar patrones más específicos para reducir la cantidad de falsos positivos."
    |                                                                                                     ^^^^^ E501
204 |         )
205 |         output.append(
    |

scripts\run_tests.py:5:1: I001 [*] Import block is un-sorted or un-formatted
   |
 3 |   Script para ejecutar los tests del proyecto.
 4 |   """
 5 | / import os
 6 | | import sys
 7 | | import subprocess
 8 | | import argparse
 9 | | from pathlib import Path
   | |________________________^ I001
10 |
11 |   def main():
   |
   = help: Organize imports

scripts\run_tests.py:5:8: F401 [*] `os` imported but unused
  |
3 | Script para ejecutar los tests del proyecto.
4 | """
5 | import os
  |        ^^ F401
6 | import sys
7 | import subprocess
  |
  = help: Remove unused import: `os`

scripts\run_tests.py:11:5: PLR0912 Too many branches (19 > 12)
   |
 9 | from pathlib import Path
10 |
11 | def main():
   |     ^^^^ PLR0912
12 |     """Ejecuta los tests del proyecto."""
13 |     parser = argparse.ArgumentParser(description="Ejecuta los tests del proyecto")
   |

scripts\run_tests.py:11:5: PLR0915 Too many statements (58 > 50)
   |
 9 | from pathlib import Path
10 |
11 | def main():
   |     ^^^^ PLR0915
12 |     """Ejecuta los tests del proyecto."""
13 |     parser = argparse.ArgumentParser(description="Ejecuta los tests del proyecto")
   |

scripts\run_tests.py:11:5: ANN201 Missing return type annotation for public function `main`
   |
 9 | from pathlib import Path
10 |
11 | def main():
   |     ^^^^ ANN201
12 |     """Ejecuta los tests del proyecto."""
13 |     parser = argparse.ArgumentParser(description="Ejecuta los tests del proyecto")
   |
   = help: Add return type annotation

scripts\run_tests.py:23:1: W293 [*] Blank line contains whitespace
   |
21 |     # Obtener el directorio raíz del proyecto
22 |     root_dir = Path(__file__).parent.parent.absolute()
23 |
   | ^^^^ W293
24 |     # Si no se especifica ninguna opción, ejecutar todos los tests
25 |     if not args.backend and not args.frontend:
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:28:1: W293 [*] Blank line contains whitespace
   |
26 |         args.backend = True
27 |         args.frontend = True
28 |
   | ^^^^ W293
29 |     exit_code = 0
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:30:1: W293 [*] Blank line contains whitespace
   |
29 |     exit_code = 0
30 |
   | ^^^^ W293
31 |     # Ejecutar tests de backend
32 |     if args.backend:
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:35:1: W293 [*] Blank line contains whitespace
   |
33 |         print("=== Ejecutando tests de backend ===")
34 |         backend_cmd = ["pytest"]
35 |
   | ^^^^^^^^ W293
36 |         # Añadir opciones
37 |         if args.verbose:
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:39:1: W293 [*] Blank line contains whitespace
   |
37 |         if args.verbose:
38 |             backend_cmd.append("-v")
39 |
   | ^^^^^^^^ W293
40 |         if args.coverage:
41 |             backend_cmd.extend(["--cov=app", "--cov-report=term", "--cov-report=xml:coverage-backend.xml"])
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:41:101: E501 Line too long (107 > 100)
   |
40 |         if args.coverage:
41 |             backend_cmd.extend(["--cov=app", "--cov-report=term", "--cov-report=xml:coverage-backend.xml"])
   |                                                                                                     ^^^^^^^ E501
42 |
43 |         if args.pattern:
   |

scripts\run_tests.py:42:1: W293 [*] Blank line contains whitespace
   |
40 |         if args.coverage:
41 |             backend_cmd.extend(["--cov=app", "--cov-report=term", "--cov-report=xml:coverage-backend.xml"])
42 |
   | ^^^^^^^^ W293
43 |         if args.pattern:
44 |             backend_cmd.append(args.pattern)
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:47:1: W293 [*] Blank line contains whitespace
   |
45 |         else:
46 |             backend_cmd.append("tests/")
47 |
   | ^^^^^^^^ W293
48 |         # Ejecutar pytest
49 |         print(f"Ejecutando: {' '.join(backend_cmd)}")
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:50:26: S603 `subprocess` call: check for execution of untrusted input
   |
48 |         # Ejecutar pytest
49 |         print(f"Ejecutando: {' '.join(backend_cmd)}")
50 |         backend_result = subprocess.run(backend_cmd, cwd=root_dir)
   |                          ^^^^^^^^^^^^^^ S603
51 |
52 |         if backend_result.returncode != 0:
   |

scripts\run_tests.py:50:26: PLW1510 [*] `subprocess.run` without explicit `check` argument
   |
48 |         # Ejecutar pytest
49 |         print(f"Ejecutando: {' '.join(backend_cmd)}")
50 |         backend_result = subprocess.run(backend_cmd, cwd=root_dir)
   |                          ^^^^^^^^^^^^^^ PLW1510
51 |
52 |         if backend_result.returncode != 0:
   |
   = help: Add explicit `check=False`

scripts\run_tests.py:51:1: W293 [*] Blank line contains whitespace
   |
49 |         print(f"Ejecutando: {' '.join(backend_cmd)}")
50 |         backend_result = subprocess.run(backend_cmd, cwd=root_dir)
51 |
   | ^^^^^^^^ W293
52 |         if backend_result.returncode != 0:
53 |             exit_code = backend_result.returncode
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:57:1: W293 [*] Blank line contains whitespace
   |
55 |         else:
56 |             print("✅ Tests de backend exitosos")
57 |
   | ^^^^ W293
58 |     # Ejecutar tests de frontend
59 |     if args.frontend:
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:62:1: W293 [*] Blank line contains whitespace
   |
60 |         print("\n=== Ejecutando tests de frontend ===")
61 |         frontend_dir = root_dir / "frontend-call-automation"
62 |
   | ^^^^^^^^ W293
63 |         if not frontend_dir.exists():
64 |             print("⚠️ Directorio de frontend no encontrado, omitiendo tests")
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:73:1: W293 [*] Blank line contains whitespace
   |
71 |             else:
72 |                 cmd_prefix = ["npm", "run"]
73 |
   | ^^^^^^^^^^^^ W293
74 |             frontend_cmd = cmd_prefix + ["test"]
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:74:28: RUF005 Consider `[*cmd_prefix, "test"]` instead of concatenation
   |
72 |                 cmd_prefix = ["npm", "run"]
73 |
74 |             frontend_cmd = cmd_prefix + ["test"]
   |                            ^^^^^^^^^^^^^^^^^^^^^ RUF005
75 |
76 |             # Añadir opciones
   |
   = help: Replace with `[*cmd_prefix, "test"]`

scripts\run_tests.py:75:1: W293 [*] Blank line contains whitespace
   |
74 |             frontend_cmd = cmd_prefix + ["test"]
75 |
   | ^^^^^^^^^^^^ W293
76 |             # Añadir opciones
77 |             if args.coverage:
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:79:1: W293 [*] Blank line contains whitespace
   |
77 |             if args.coverage:
78 |                 frontend_cmd.append("--coverage")
79 |
   | ^^^^^^^^^^^^ W293
80 |             # Ejecutar tests de frontend
81 |             print(f"Ejecutando: {' '.join(frontend_cmd)}")
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:82:31: S603 `subprocess` call: check for execution of untrusted input
   |
80 |             # Ejecutar tests de frontend
81 |             print(f"Ejecutando: {' '.join(frontend_cmd)}")
82 |             frontend_result = subprocess.run(frontend_cmd, cwd=frontend_dir)
   |                               ^^^^^^^^^^^^^^ S603
83 |
84 |             if frontend_result.returncode != 0:
   |

scripts\run_tests.py:82:31: PLW1510 [*] `subprocess.run` without explicit `check` argument
   |
80 |             # Ejecutar tests de frontend
81 |             print(f"Ejecutando: {' '.join(frontend_cmd)}")
82 |             frontend_result = subprocess.run(frontend_cmd, cwd=frontend_dir)
   |                               ^^^^^^^^^^^^^^ PLW1510
83 |
84 |             if frontend_result.returncode != 0:
   |
   = help: Add explicit `check=False`

scripts\run_tests.py:83:1: W293 [*] Blank line contains whitespace
   |
81 |             print(f"Ejecutando: {' '.join(frontend_cmd)}")
82 |             frontend_result = subprocess.run(frontend_cmd, cwd=frontend_dir)
83 |
   | ^^^^^^^^^^^^ W293
84 |             if frontend_result.returncode != 0:
85 |                 exit_code = frontend_result.returncode
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:89:1: W293 [*] Blank line contains whitespace
   |
87 |             else:
88 |                 print("✅ Tests de frontend exitosos")
89 |
   | ^^^^ W293
90 |     # Resumen final
91 |     print("\n=== Resumen de tests ===")
   |
   = help: Remove whitespace from blank line

scripts\run_tests.py:96:1: W293 [*] Blank line contains whitespace
   |
94 |     else:
95 |         print(f"❌ Algunos tests han fallado (código de salida: {exit_code})")
96 |
   | ^^^^ W293
97 |     return exit_code
   |
   = help: Remove whitespace from blank line

scripts\security_check.py:68:21: S603 `subprocess` call: check for execution of untrusted input
   |
66 |     # Verificar que los archivos .env no estén en el control de versiones
67 |     try:
68 |         git_files = subprocess.check_output(["git", "ls-files"], text=True).splitlines()
   |                     ^^^^^^^^^^^^^^^^^^^^^^^ S603
69 |         tracked_env_files = [f for f in actual_env_files if str(f) in git_files]
   |

scripts\security_check.py:68:45: S607 Starting a process with a partial executable path
   |
66 |     # Verificar que los archivos .env no estén en el control de versiones
67 |     try:
68 |         git_files = subprocess.check_output(["git", "ls-files"], text=True).splitlines()
   |                                             ^^^^^^^^^^^^^^^^^^^ S607
69 |         tracked_env_files = [f for f in actual_env_files if str(f) in git_files]
   |

scripts\security_check.py:74:101: E501 Line too long (126 > 100)
   |
72 |             return (
73 |                 False,
74 |                 f"Los siguientes archivos .env están en control de versiones: {', '.join(str(f) for f in tracked_env_files)}",
   |                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ E501
75 |             )
76 |     except subprocess.SubprocessError:
   |

scripts\security_check.py:155:36: PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
    |
153 |         El secreto enmascarado, mostrando solo los primeros 4 caracteres
154 |     """
155 |     if not secret or len(secret) < 8:
    |                                    ^ PLR2004
156 |         return "[SECRETO REDACTADO]"
    |

scripts\security_check.py:161:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
159 |     if "=" in secret:
160 |         parts = secret.split("=", 1)
161 |         if len(parts) == 2:
    |                          ^ PLR2004
162 |             key, value = parts
163 |             # Limpiar comillas
    |

scripts\security_check.py:168:13: SIM108 Use ternary operator `masked_value = value[:4] + "*" * (len(value) - 4) if len(value) > 8 else "****"` instead of `if`-`else`-block
    |
166 |                   value = value[1:-1]
167 |               # Enmascarar solo el valor
168 | /             if len(value) > 8:
169 | |                 masked_value = value[:4] + "*" * (len(value) - 4)
170 | |             else:
171 | |                 masked_value = "****"
    | |_____________________________________^ SIM108
172 |               return f"{key}= [VALOR SENSIBLE: {masked_value}]"
    |
    = help: Replace `if`-`else`-block with `masked_value = value[:4] + "*" * (len(value) - 4) if len(value) > 8 else "****"`

scripts\security_check.py:168:29: PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
    |
166 |                 value = value[1:-1]
167 |             # Enmascarar solo el valor
168 |             if len(value) > 8:
    |                             ^ PLR2004
169 |                 masked_value = value[:4] + "*" * (len(value) - 4)
170 |             else:
    |

scripts\security_check.py:266:33: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
264 |             # Los secretos ya están enmascarados por la función mask_secret
265 |             print(f"  - {secret}")
266 |         if len(found_secrets) > 10:
    |                                 ^^ PLR2004
267 |             print(f"  ... y {len(found_secrets) - 10} más")
    |

scripts\security_check.py:271:101: E501 Line too long (104 > 100)
    |
269 |     if all_passed and secrets_check:
270 |         print(
271 |             f"\n{Colors.GREEN}{Colors.BOLD}✓ Todas las verificaciones de seguridad pasaron{Colors.ENDC}"
    |                                                                                                     ^^^^ E501
272 |         )
273 |         return 0
    |

scripts\security_check_local.py:41:48: PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   |
39 |                     El secreto enmascarado, mostrando solo los primeros 4 caracteres
40 |                 """
41 |                 if not secret or len(secret) < 8:
   |                                                ^ PLR2004
42 |                     return "[SECRETO REDACTADO]"
   |

scripts\security_check_local.py:47:38: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
45 |                 if "=" in secret:
46 |                     parts = secret.split("=", 1)
47 |                     if len(parts) == 2:
   |                                      ^ PLR2004
48 |                         key, value = parts
49 |                         # Limpiar comillas
   |

scripts\security_check_local.py:71:40: PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   |
69 |             El secreto enmascarado, mostrando solo los primeros 4 caracteres
70 |         """
71 |         if not secret or len(secret) < 8:
   |                                        ^ PLR2004
72 |             return "[SECRETO REDACTADO]"
   |

scripts\security_check_local.py:77:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
75 |         if "=" in secret:
76 |             parts = secret.split("=", 1)
77 |             if len(parts) == 2:
   |                              ^ PLR2004
78 |                 key, value = parts
79 |                 # Limpiar comillas
   |

scripts\security_check_local.py:144:18: S603 `subprocess` call: check for execution of untrusted input
    |
142 |     try:
143 |         # Usar shell=False para evitar problemas de seguridad
144 |         result = subprocess.run(cmd, capture_output=True, text=True, shell=False, check=False)
    |                  ^^^^^^^^^^^^^^ S603
145 |         return result.returncode, result.stdout + result.stderr
146 |     except Exception:
    |

scripts\security_check_local.py:263:101: E501 Line too long (101 > 100)
    |
261 |                     return (
262 |                         False,
263 |                         "No se pudo instalar safety. Instálala manualmente con 'pip install safety'",
    |                                                                                                     ^ E501
264 |                     )
    |

scripts\security_check_local.py:274:9: TRY300 Consider moving this statement to an `else` block
    |
272 |             )
273 |
274 |         return True, ""
    |         ^^^^^^^^^^^^^^^ TRY300
275 |     except Exception:
276 |         return (
    |

scripts\security_check_local.py:282:5: PLR0911 Too many return statements (7 > 6)
    |
282 | def check_js_dependencies() -> tuple[bool, str]:
    |     ^^^^^^^^^^^^^^^^^^^^^ PLR0911
283 |     """
284 |     Verifica vulnerabilidades en dependencias JavaScript.
    |

scripts\security_check_local.py:323:101: E501 Line too long (103 > 100)
    |
321 |                     return (
322 |                         False,
323 |                         f"Se encontraron {high_critical} vulnerabilidades de alta o crítica severidad",
    |                                                                                                     ^^^ E501
324 |                     )
325 |             except json.JSONDecodeError:
    |

scripts\security_check_local.py:331:9: TRY300 Consider moving this statement to an `else` block
    |
329 |                 )
330 |
331 |         return True, ""
    |         ^^^^^^^^^^^^^^^ TRY300
332 |     except Exception:
333 |         # Asegurarse de volver al directorio original en caso de error
    |

scripts\security_check_local.py:338:101: E501 Line too long (102 > 100)
    |
336 |         return (
337 |             False,
338 |             "Error al verificar dependencias JavaScript: Se produjo un error durante la verificación",
    |                                                                                                     ^^ E501
339 |         )
    |

scripts\security_check_local.py:342:5: PLR0912 Too many branches (23 > 12)
    |
342 | def check_secrets_in_code() -> tuple[bool, list[str]]:
    |     ^^^^^^^^^^^^^^^^^^^^^ PLR0912
343 |     """
344 |     Busca posibles secretos en el código.
    |

scripts\security_check_local.py:342:5: PLR0915 Too many statements (63 > 50)
    |
342 | def check_secrets_in_code() -> tuple[bool, list[str]]:
    |     ^^^^^^^^^^^^^^^^^^^^^ PLR0915
343 |     """
344 |     Busca posibles secretos en el código.
    |

scripts\security_check_local.py:368:9: SIM102 Use a single `if` statement instead of nested `if` statements
    |
366 |       # Intentar usar la función mejorada de búsqueda de secretos si está disponible
367 |       try:
368 | /         if "improved_security" in globals():
369 | |             # Si ya importamos el módulo improved_security_utils
370 | |             if hasattr(improved_security, "find_secrets"):
    | |__________________________________________________________^ SIM102
371 |                   return improved_security.find_secrets(
372 |                       exclude_dirs=exclude_dirs,
    |
    = help: Combine `if` statements using `and`

scripts\security_check_local.py:514:101: E501 Line too long (120 > 100)
    |
512 |                                     )
513 |                                     print(
514 |                                         f"  Se encontró un posible secreto en {file_path}:{line_number}: {masked_value}"
    |                                                                                                     ^^^^^^^^^^^^^^^^^^^^ E501
515 |                                     )
516 |                     except (UnicodeDecodeError, IsADirectoryError, PermissionError):
    |

scripts\security_check_local.py:570:9: ERA001 Found commented-out code
    |
568 |     if not secrets_check:
569 |         # No marcamos como fallo crítico si se encuentran secretos
570 |         # critical_passed = False
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
571 |         for secret in found_secrets:
572 |             print(f"  {YELLOW}{secret}{RESET}")
    |
    = help: Remove commented-out code

scripts\security_check_local.py:580:101: E501 Line too long (107 > 100)
    |
578 |         else:
579 |             print(
580 |                 f"{YELLOW}{BOLD}⚠ VERIFICACIONES CRÍTICAS PASARON, PERO ALGUNAS OPCIONALES FALLARON{RESET}"
    |                                                                                                     ^^^^^^^ E501
581 |             )
582 |             print(
    |

scripts\security_check_local.py:583:101: E501 Line too long (105 > 100)
    |
581 |             )
582 |             print(
583 |                 f"{YELLOW}Puedes continuar, pero considera resolver estos problemas en el futuro.{RESET}"
    |                                                                                                     ^^^^^ E501
584 |             )
585 |         return 0
    |

scripts\test_dependencies.py:16:5: ANN201 Missing return type annotation for public function `create_virtual_env`
   |
16 | def create_virtual_env(venv_dir):
   |     ^^^^^^^^^^^^^^^^^^ ANN201
17 |     """Crea un entorno virtual para probar las dependencias."""
18 |     print(f"Creando entorno virtual en {venv_dir}...")
   |
   = help: Add return type annotation

scripts\test_dependencies.py:16:24: ANN001 Missing type annotation for function argument `venv_dir`
   |
16 | def create_virtual_env(venv_dir):
   |                        ^^^^^^^^ ANN001
17 |     """Crea un entorno virtual para probar las dependencias."""
18 |     print(f"Creando entorno virtual en {venv_dir}...")
   |

scripts\test_dependencies.py:30:5: ANN201 Missing return type annotation for public function `install_dependencies`
   |
30 | def install_dependencies(pip_exe, requirements_file):
   |     ^^^^^^^^^^^^^^^^^^^^ ANN201
31 |     """Instala dependencias desde un archivo requirements.txt."""
32 |     print(f"Instalando dependencias desde {requirements_file}...")
   |
   = help: Add return type annotation: `bool`

scripts\test_dependencies.py:30:26: ANN001 Missing type annotation for function argument `pip_exe`
   |
30 | def install_dependencies(pip_exe, requirements_file):
   |                          ^^^^^^^ ANN001
31 |     """Instala dependencias desde un archivo requirements.txt."""
32 |     print(f"Instalando dependencias desde {requirements_file}...")
   |

scripts\test_dependencies.py:30:35: ANN001 Missing type annotation for function argument `requirements_file`
   |
30 | def install_dependencies(pip_exe, requirements_file):
   |                                   ^^^^^^^^^^^^^^^^^ ANN001
31 |     """Instala dependencias desde un archivo requirements.txt."""
32 |     print(f"Instalando dependencias desde {requirements_file}...")
   |

scripts\test_dependencies.py:33:14: S603 `subprocess` call: check for execution of untrusted input
   |
31 |     """Instala dependencias desde un archivo requirements.txt."""
32 |     print(f"Instalando dependencias desde {requirements_file}...")
33 |     result = subprocess.run(
   |              ^^^^^^^^^^^^^^ S603
34 |         [pip_exe, "install", "-r", requirements_file], capture_output=True, text=True, check=False
35 |     )
   |

scripts\test_dependencies.py:46:5: ANN201 Missing return type annotation for public function `check_dependency_conflicts`
   |
46 | def check_dependency_conflicts(pip_exe):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
47 |     """Verifica si hay conflictos de dependencias."""
48 |     print("Verificando conflictos de dependencias...")
   |
   = help: Add return type annotation: `bool`

scripts\test_dependencies.py:46:32: ANN001 Missing type annotation for function argument `pip_exe`
   |
46 | def check_dependency_conflicts(pip_exe):
   |                                ^^^^^^^ ANN001
47 |     """Verifica si hay conflictos de dependencias."""
48 |     print("Verificando conflictos de dependencias...")
   |

scripts\test_dependencies.py:49:14: S603 `subprocess` call: check for execution of untrusted input
   |
47 |     """Verifica si hay conflictos de dependencias."""
48 |     print("Verificando conflictos de dependencias...")
49 |     result = subprocess.run([pip_exe, "check"], capture_output=True, text=True, check=False)
   |              ^^^^^^^^^^^^^^ S603
50 |
51 |     if "No broken requirements found." in result.stdout:
   |

scripts\test_dependencies.py:59:5: ANN201 Missing return type annotation for public function `main`
   |
59 | def main():
   |     ^^^^ ANN201
60 |     """Función principal."""
61 |     # Obtener la ruta del proyecto
   |
   = help: Add return type annotation: `int`

scripts\test_dependencies.py:84:13: S603 `subprocess` call: check for execution of untrusted input
   |
82 |         # Actualizar pip (sin verificar errores)
83 |         try:
84 |             subprocess.run([pip_exe, "install", "--upgrade", "pip"], check=False)
   |             ^^^^^^^^^^^^^^ S603
85 |         except Exception as e:
86 |             print(f"Advertencia: No se pudo actualizar pip: {e}")
   |

scripts\test_dependencies.py:90:9: S603 `subprocess` call: check for execution of untrusted input
   |
89 |         # Instalar packaging primero para evitar conflictos
90 |         subprocess.run([pip_exe, "install", "packaging>=21.0,<28.0"], check=True)
   |         ^^^^^^^^^^^^^^ S603
91 |
92 |         # Instalar dependencias principales
   |

scripts\test_dependencies.py:103:101: E501 Line too long (101 > 100)
    |
101 |         if not install_dependencies(pip_exe, backend_requirements):
102 |             print(
103 |                 "Advertencia: Algunos paquetes del backend no pudieron instalarse, pero continuamos."
    |                                                                                                     ^ E501
104 |             )
    |

temp_venv\Scripts\restructuredtext-lint-script.py:2:101: E501 Line too long (101 > 100)
  |
1 | #!C:\Users\marti\Desktop\DESARROLLOSW\CALLi\temp_venv\Scripts\python.exe
2 | # EASY-INSTALL-ENTRY-SCRIPT: 'restructuredtext-lint==1.4.0','console_scripts','restructuredtext-lint'
  |                                                                                                     ^ E501
3 | import re
4 | import sys
  |

temp_venv\Scripts\restructuredtext-lint-script.py:18:5: ANN201 Missing return type annotation for public function `importlib_load_entry_point`
   |
18 | def importlib_load_entry_point(spec, group, name):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
19 |     dist_name, _, _ = spec.partition("==")
20 |     matches = (
   |
   = help: Add return type annotation

temp_venv\Scripts\restructuredtext-lint-script.py:18:32: ANN001 Missing type annotation for function argument `spec`
   |
18 | def importlib_load_entry_point(spec, group, name):
   |                                ^^^^ ANN001
19 |     dist_name, _, _ = spec.partition("==")
20 |     matches = (
   |

temp_venv\Scripts\restructuredtext-lint-script.py:18:38: ANN001 Missing type annotation for function argument `group`
   |
18 | def importlib_load_entry_point(spec, group, name):
   |                                      ^^^^^ ANN001
19 |     dist_name, _, _ = spec.partition("==")
20 |     matches = (
   |

temp_venv\Scripts\restructuredtext-lint-script.py:18:45: ANN001 Missing type annotation for function argument `name`
   |
18 | def importlib_load_entry_point(spec, group, name):
   |                                             ^^^^ ANN001
19 |     dist_name, _, _ = spec.partition("==")
20 |     matches = (
   |

temp_venv\Scripts\rst-lint-script.py:18:5: ANN201 Missing return type annotation for public function `importlib_load_entry_point`
   |
18 | def importlib_load_entry_point(spec, group, name):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
19 |     dist_name, _, _ = spec.partition("==")
20 |     matches = (
   |
   = help: Add return type annotation

temp_venv\Scripts\rst-lint-script.py:18:32: ANN001 Missing type annotation for function argument `spec`
   |
18 | def importlib_load_entry_point(spec, group, name):
   |                                ^^^^ ANN001
19 |     dist_name, _, _ = spec.partition("==")
20 |     matches = (
   |

temp_venv\Scripts\rst-lint-script.py:18:38: ANN001 Missing type annotation for function argument `group`
   |
18 | def importlib_load_entry_point(spec, group, name):
   |                                      ^^^^^ ANN001
19 |     dist_name, _, _ = spec.partition("==")
20 |     matches = (
   |

temp_venv\Scripts\rst-lint-script.py:18:45: ANN001 Missing type annotation for function argument `name`
   |
18 | def importlib_load_entry_point(spec, group, name):
   |                                             ^^^^ ANN001
19 |     dist_name, _, _ = spec.partition("==")
20 |     matches = (
   |

tests\app\services\test_ai_conversation_service.py:8:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
 8 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
 9 | def ai_conversation_service():
10 |     return AIConversationService()
   |
   = help: Remove parentheses

tests\app\services\test_ai_conversation_service.py:9:5: ANN201 Missing return type annotation for public function `ai_conversation_service`
   |
 8 | @pytest.fixture()
 9 | def ai_conversation_service():
   |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
10 |     return AIConversationService()
   |
   = help: Add return type annotation

tests\app\services\test_ai_conversation_service.py:13:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
13 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
14 | async def test_process_message(ai_conversation_service):
15 |     ai_conversation_service.get_from_cache = AsyncMock(return_value=None)
   |
   = help: Remove parentheses

tests\app\services\test_ai_conversation_service.py:14:11: ANN201 Missing return type annotation for public function `test_process_message`
   |
13 | @pytest.mark.asyncio()
14 | async def test_process_message(ai_conversation_service):
   |           ^^^^^^^^^^^^^^^^^^^^ ANN201
15 |     ai_conversation_service.get_from_cache = AsyncMock(return_value=None)
16 |     ai_conversation_service.analyze_sentiment = AsyncMock(
   |
   = help: Add return type annotation: `None`

tests\app\services\test_ai_conversation_service.py:14:32: ANN001 Missing type annotation for function argument `ai_conversation_service`
   |
13 | @pytest.mark.asyncio()
14 | async def test_process_message(ai_conversation_service):
   |                                ^^^^^^^^^^^^^^^^^^^^^^^ ANN001
15 |     ai_conversation_service.get_from_cache = AsyncMock(return_value=None)
16 |     ai_conversation_service.analyze_sentiment = AsyncMock(
   |

tests\app\services\test_ai_conversation_service.py:29:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
29 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
30 | async def test_analyze_sentiment(ai_conversation_service):
31 |     ai_conversation_service.llm.ainvoke = AsyncMock(
   |
   = help: Remove parentheses

tests\app\services\test_ai_conversation_service.py:30:11: ANN201 Missing return type annotation for public function `test_analyze_sentiment`
   |
29 | @pytest.mark.asyncio()
30 | async def test_analyze_sentiment(ai_conversation_service):
   |           ^^^^^^^^^^^^^^^^^^^^^^ ANN201
31 |     ai_conversation_service.llm.ainvoke = AsyncMock(
32 |         return_value='{"primary_emotion": "positive", "score": 0.8}'
   |
   = help: Add return type annotation: `None`

tests\app\services\test_ai_conversation_service.py:30:34: ANN001 Missing type annotation for function argument `ai_conversation_service`
   |
29 | @pytest.mark.asyncio()
30 | async def test_analyze_sentiment(ai_conversation_service):
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^ ANN001
31 |     ai_conversation_service.llm.ainvoke = AsyncMock(
32 |         return_value='{"primary_emotion": "positive", "score": 0.8}'
   |

tests\app\services\test_ai_conversation_service.py:38:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
38 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
39 | async def test_save_conversation_metrics(ai_conversation_service):
40 |     # Mockear el método save_metrics_to_db
   |
   = help: Remove parentheses

tests\app\services\test_ai_conversation_service.py:39:11: ANN201 Missing return type annotation for public function `test_save_conversation_metrics`
   |
38 | @pytest.mark.asyncio()
39 | async def test_save_conversation_metrics(ai_conversation_service):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
40 |     # Mockear el método save_metrics_to_db
41 |     ai_conversation_service.save_metrics_to_db = AsyncMock()
   |
   = help: Add return type annotation: `None`

tests\app\services\test_ai_conversation_service.py:39:42: ANN001 Missing type annotation for function argument `ai_conversation_service`
   |
38 | @pytest.mark.asyncio()
39 | async def test_save_conversation_metrics(ai_conversation_service):
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ ANN001
40 |     # Mockear el método save_metrics_to_db
41 |     ai_conversation_service.save_metrics_to_db = AsyncMock()
   |

tests\app\services\test_ai_conversation_service.py:56:41: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
54 |     args, kwargs = ai_conversation_service.save_metrics_to_db.call_args
55 |     assert args[0]["conversation_id"] == "123"
56 |     assert args[0]["message_length"] == 4
   |                                         ^ PLR2004
57 |     assert args[0]["response_sentiment"] == "positive"
58 |     assert args[0]["response_sentiment_score"] == 0.8
   |

tests\app\services\test_ai_conversation_service.py:58:51: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
   |
56 |     assert args[0]["message_length"] == 4
57 |     assert args[0]["response_sentiment"] == "positive"
58 |     assert args[0]["response_sentiment_score"] == 0.8
   |                                                   ^^^ PLR2004
   |

tests\app\services\test_ai_conversation_service.py:61:5: ANN201 Missing return type annotation for public function `test_extract_conversation_context`
   |
61 | def test_extract_conversation_context(ai_conversation_service):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
62 |     memory = ConversationBufferMemory()
63 |     memory.save_context({"input": "Hola"}, {"output": "Hola, ¿en qué puedo ayudarte?"})
   |
   = help: Add return type annotation: `None`

tests\app\services\test_ai_conversation_service.py:61:39: ANN001 Missing type annotation for function argument `ai_conversation_service`
   |
61 | def test_extract_conversation_context(ai_conversation_service):
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^ ANN001
62 |     memory = ConversationBufferMemory()
63 |     memory.save_context({"input": "Hola"}, {"output": "Hola, ¿en qué puedo ayudarte?"})
   |

tests\app\services\test_ai_conversation_service.py:62:14: F821 Undefined name `ConversationBufferMemory`
   |
61 | def test_extract_conversation_context(ai_conversation_service):
62 |     memory = ConversationBufferMemory()
   |              ^^^^^^^^^^^^^^^^^^^^^^^^ F821
63 |     memory.save_context({"input": "Hola"}, {"output": "Hola, ¿en qué puedo ayudarte?"})
64 |     context = ai_conversation_service.extract_conversation_context(memory)
   |

tests\app\services\test_ai_conversation_service.py:69:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
69 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
70 | async def test_get_from_cache(ai_conversation_service):
71 |     ai_conversation_service.get_from_cache = AsyncMock(
   |
   = help: Remove parentheses

tests\app\services\test_ai_conversation_service.py:70:11: ANN201 Missing return type annotation for public function `test_get_from_cache`
   |
69 | @pytest.mark.asyncio()
70 | async def test_get_from_cache(ai_conversation_service):
   |           ^^^^^^^^^^^^^^^^^^^ ANN201
71 |     ai_conversation_service.get_from_cache = AsyncMock(
72 |         return_value=[
   |
   = help: Add return type annotation: `None`

tests\app\services\test_ai_conversation_service.py:70:31: ANN001 Missing type annotation for function argument `ai_conversation_service`
   |
69 | @pytest.mark.asyncio()
70 | async def test_get_from_cache(ai_conversation_service):
   |                               ^^^^^^^^^^^^^^^^^^^^^^^ ANN001
71 |     ai_conversation_service.get_from_cache = AsyncMock(
72 |         return_value=[
   |

tests\app\services\test_ai_conversation_service.py:84:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
84 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
85 | async def test_set_in_cache(ai_conversation_service):
86 |     ai_conversation_service.set_in_cache = AsyncMock()
   |
   = help: Remove parentheses

tests\app\services\test_ai_conversation_service.py:85:11: ANN201 Missing return type annotation for public function `test_set_in_cache`
   |
84 | @pytest.mark.asyncio()
85 | async def test_set_in_cache(ai_conversation_service):
   |           ^^^^^^^^^^^^^^^^^ ANN201
86 |     ai_conversation_service.set_in_cache = AsyncMock()
87 |     await ai_conversation_service.set_in_cache(
   |
   = help: Add return type annotation: `None`

tests\app\services\test_ai_conversation_service.py:85:29: ANN001 Missing type annotation for function argument `ai_conversation_service`
   |
84 | @pytest.mark.asyncio()
85 | async def test_set_in_cache(ai_conversation_service):
   |                             ^^^^^^^^^^^^^^^^^^^^^^^ ANN001
86 |     ai_conversation_service.set_in_cache = AsyncMock()
87 |     await ai_conversation_service.set_in_cache(
   |

tests\app\services\test_call_service.py:8:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
 8 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
 9 | def mock_supabase():
10 |     return AsyncMock()
   |
   = help: Remove parentheses

tests\app\services\test_call_service.py:9:5: ANN201 Missing return type annotation for public function `mock_supabase`
   |
 8 | @pytest.fixture()
 9 | def mock_supabase():
   |     ^^^^^^^^^^^^^ ANN201
10 |     return AsyncMock()
   |
   = help: Add return type annotation

tests\app\services\test_call_service.py:13:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
13 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
14 | def mock_elevenlabs_service():
15 |     return MagicMock()
   |
   = help: Remove parentheses

tests\app\services\test_call_service.py:14:5: ANN201 Missing return type annotation for public function `mock_elevenlabs_service`
   |
13 | @pytest.fixture()
14 | def mock_elevenlabs_service():
   |     ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
15 |     return MagicMock()
   |
   = help: Add return type annotation

tests\app\services\test_call_service.py:18:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
18 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
19 | def mock_ai_service():
20 |     return MagicMock()
   |
   = help: Remove parentheses

tests\app\services\test_call_service.py:19:5: ANN201 Missing return type annotation for public function `mock_ai_service`
   |
18 | @pytest.fixture()
19 | def mock_ai_service():
   |     ^^^^^^^^^^^^^^^ ANN201
20 |     return MagicMock()
   |
   = help: Add return type annotation

tests\app\services\test_call_service.py:23:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
23 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
24 | async def test_handle_call_end(mock_supabase, mock_elevenlabs_service, mock_ai_service):
25 |     # Arrange
   |
   = help: Remove parentheses

tests\app\services\test_call_service.py:24:11: ANN201 Missing return type annotation for public function `test_handle_call_end`
   |
23 | @pytest.mark.asyncio()
24 | async def test_handle_call_end(mock_supabase, mock_elevenlabs_service, mock_ai_service):
   |           ^^^^^^^^^^^^^^^^^^^^ ANN201
25 |     # Arrange
26 |     call_service = CallService(
   |
   = help: Add return type annotation: `None`

tests\app\services\test_call_service.py:24:32: ANN001 Missing type annotation for function argument `mock_supabase`
   |
23 | @pytest.mark.asyncio()
24 | async def test_handle_call_end(mock_supabase, mock_elevenlabs_service, mock_ai_service):
   |                                ^^^^^^^^^^^^^ ANN001
25 |     # Arrange
26 |     call_service = CallService(
   |

tests\app\services\test_call_service.py:24:47: ANN001 Missing type annotation for function argument `mock_elevenlabs_service`
   |
23 | @pytest.mark.asyncio()
24 | async def test_handle_call_end(mock_supabase, mock_elevenlabs_service, mock_ai_service):
   |                                               ^^^^^^^^^^^^^^^^^^^^^^^ ANN001
25 |     # Arrange
26 |     call_service = CallService(
   |

tests\app\services\test_call_service.py:24:72: ANN001 Missing type annotation for function argument `mock_ai_service`
   |
23 | @pytest.mark.asyncio()
24 | async def test_handle_call_end(mock_supabase, mock_elevenlabs_service, mock_ai_service):
   |                                                                        ^^^^^^^^^^^^^^^ ANN001
25 |     # Arrange
26 |     call_service = CallService(
   |

tests\app\services\test_call_service.py:38:5: ERA001 Found commented-out code
   |
36 |     # Assert
37 |     mock_elevenlabs_service.close_conversation.assert_called_once()
38 |     # mock_ai_service.end_conversation.assert_called_once_with(conversation_id=call_id)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ERA001
39 |     mock_supabase.table.assert_called_once_with("calls")
40 |     mock_supabase.table().update.assert_called_once_with({"status": "completed", "end_time": ANY})
   |
   = help: Remove commented-out code

tests\mocks\elevenlabs_mock.py:5:9: ANN204 Missing return type annotation for special method `__init__`
  |
4 | class MockVoiceSettings:
5 |     def __init__(self, stability=0.7, similarity_boost=0.75):
  |         ^^^^^^^^ ANN204
6 |         self.stability = stability
7 |         self.similarity_boost = similarity_boost
  |
  = help: Add return type annotation: `None`

tests\mocks\elevenlabs_mock.py:5:24: ANN001 Missing type annotation for function argument `stability`
  |
4 | class MockVoiceSettings:
5 |     def __init__(self, stability=0.7, similarity_boost=0.75):
  |                        ^^^^^^^^^ ANN001
6 |         self.stability = stability
7 |         self.similarity_boost = similarity_boost
  |

tests\mocks\elevenlabs_mock.py:5:39: ANN001 Missing type annotation for function argument `similarity_boost`
  |
4 | class MockVoiceSettings:
5 |     def __init__(self, stability=0.7, similarity_boost=0.75):
  |                                       ^^^^^^^^^^^^^^^^ ANN001
6 |         self.stability = stability
7 |         self.similarity_boost = similarity_boost
  |

tests\mocks\elevenlabs_mock.py:11:9: ANN204 Missing return type annotation for special method `__init__`
   |
10 | class MockConversation:
11 |     def __init__(self, voice="Bella", voice_settings=None):
   |         ^^^^^^^^ ANN204
12 |         self.voice = voice
13 |         self.voice_settings = voice_settings or MockVoiceSettings()
   |
   = help: Add return type annotation: `None`

tests\mocks\elevenlabs_mock.py:11:24: ANN001 Missing type annotation for function argument `voice`
   |
10 | class MockConversation:
11 |     def __init__(self, voice="Bella", voice_settings=None):
   |                        ^^^^^ ANN001
12 |         self.voice = voice
13 |         self.voice_settings = voice_settings or MockVoiceSettings()
   |

tests\mocks\elevenlabs_mock.py:11:39: ANN001 Missing type annotation for function argument `voice_settings`
   |
10 | class MockConversation:
11 |     def __init__(self, voice="Bella", voice_settings=None):
   |                                       ^^^^^^^^^^^^^^ ANN001
12 |         self.voice = voice
13 |         self.voice_settings = voice_settings or MockVoiceSettings()
   |

tests\mocks\elevenlabs_mock.py:15:9: ANN201 Missing return type annotation for public function `generate`
   |
13 |         self.voice_settings = voice_settings or MockVoiceSettings()
14 |
15 |     def generate(self, text):
   |         ^^^^^^^^ ANN201
16 |         return b"mock_audio_data"
   |
   = help: Add return type annotation: `bytes`

tests\mocks\elevenlabs_mock.py:15:24: ANN001 Missing type annotation for function argument `text`
   |
13 |         self.voice_settings = voice_settings or MockVoiceSettings()
14 |
15 |     def generate(self, text):
   |                        ^^^^ ANN001
16 |         return b"mock_audio_data"
   |

tests\mocks\elevenlabs_mock.py:15:24: ARG002 Unused method argument: `text`
   |
13 |         self.voice_settings = voice_settings or MockVoiceSettings()
14 |
15 |     def generate(self, text):
   |                        ^^^^ ARG002
16 |         return b"mock_audio_data"
   |

tests\routers\test_call_webhook.py:5:1: UP035 `typing.List` is deprecated, use `list` instead
  |
3 | import json
4 | from collections.abc import AsyncGenerator
5 | from typing import List
  | ^^^^^^^^^^^^^^^^^^^^^^^ UP035
6 | from unittest.mock import AsyncMock, MagicMock
  |

tests\routers\test_call_webhook.py:17:47: UP006 [*] Use `list` instead of `List` for type annotation
   |
16 | # --- Mock del Generador Asíncrono ---
17 | async def mock_audio_stream_generator(chunks: List[bytes]) -> AsyncGenerator[bytes, None]:
   |                                               ^^^^ UP006
18 |     """Un generador asíncrono simple para usar en los mocks."""
19 |     for chunk in chunks:
   |
   = help: Replace with `list`

tests\routers\test_call_webhook.py:26:5: ANN201 Missing return type annotation for public function `client`
   |
24 | # --- Fixture para el TestClient ---
25 | @pytest.fixture(scope="module")
26 | def client():
   |     ^^^^^^ ANN201
27 |     """Crea un TestClient para la aplicación."""
28 |     return TestClient(app)
   |
   = help: Add return type annotation

tests\routers\test_call_webhook.py:32:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
31 | # --- Tests ---
32 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
33 | async def test_handle_webhook_user_input_success(client: TestClient, mocker: MagicMock):
34 |     """
   |
   = help: Remove parentheses

tests\routers\test_call_webhook.py:33:11: ANN201 Missing return type annotation for public function `test_handle_webhook_user_input_success`
   |
31 | # --- Tests ---
32 | @pytest.mark.asyncio()
33 | async def test_handle_webhook_user_input_success(client: TestClient, mocker: MagicMock):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
34 |     """
35 |     Prueba el webhook cuando recibe input del usuario y debe devolver audio.
   |
   = help: Add return type annotation: `None`

tests\routers\test_call_webhook.py:71:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
70 |     # 5. Verificar Respuesta HTTP
71 |     assert response.status_code == 200
   |                                    ^^^ PLR2004
72 |     assert response.headers["content-type"] == "audio/mpeg"  # O el media type correcto
73 |     # Iterar sobre la respuesta de streaming para verificar el contenido
   |

tests\routers\test_call_webhook.py:90:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
90 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
91 | async def test_handle_webhook_call_ended(client: TestClient, mocker: MagicMock):
92 |     """
   |
   = help: Remove parentheses

tests\routers\test_call_webhook.py:91:11: ANN201 Missing return type annotation for public function `test_handle_webhook_call_ended`
   |
90 | @pytest.mark.asyncio()
91 | async def test_handle_webhook_call_ended(client: TestClient, mocker: MagicMock):
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
92 |     """
93 |     Prueba el webhook cuando recibe un evento de finalización de llamada.
   |
   = help: Add return type annotation: `None`

tests\routers\test_call_webhook.py:112:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
111 |     # 5. Verificar Respuesta HTTP
112 |     assert response.status_code == 200
    |                                    ^^^ PLR2004
113 |     assert response.content == b""  # Esperamos cuerpo vacío
    |

tests\routers\test_call_webhook.py:125:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
125 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
126 | async def test_handle_webhook_streaming_error(client: TestClient, mocker: MagicMock):
127 |     """Prueba el manejo de StreamingError durante la generación de audio."""
    |
    = help: Remove parentheses

tests\routers\test_call_webhook.py:126:11: ANN201 Missing return type annotation for public function `test_handle_webhook_streaming_error`
    |
125 | @pytest.mark.asyncio()
126 | async def test_handle_webhook_streaming_error(client: TestClient, mocker: MagicMock):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
127 |     """Prueba el manejo de StreamingError durante la generación de audio."""
128 |     fake_call_sid = "CAzzzzzzzzzzzzzzzzzzzzzzzzzzzz"
    |
    = help: Add return type annotation: `None`

tests\routers\test_call_webhook.py:145:36: PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
    |
143 |     response = client.post("/api/v1/calls/webhook", json=fake_payload)
144 |
145 |     assert response.status_code == 500
    |                                    ^^^ PLR2004
146 |     assert response.content == b""
147 |     mock_call_service_instance.handle_call_response.assert_awaited_once_with(
    |

tests\routers\test_call_webhook.py:154:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
154 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
155 | async def test_handle_webhook_form_data(client: TestClient, mocker: MagicMock):
156 |     """Prueba el manejo de payload en formato form-data."""
    |
    = help: Remove parentheses

tests\routers\test_call_webhook.py:155:11: ANN201 Missing return type annotation for public function `test_handle_webhook_form_data`
    |
154 | @pytest.mark.asyncio()
155 | async def test_handle_webhook_form_data(client: TestClient, mocker: MagicMock):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
156 |     """Prueba el manejo de payload en formato form-data."""
157 |     fake_call_sid = "CAwwwwwwwwwwwwwwwwwwwwwwwwww"
    |
    = help: Add return type annotation: `None`

tests\routers\test_call_webhook.py:179:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
177 |     )
178 |
179 |     assert response.status_code == 200
    |                                    ^^^ PLR2004
180 |     assert response.headers["content-type"] == "audio/mpeg"
181 |     # Iterar sobre la respuesta de streaming para verificar el contenido
    |

tests\routers\test_call_webhook.py:190:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
190 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
191 | async def test_handle_webhook_intermediate_event(client: TestClient, mocker: MagicMock):
192 |     """Prueba el manejo de eventos intermedios sin input de usuario."""
    |
    = help: Remove parentheses

tests\routers\test_call_webhook.py:191:11: ANN201 Missing return type annotation for public function `test_handle_webhook_intermediate_event`
    |
190 | @pytest.mark.asyncio()
191 | async def test_handle_webhook_intermediate_event(client: TestClient, mocker: MagicMock):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
192 |     """Prueba el manejo de eventos intermedios sin input de usuario."""
193 |     fake_call_sid = "CAvvvvvvvvvvvvvvvvvvvvvvvvvv"
    |
    = help: Add return type annotation: `None`

tests\routers\test_call_webhook.py:201:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
199 |     response = client.post("/api/v1/calls/webhook", json=fake_payload)
200 |
201 |     assert response.status_code == 200
    |                                    ^^^ PLR2004
202 |     assert response.content == b""
203 |     mock_call_service_instance.handle_call_response.assert_not_called()
    |

tests\routers\test_call_webhook.py:209:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
209 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
210 | async def test_handle_webhook_invalid_json(client: TestClient, mocker: MagicMock):
211 |     """Prueba el manejo de JSON inválido en el payload."""
    |
    = help: Remove parentheses

tests\routers\test_call_webhook.py:210:11: ANN201 Missing return type annotation for public function `test_handle_webhook_invalid_json`
    |
209 | @pytest.mark.asyncio()
210 | async def test_handle_webhook_invalid_json(client: TestClient, mocker: MagicMock):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
211 |     """Prueba el manejo de JSON inválido en el payload."""
212 |     invalid_json = "{"
    |
    = help: Add return type annotation: `None`

tests\routers\test_call_webhook.py:223:36: PLR2004 Magic value used in comparison, consider replacing `422` with a constant variable
    |
221 |     )
222 |
223 |     assert response.status_code == 422
    |                                    ^^^ PLR2004
224 |     mock_call_service_instance.handle_call_response.assert_not_called()
225 |     mock_call_service_instance.handle_call_end.assert_not_called()
    |

tests\routers\test_call_webhook.py:230:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
    |
230 | @pytest.mark.asyncio()
    | ^^^^^^^^^^^^^^^^^^^^^^ PT023
231 | async def test_handle_webhook_metadata_parsing(client: TestClient, mocker: MagicMock):
232 |     """Prueba el manejo de metadata en formato JSON string."""
    |
    = help: Remove parentheses

tests\routers\test_call_webhook.py:231:11: ANN201 Missing return type annotation for public function `test_handle_webhook_metadata_parsing`
    |
230 | @pytest.mark.asyncio()
231 | async def test_handle_webhook_metadata_parsing(client: TestClient, mocker: MagicMock):
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ANN201
232 |     """Prueba el manejo de metadata en formato JSON string."""
233 |     fake_call_sid = "CAuuuuuuuuuuuuuuuuuuuuuuuuuu"
    |
    = help: Add return type annotation: `None`

tests\routers\test_call_webhook.py:252:36: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
250 |     response = client.post("/api/v1/calls/webhook", json=fake_payload)
251 |
252 |     assert response.status_code == 200
    |                                    ^^^ PLR2004
253 |     assert response.headers["content-type"] == "audio/mpeg"
254 |     # Iterar sobre la respuesta de streaming para verificar el contenido
    |

tests\test_services\test_elevenlabs_service.py:8:1: PT001 [*] Use `@pytest.fixture` over `@pytest.fixture()`
   |
 8 | @pytest.fixture()
   | ^^^^^^^^^^^^^^^^^ PT001
 9 | def elevenlabs_service():
10 |     service = ElevenLabsService()
   |
   = help: Remove parentheses

tests\test_services\test_elevenlabs_service.py:9:5: ANN201 Missing return type annotation for public function `elevenlabs_service`
   |
 8 | @pytest.fixture()
 9 | def elevenlabs_service():
   |     ^^^^^^^^^^^^^^^^^^ ANN201
10 |     service = ElevenLabsService()
11 |     return service
   |
   = help: Add return type annotation

tests\test_services\test_elevenlabs_service.py:11:12: RET504 Unnecessary assignment to `service` before `return` statement
   |
 9 | def elevenlabs_service():
10 |     service = ElevenLabsService()
11 |     return service
   |            ^^^^^^^ RET504
   |
   = help: Remove unnecessary assignment

tests\test_services\test_elevenlabs_service.py:14:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
14 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
15 | async def test_generate_audio(elevenlabs_service):
16 |     """Prueba la generación de audio."""
   |
   = help: Remove parentheses

tests\test_services\test_elevenlabs_service.py:15:11: ANN201 Missing return type annotation for public function `test_generate_audio`
   |
14 | @pytest.mark.asyncio()
15 | async def test_generate_audio(elevenlabs_service):
   |           ^^^^^^^^^^^^^^^^^^^ ANN201
16 |     """Prueba la generación de audio."""
17 |     test_text = "Texto de prueba"
   |
   = help: Add return type annotation: `None`

tests\test_services\test_elevenlabs_service.py:15:31: ANN001 Missing type annotation for function argument `elevenlabs_service`
   |
14 | @pytest.mark.asyncio()
15 | async def test_generate_audio(elevenlabs_service):
   |                               ^^^^^^^^^^^^^^^^^^ ANN001
16 |     """Prueba la generación de audio."""
17 |     test_text = "Texto de prueba"
   |

tests\test_services\test_elevenlabs_service.py:28:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
28 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
29 | async def test_start_conversation(elevenlabs_service):
30 |     """Prueba el inicio de una conversación."""
   |
   = help: Remove parentheses

tests\test_services\test_elevenlabs_service.py:29:11: ANN201 Missing return type annotation for public function `test_start_conversation`
   |
28 | @pytest.mark.asyncio()
29 | async def test_start_conversation(elevenlabs_service):
   |           ^^^^^^^^^^^^^^^^^^^^^^^ ANN201
30 |     """Prueba el inicio de una conversación."""
31 |     test_voice = "Bella"
   |
   = help: Add return type annotation: `None`

tests\test_services\test_elevenlabs_service.py:29:35: ANN001 Missing type annotation for function argument `elevenlabs_service`
   |
28 | @pytest.mark.asyncio()
29 | async def test_start_conversation(elevenlabs_service):
   |                                   ^^^^^^^^^^^^^^^^^^ ANN001
30 |     """Prueba el inicio de una conversación."""
31 |     test_voice = "Bella"
   |

tests\test_services\test_elevenlabs_service.py:39:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
39 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
40 | async def test_generate_response(elevenlabs_service):
41 |     """Prueba la generación de respuesta en una conversación."""
   |
   = help: Remove parentheses

tests\test_services\test_elevenlabs_service.py:40:11: ANN201 Missing return type annotation for public function `test_generate_response`
   |
39 | @pytest.mark.asyncio()
40 | async def test_generate_response(elevenlabs_service):
   |           ^^^^^^^^^^^^^^^^^^^^^^ ANN201
41 |     """Prueba la generación de respuesta en una conversación."""
42 |     test_text = "Hola mundo"
   |
   = help: Add return type annotation: `None`

tests\test_services\test_elevenlabs_service.py:40:34: ANN001 Missing type annotation for function argument `elevenlabs_service`
   |
39 | @pytest.mark.asyncio()
40 | async def test_generate_response(elevenlabs_service):
   |                                  ^^^^^^^^^^^^^^^^^^ ANN001
41 |     """Prueba la generación de respuesta en una conversación."""
42 |     test_text = "Hola mundo"
   |

tests\test_services\test_elevenlabs_service.py:54:1: PT023 [*] Use `@pytest.mark.asyncio` over `@pytest.mark.asyncio()`
   |
54 | @pytest.mark.asyncio()
   | ^^^^^^^^^^^^^^^^^^^^^^ PT023
55 | async def test_error_handling(elevenlabs_service):
56 |     """Prueba el manejo de errores."""
   |
   = help: Remove parentheses

tests\test_services\test_elevenlabs_service.py:55:11: ANN201 Missing return type annotation for public function `test_error_handling`
   |
54 | @pytest.mark.asyncio()
55 | async def test_error_handling(elevenlabs_service):
   |           ^^^^^^^^^^^^^^^^^^^ ANN201
56 |     """Prueba el manejo de errores."""
57 |     with patch("app.services.elevenlabs_service.generate", side_effect=Exception("API Error")):
   |
   = help: Add return type annotation: `None`

tests\test_services\test_elevenlabs_service.py:55:31: ANN001 Missing type annotation for function argument `elevenlabs_service`
   |
54 | @pytest.mark.asyncio()
55 | async def test_error_handling(elevenlabs_service):
   |                               ^^^^^^^^^^^^^^^^^^ ANN001
56 |     """Prueba el manejo de errores."""
57 |     with patch("app.services.elevenlabs_service.generate", side_effect=Exception("API Error")):
   |

tests\test_services\test_elevenlabs_service.py:58:28: PT011 `pytest.raises(Exception)` is too broad, set the `match` parameter or use a more specific exception
   |
56 |     """Prueba el manejo de errores."""
57 |     with patch("app.services.elevenlabs_service.generate", side_effect=Exception("API Error")):
58 |         with pytest.raises(Exception) as exc_info:
   |                            ^^^^^^^^^ PT011
59 |             await elevenlabs_service.generate_audio("test")
60 |         assert "API Error" in str(exc_info.value)
   |

Found 1483 errors.
[*] 293 fixable with the `--fix` option (284 hidden fixes can be enabled with the `--unsafe-fixes` option).
